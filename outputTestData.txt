1:	Computer Science 42SAP - Mr. Wachs' Computer Science content running simulated:............
2:	Computer Science 42SAP - Computer Science 20S Course content running simulated:............
3:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
4:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
5:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
6:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
7:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
8:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
9:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
10:	Computer Science 42SAP - Computer Science 30S Course content running simulated:............
11:	Hello World I'm in The world!
12:	Good-bye World
13:	Make a quote " 
14:	Make a slash \ 
15:	Make a 	 tab 
16:	Make a 
 new line break
17:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
18:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
19:	~~~ SIMULATED {Message Information Title  simulated message} DIALOG: 
20:	~~~ SIMULATED {Message Question Title  simulated message} DIALOG: 
21:	~~~ SIMULATED {Message Warning Title  simulated message} DIALOG: 
22:	~~~ SIMULATED {Message Error Title  simulated message} DIALOG: 
23:	~~~ SIMULATED {Message Plain Title  simulated message} DIALOG: 
24:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
25:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
26:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
27:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
28:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
29:	~~~ SIMULATED {Confirm null  simulated message} DIALOG: 
30:	~~~ SIMULATED {Confirm Information  simulated message} DIALOG: 
31:	~~~ SIMULATED {Confirm Question  simulated message} DIALOG: 
32:	~~~ SIMULATED {Confirm Warning  simulated message} DIALOG: 
33:	~~~ SIMULATED {Confirm Error  simulated message} DIALOG: 
34:	~~~ SIMULATED {Confirm Plain  simulated message} DIALOG: 
35:	a = false
36:	b = 1
37:	c = 1.2
38:	d = A
39:	e = apple
40:	x = 0
41:	x = 20
42:	y = 30
43:	y = 30
44:	x = 28
45:	y = 5
46:	z = 3
47:	3.141592653589793,99,Y,true,Wachs
48:	f = 25
49:	g = 25.0
50:	g = 25.9999999999999
51:	h = 25
52:	k = 2.9999999999
53:	l = 2
54:	m = 2.0
55:	n = A
56:	o = 65
57:	p = F
58:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
59:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
60:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
61:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
62:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
63:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
64:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
65:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
66:	word hippopotomonsprosesquippedaiophobia is length 35
67:	word hippopotomonsprosesquippedaiophobia in upper case is HIPPOPOTOMONSPROSESQUIPPEDAIOPHOBIA
68:	answer1 = 3.141592653589793
69:	answer2 = 0.8775825618903728
70:	answer3 = 1.0
71:	answer4 = 125.0
72:	answer5 = 3.0
73:	answer6 = -0.6931471805599453
74:	seed = 0.9757182739072108
75:	number = 10.757182739072107
76:	value = 10
77:	card = 39
78:	equal
79:	less than
80:	!=
81:	kind of equal
82:	Keep trying...
83:	counter = 0
84:	counter = 1
85:	counter = 2
86:	counter = 3
87:	counter = 4
88:	counter = 5
89:	counter = 6
90:	counter = 7
91:	counter = 8
92:	counter = 9
93:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
94:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
95:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
96:	0
97:	1
98:	2
99:	3
100:	4
101:	5
102:	6
103:	7
104:	8
105:	9
106:	i = 100
107:	i = 90
108:	i = 80
109:	i = 70
110:	i = 60
111:	i = 50
112:	i = 40
113:	i = 30
114:	i = 20
115:	i = 10
116:	i = 0
117:	counting = 100
118:	counting = 200
119:	counting = 400
120:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
121:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
122:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
123:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
124:	Start learning methods...
125:	*
126:	*
127:	something
128:	Spider-man
129:	Batman
130:	Superman
131:	Omni-man
132:	Mr. Wachs
133:	Dalmations
134:	Dalmations
135:	Dalmations
136:	Dalmations
137:	Dalmations
138:	Dalmations
139:	Dalmations
140:	Dalmations
141:	Dalmations
142:	Dalmations
143:	Dalmations
144:	Dalmations
145:	Dalmations
146:	Dalmations
147:	Dalmations
148:	Dalmations
149:	Dalmations
150:	Dalmations
151:	Dalmations
152:	Dalmations
153:	Dalmations
154:	Dalmations
155:	Dalmations
156:	Dalmations
157:	Dalmations
158:	Dalmations
159:	Dalmations
160:	Dalmations
161:	Dalmations
162:	Dalmations
163:	Dalmations
164:	Dalmations
165:	Dalmations
166:	Dalmations
167:	Dalmations
168:	Dalmations
169:	Dalmations
170:	Dalmations
171:	Dalmations
172:	Dalmations
173:	Dalmations
174:	Dalmations
175:	Dalmations
176:	Dalmations
177:	Dalmations
178:	Dalmations
179:	Dalmations
180:	Dalmations
181:	Dalmations
182:	Dalmations
183:	Dalmations
184:	Dalmations
185:	Dalmations
186:	Dalmations
187:	Dalmations
188:	Dalmations
189:	Dalmations
190:	Dalmations
191:	Dalmations
192:	Dalmations
193:	Dalmations
194:	Dalmations
195:	Dalmations
196:	Dalmations
197:	Dalmations
198:	Dalmations
199:	Dalmations
200:	Dalmations
201:	Dalmations
202:	Dalmations
203:	Dalmations
204:	Dalmations
205:	Dalmations
206:	Dalmations
207:	Dalmations
208:	Dalmations
209:	Dalmations
210:	Dalmations
211:	Dalmations
212:	Dalmations
213:	Dalmations
214:	Dalmations
215:	Dalmations
216:	Dalmations
217:	Dalmations
218:	Dalmations
219:	Dalmations
220:	Dalmations
221:	Dalmations
222:	Dalmations
223:	Dalmations
224:	Dalmations
225:	Dalmations
226:	Dalmations
227:	Dalmations
228:	Dalmations
229:	Dalmations
230:	Dalmations
231:	Dalmations
232:	Dalmations
233:	Dalmations
234:	Problems
235:	Problems
236:	Problems
237:	Problems
238:	Problems
239:	Problems
240:	Problems
241:	Problems
242:	Problems
243:	Problems
244:	Problems
245:	Problems
246:	Problems
247:	Problems
248:	Problems
249:	Problems
250:	Problems
251:	Problems
252:	Problems
253:	Problems
254:	Problems
255:	Problems
256:	Problems
257:	Problems
258:	Problems
259:	Problems
260:	Problems
261:	Problems
262:	Problems
263:	Problems
264:	Problems
265:	Problems
266:	Problems
267:	Problems
268:	Problems
269:	Problems
270:	Problems
271:	Problems
272:	Problems
273:	Problems
274:	Problems
275:	Problems
276:	Problems
277:	Problems
278:	Problems
279:	Problems
280:	Problems
281:	Problems
282:	Problems
283:	Problems
284:	Problems
285:	Problems
286:	Problems
287:	Problems
288:	Problems
289:	Problems
290:	Problems
291:	Problems
292:	Problems
293:	Problems
294:	Problems
295:	Problems
296:	Problems
297:	Problems
298:	Problems
299:	Problems
300:	Problems
301:	Problems
302:	Problems
303:	Problems
304:	Problems
305:	Problems
306:	Problems
307:	Problems
308:	Problems
309:	Problems
310:	Problems
311:	Problems
312:	Problems
313:	Problems
314:	Problems
315:	Problems
316:	Problems
317:	Problems
318:	Problems
319:	Problems
320:	Problems
321:	Problems
322:	Problems
323:	Problems
324:	Problems
325:	Problems
326:	Problems
327:	Problems
328:	Problems
329:	Problems
330:	Problems
331:	Problems
332:	Problems
333:	Number was 3
334:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
335:	~~~ SIMULATED {Message Learning  simulated message} DIALOG: 
336:	Completed learning methods!
337:	Start Learning Arrays...
338:	666
339:	0 = 666
340:	1 = 0
341:	2 = 0
342:	3 = 0
343:	4 = 0
344:	5 = 0
345:	6 = 0
346:	7 = 0
347:	8 = 0
348:	9 = 0
349:	10 = 0
350:	11 = 0
351:	12 = 0
352:	13 = 0
353:	14 = 0
354:	15 = 0
355:	16 = 0
356:	17 = 0
357:	18 = 0
358:	19 = 0
359:	20 = 0
360:	21 = 0
361:	22 = 0
362:	23 = 0
363:	24 = 0
364:	25 = 0
365:	26 = 0
366:	27 = 0
367:	28 = 0
368:	29 = 0
369:	30 = 0
370:	31 = 0
371:	32 = 0
372:	33 = 0
373:	34 = 0
374:	35 = 0
375:	36 = 0
376:	37 = 0
377:	38 = 0
378:	39 = 0
379:	40 = 0
380:	41 = 0
381:	42 = 0
382:	43 = 0
383:	44 = 0
384:	45 = 0
385:	46 = 0
386:	47 = 0
387:	48 = 0
388:	49 = 0
389:	50 = 0
390:	51 = 0
391:	52 = 0
392:	53 = 0
393:	54 = 0
394:	55 = 0
395:	56 = 0
396:	57 = 0
397:	58 = 0
398:	59 = 0
399:	60 = 0
400:	61 = 0
401:	62 = 0
402:	63 = 0
403:	64 = 0
404:	65 = 0
405:	66 = 0
406:	67 = 0
407:	68 = 0
408:	69 = 0
409:	70 = 0
410:	71 = 0
411:	72 = 0
412:	73 = 0
413:	74 = 0
414:	75 = 0
415:	76 = 0
416:	77 = 0
417:	78 = 0
418:	79 = 0
419:	80 = 0
420:	81 = 0
421:	82 = 0
422:	83 = 0
423:	84 = 0
424:	85 = 0
425:	86 = 0
426:	87 = 0
427:	88 = 0
428:	89 = 0
429:	90 = 0
430:	91 = 0
431:	92 = 0
432:	93 = 0
433:	94 = 0
434:	95 = 0
435:	96 = 0
436:	97 = 0
437:	98 = 0
438:	99 = 333
439:	0 = 666 again!
440:	1 = 0 again!
441:	2 = 0 again!
442:	3 = 0 again!
443:	4 = 0 again!
444:	5 = 0 again!
445:	6 = 0 again!
446:	7 = 0 again!
447:	8 = 0 again!
448:	9 = 0 again!
449:	10 = 0 again!
450:	11 = 0 again!
451:	12 = 0 again!
452:	13 = 0 again!
453:	14 = 0 again!
454:	15 = 0 again!
455:	16 = 0 again!
456:	17 = 0 again!
457:	18 = 0 again!
458:	19 = 0 again!
459:	20 = 0 again!
460:	21 = 0 again!
461:	22 = 0 again!
462:	23 = 0 again!
463:	24 = 0 again!
464:	25 = 0 again!
465:	26 = 0 again!
466:	27 = 0 again!
467:	28 = 0 again!
468:	29 = 0 again!
469:	30 = 0 again!
470:	31 = 0 again!
471:	32 = 0 again!
472:	33 = 0 again!
473:	34 = 0 again!
474:	35 = 0 again!
475:	36 = 0 again!
476:	37 = 0 again!
477:	38 = 0 again!
478:	39 = 0 again!
479:	40 = 0 again!
480:	41 = 0 again!
481:	42 = 0 again!
482:	43 = 0 again!
483:	44 = 0 again!
484:	45 = 0 again!
485:	46 = 0 again!
486:	47 = 0 again!
487:	48 = 0 again!
488:	49 = 0 again!
489:	50 = 0 again!
490:	51 = 0 again!
491:	52 = 0 again!
492:	53 = 0 again!
493:	54 = 0 again!
494:	55 = 0 again!
495:	56 = 0 again!
496:	57 = 0 again!
497:	58 = 0 again!
498:	59 = 0 again!
499:	60 = 0 again!
500:	61 = 0 again!
501:	62 = 0 again!
502:	63 = 0 again!
503:	64 = 0 again!
504:	65 = 0 again!
505:	66 = 0 again!
506:	67 = 0 again!
507:	68 = 0 again!
508:	69 = 0 again!
509:	70 = 0 again!
510:	71 = 0 again!
511:	72 = 0 again!
512:	73 = 0 again!
513:	74 = 0 again!
514:	75 = 0 again!
515:	76 = 0 again!
516:	77 = 0 again!
517:	78 = 0 again!
518:	79 = 0 again!
519:	80 = 0 again!
520:	81 = 0 again!
521:	82 = 0 again!
522:	83 = 0 again!
523:	84 = 0 again!
524:	85 = 0 again!
525:	86 = 0 again!
526:	87 = 0 again!
527:	88 = 0 again!
528:	89 = 0 again!
529:	90 = 0 again!
530:	91 = 0 again!
531:	92 = 0 again!
532:	93 = 0 again!
533:	94 = 0 again!
534:	95 = 0 again!
535:	96 = 0 again!
536:	97 = 0 again!
537:	98 = 0 again!
538:	99 = 333 again!
539:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
540:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
541:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
542:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
543:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
544:	Random character was G
545:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
546:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
547:	~~~ SIMULATED {Message The Matrix...  simulated message} DIALOG: 
548:	~~~ SIMULATED {Message Tic-Tac-Toe...  simulated message} DIALOG: 
549:	Completed learning Arrays!
550:	Start learning classes...
551:	Completed learning classes!
552:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
553:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
554:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
555:	Computer Science 42SAP - Computer Science 40S Course content running simulated:............
556:	Recursion test started...
557:	Recursive factorials............................
558:	-1 factorial = 1
559:	0 factorial = 1
560:	1 factorial = 1
561:	2 factorial = 2
562:	3 factorial = 6
563:	4 factorial = 24
564:	5 factorial = 120
565:	6 factorial = 720
566:	7 factorial = 5040
567:	8 factorial = 40320
568:	9 factorial = 362880
569:	10 factorial = 3628800
570:	11 factorial = 39916800
571:	12 factorial = 479001600
572:	13 factorial = 6227020800
573:	14 factorial = 87178291200
574:	15 factorial = 1307674368000
575:	16 factorial = 20922789888000
576:	17 factorial = 355687428096000
577:	18 factorial = 6402373705728000
578:	19 factorial = 121645100408832000
579:	20 factorial = 2432902008176640000
580:	Recursive powers................................
581:	-5 to the exponent -5 = -3.2E-4
582:	-4 to the exponent -5 = -9.765625E-4
583:	-3 to the exponent -5 = -0.00411522633744856
584:	-2 to the exponent -5 = -0.03125
585:	-1 to the exponent -5 = -1.0
586:	0 to the exponent -5 = 4.9E-324
587:	1 to the exponent -5 = 1.0
588:	2 to the exponent -5 = 0.03125
589:	3 to the exponent -5 = 0.00411522633744856
590:	4 to the exponent -5 = 9.765625E-4
591:	5 to the exponent -5 = 3.2E-4
592:	6 to the exponent -5 = 1.286008230452675E-4
593:	7 to the exponent -5 = 5.9499018266198606E-5
594:	8 to the exponent -5 = 3.0517578125E-5
595:	9 to the exponent -5 = 1.6935087808430286E-5
596:	10 to the exponent -5 = 1.0E-5
597:	-5 to the exponent -4 = 0.0016
598:	-4 to the exponent -4 = 0.00390625
599:	-3 to the exponent -4 = 0.012345679012345678
600:	-2 to the exponent -4 = 0.0625
601:	-1 to the exponent -4 = 1.0
602:	0 to the exponent -4 = 4.9E-324
603:	1 to the exponent -4 = 1.0
604:	2 to the exponent -4 = 0.0625
605:	3 to the exponent -4 = 0.012345679012345678
606:	4 to the exponent -4 = 0.00390625
607:	5 to the exponent -4 = 0.0016
608:	6 to the exponent -4 = 7.716049382716049E-4
609:	7 to the exponent -4 = 4.1649312786339027E-4
610:	8 to the exponent -4 = 2.44140625E-4
611:	9 to the exponent -4 = 1.5241579027587258E-4
612:	10 to the exponent -4 = 1.0E-4
613:	-5 to the exponent -3 = -0.008
614:	-4 to the exponent -3 = -0.015625
615:	-3 to the exponent -3 = -0.037037037037037035
616:	-2 to the exponent -3 = -0.125
617:	-1 to the exponent -3 = -1.0
618:	0 to the exponent -3 = 4.9E-324
619:	1 to the exponent -3 = 1.0
620:	2 to the exponent -3 = 0.125
621:	3 to the exponent -3 = 0.037037037037037035
622:	4 to the exponent -3 = 0.015625
623:	5 to the exponent -3 = 0.008
624:	6 to the exponent -3 = 0.004629629629629629
625:	7 to the exponent -3 = 0.0029154518950437317
626:	8 to the exponent -3 = 0.001953125
627:	9 to the exponent -3 = 0.0013717421124828531
628:	10 to the exponent -3 = 0.001
629:	-5 to the exponent -2 = 0.04
630:	-4 to the exponent -2 = 0.0625
631:	-3 to the exponent -2 = 0.1111111111111111
632:	-2 to the exponent -2 = 0.25
633:	-1 to the exponent -2 = 1.0
634:	0 to the exponent -2 = 4.9E-324
635:	1 to the exponent -2 = 1.0
636:	2 to the exponent -2 = 0.25
637:	3 to the exponent -2 = 0.1111111111111111
638:	4 to the exponent -2 = 0.0625
639:	5 to the exponent -2 = 0.04
640:	6 to the exponent -2 = 0.027777777777777776
641:	7 to the exponent -2 = 0.02040816326530612
642:	8 to the exponent -2 = 0.015625
643:	9 to the exponent -2 = 0.012345679012345678
644:	10 to the exponent -2 = 0.01
645:	-5 to the exponent -1 = -0.2
646:	-4 to the exponent -1 = -0.25
647:	-3 to the exponent -1 = -0.3333333333333333
648:	-2 to the exponent -1 = -0.5
649:	-1 to the exponent -1 = -1.0
650:	0 to the exponent -1 = 4.9E-324
651:	1 to the exponent -1 = 1.0
652:	2 to the exponent -1 = 0.5
653:	3 to the exponent -1 = 0.3333333333333333
654:	4 to the exponent -1 = 0.25
655:	5 to the exponent -1 = 0.2
656:	6 to the exponent -1 = 0.16666666666666666
657:	7 to the exponent -1 = 0.14285714285714285
658:	8 to the exponent -1 = 0.125
659:	9 to the exponent -1 = 0.1111111111111111
660:	10 to the exponent -1 = 0.1
661:	-5 to the exponent 0 = 1.0
662:	-4 to the exponent 0 = 1.0
663:	-3 to the exponent 0 = 1.0
664:	-2 to the exponent 0 = 1.0
665:	-1 to the exponent 0 = 1.0
666:	0 to the exponent 0 = 1.0
667:	1 to the exponent 0 = 1.0
668:	2 to the exponent 0 = 1.0
669:	3 to the exponent 0 = 1.0
670:	4 to the exponent 0 = 1.0
671:	5 to the exponent 0 = 1.0
672:	6 to the exponent 0 = 1.0
673:	7 to the exponent 0 = 1.0
674:	8 to the exponent 0 = 1.0
675:	9 to the exponent 0 = 1.0
676:	10 to the exponent 0 = 1.0
677:	-5 to the exponent 1 = -5.0
678:	-4 to the exponent 1 = -4.0
679:	-3 to the exponent 1 = -3.0
680:	-2 to the exponent 1 = -2.0
681:	-1 to the exponent 1 = -1.0
682:	0 to the exponent 1 = 0.0
683:	1 to the exponent 1 = 1.0
684:	2 to the exponent 1 = 2.0
685:	3 to the exponent 1 = 3.0
686:	4 to the exponent 1 = 4.0
687:	5 to the exponent 1 = 5.0
688:	6 to the exponent 1 = 6.0
689:	7 to the exponent 1 = 7.0
690:	8 to the exponent 1 = 8.0
691:	9 to the exponent 1 = 9.0
692:	10 to the exponent 1 = 10.0
693:	-5 to the exponent 2 = 25.0
694:	-4 to the exponent 2 = 16.0
695:	-3 to the exponent 2 = 9.0
696:	-2 to the exponent 2 = 4.0
697:	-1 to the exponent 2 = 1.0
698:	0 to the exponent 2 = 0.0
699:	1 to the exponent 2 = 1.0
700:	2 to the exponent 2 = 4.0
701:	3 to the exponent 2 = 9.0
702:	4 to the exponent 2 = 16.0
703:	5 to the exponent 2 = 25.0
704:	6 to the exponent 2 = 36.0
705:	7 to the exponent 2 = 49.0
706:	8 to the exponent 2 = 64.0
707:	9 to the exponent 2 = 81.0
708:	10 to the exponent 2 = 100.0
709:	-5 to the exponent 3 = -125.0
710:	-4 to the exponent 3 = -64.0
711:	-3 to the exponent 3 = -27.0
712:	-2 to the exponent 3 = -8.0
713:	-1 to the exponent 3 = -1.0
714:	0 to the exponent 3 = 0.0
715:	1 to the exponent 3 = 1.0
716:	2 to the exponent 3 = 8.0
717:	3 to the exponent 3 = 27.0
718:	4 to the exponent 3 = 64.0
719:	5 to the exponent 3 = 125.0
720:	6 to the exponent 3 = 216.0
721:	7 to the exponent 3 = 343.0
722:	8 to the exponent 3 = 512.0
723:	9 to the exponent 3 = 729.0
724:	10 to the exponent 3 = 1000.0
725:	-5 to the exponent 4 = 625.0
726:	-4 to the exponent 4 = 256.0
727:	-3 to the exponent 4 = 81.0
728:	-2 to the exponent 4 = 16.0
729:	-1 to the exponent 4 = 1.0
730:	0 to the exponent 4 = 0.0
731:	1 to the exponent 4 = 1.0
732:	2 to the exponent 4 = 16.0
733:	3 to the exponent 4 = 81.0
734:	4 to the exponent 4 = 256.0
735:	5 to the exponent 4 = 625.0
736:	6 to the exponent 4 = 1296.0
737:	7 to the exponent 4 = 2401.0
738:	8 to the exponent 4 = 4096.0
739:	9 to the exponent 4 = 6561.0
740:	10 to the exponent 4 = 10000.0
741:	-5 to the exponent 5 = -3125.0
742:	-4 to the exponent 5 = -1024.0
743:	-3 to the exponent 5 = -243.0
744:	-2 to the exponent 5 = -32.0
745:	-1 to the exponent 5 = -1.0
746:	0 to the exponent 5 = 0.0
747:	1 to the exponent 5 = 1.0
748:	2 to the exponent 5 = 32.0
749:	3 to the exponent 5 = 243.0
750:	4 to the exponent 5 = 1024.0
751:	5 to the exponent 5 = 3125.0
752:	6 to the exponent 5 = 7776.0
753:	7 to the exponent 5 = 16807.0
754:	8 to the exponent 5 = 32768.0
755:	9 to the exponent 5 = 59049.0
756:	10 to the exponent 5 = 100000.0
757:	-5 to the exponent 6 = 15625.0
758:	-4 to the exponent 6 = 4096.0
759:	-3 to the exponent 6 = 729.0
760:	-2 to the exponent 6 = 64.0
761:	-1 to the exponent 6 = 1.0
762:	0 to the exponent 6 = 0.0
763:	1 to the exponent 6 = 1.0
764:	2 to the exponent 6 = 64.0
765:	3 to the exponent 6 = 729.0
766:	4 to the exponent 6 = 4096.0
767:	5 to the exponent 6 = 15625.0
768:	6 to the exponent 6 = 46656.0
769:	7 to the exponent 6 = 117649.0
770:	8 to the exponent 6 = 262144.0
771:	9 to the exponent 6 = 531441.0
772:	10 to the exponent 6 = 1000000.0
773:	-5 to the exponent 7 = -78125.0
774:	-4 to the exponent 7 = -16384.0
775:	-3 to the exponent 7 = -2187.0
776:	-2 to the exponent 7 = -128.0
777:	-1 to the exponent 7 = -1.0
778:	0 to the exponent 7 = 0.0
779:	1 to the exponent 7 = 1.0
780:	2 to the exponent 7 = 128.0
781:	3 to the exponent 7 = 2187.0
782:	4 to the exponent 7 = 16384.0
783:	5 to the exponent 7 = 78125.0
784:	6 to the exponent 7 = 279936.0
785:	7 to the exponent 7 = 823543.0
786:	8 to the exponent 7 = 2097152.0
787:	9 to the exponent 7 = 4782969.0
788:	10 to the exponent 7 = 1.0E7
789:	-5 to the exponent 8 = 390625.0
790:	-4 to the exponent 8 = 65536.0
791:	-3 to the exponent 8 = 6561.0
792:	-2 to the exponent 8 = 256.0
793:	-1 to the exponent 8 = 1.0
794:	0 to the exponent 8 = 0.0
795:	1 to the exponent 8 = 1.0
796:	2 to the exponent 8 = 256.0
797:	3 to the exponent 8 = 6561.0
798:	4 to the exponent 8 = 65536.0
799:	5 to the exponent 8 = 390625.0
800:	6 to the exponent 8 = 1679616.0
801:	7 to the exponent 8 = 5764801.0
802:	8 to the exponent 8 = 1.6777216E7
803:	9 to the exponent 8 = 4.3046721E7
804:	10 to the exponent 8 = 1.0E8
805:	-5 to the exponent 9 = -1953125.0
806:	-4 to the exponent 9 = -262144.0
807:	-3 to the exponent 9 = -19683.0
808:	-2 to the exponent 9 = -512.0
809:	-1 to the exponent 9 = -1.0
810:	0 to the exponent 9 = 0.0
811:	1 to the exponent 9 = 1.0
812:	2 to the exponent 9 = 512.0
813:	3 to the exponent 9 = 19683.0
814:	4 to the exponent 9 = 262144.0
815:	5 to the exponent 9 = 1953125.0
816:	6 to the exponent 9 = 1.0077696E7
817:	7 to the exponent 9 = 4.0353607E7
818:	8 to the exponent 9 = 1.34217728E8
819:	9 to the exponent 9 = 3.87420489E8
820:	10 to the exponent 9 = 1.0E9
821:	-5 to the exponent 10 = 9765625.0
822:	-4 to the exponent 10 = 1048576.0
823:	-3 to the exponent 10 = 59049.0
824:	-2 to the exponent 10 = 1024.0
825:	-1 to the exponent 10 = 1.0
826:	0 to the exponent 10 = 0.0
827:	1 to the exponent 10 = 1.0
828:	2 to the exponent 10 = 1024.0
829:	3 to the exponent 10 = 59049.0
830:	4 to the exponent 10 = 1048576.0
831:	5 to the exponent 10 = 9765625.0
832:	6 to the exponent 10 = 6.0466176E7
833:	7 to the exponent 10 = 2.82475249E8
834:	8 to the exponent 10 = 1.073741824E9
835:	9 to the exponent 10 = 3.486784401E9
836:	10 to the exponent 10 = 1.0E10
837:	Recursion complete!
838:	Start learing Advanced Classes..
839:	Object1 as a string = java.lang.Object@1ce92674
840:	Object2 as a string = java.lang.Object@5700d6b1
841:	Object3 as a string = java.lang.Object@5700d6b1
842:	Person  as a string = Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Person@6fd02e5
843:	Student as a string = Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Student@5bcab519
844:	Teacher as a string = Teacher Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Teacher@e45f292
845:	String  as a string = squirrel
846:	O2==O3
847:	P1==P2
848:	P2==P3
849:	P1==P3
850:	person==john
851:	S1==S2
852:	Students are equal!
853:	Teachers are equal!
854:	person1 : Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Person@5f2108b5
855:	clone of: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Person@5f2108b5
856:	student1: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Student@31a5c39e
857:	clone of: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Student@3f49dace
858:	teacher1: Teacher Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Teacher@1e397ed7
859:	clone of: Teacher Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Teacher@490ab905
860:	Student total = 5
861:	Student total = 5
862:	Student total = 7
863:	Student total = 10
864:	Gender = male
865:	Alive = false
866:	Doctor: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Doctor@1ed4004b
867:	DiskJockey: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.DiskJockey@ff5b51f
868:	MrWachs: Teacher Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.MrWachs@25bbe1b6
869:	Husky: HighSchool: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Husky@5702b3b1
870:	Piper: HighSchool: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Piper@69ea3742
871:	Athlete: Husky: HighSchool: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Athlete@4b952a2d
872:	Round 1...
873:	Round 2...
874:	Round 3...
875:	Round 4...
876:	Class name: Boolean, Hash code: 1231, To String: true
877:	Class name: Integer, Hash code: 0, To String: 0
878:	Class name: Double, Hash code: 300063655, To String: 3.14
879:	Class name: Character, Hash code: 97, To String: a
880:	Class name: String, Hash code: 3556498, To String: test
881:	Class name: Athlete, Hash code: 1268066861, To String: Athlete: Husky: HighSchool: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Athlete@4b952a2d
882:	Class name: JOptionPane, Hash code: 422250493, To String: utility.io.JOptionPane@192b07fd
883:	Class name: Object, Hash code: 1690287238, To String: java.lang.Object@64bfbc86
884:	Class name: Boolean, Hash code: 1231, To String: true
885:	Class name: Integer, Hash code: 0, To String: 0
886:	Class name: Double, Hash code: 300063655, To String: 3.14
887:	Class name: Character, Hash code: 97, To String: a
888:	Class name: String, Hash code: 3556498, To String: test
889:	Class name: Athlete, Hash code: 1268066861, To String: Athlete: Husky: HighSchool: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Athlete@4b952a2d
890:	Completed learning Advanced Classes!
891:	Collections testing begins...
892:	Testing Node constructors....................
893:	Testing Node toString()......................
894:	Node a = null
895:	Node b = Sass
896:	Node c = Pros
897:	Node d = Joes
898:	Testing Node clone().........................
899:	Node e = null
900:	Node f = Sass
901:	Node g = Pros
902:	Node h = Joes
903:	Testing Node equal().........................
904:	Node a == b? -> false
905:	Node b == c? -> false
906:	Node c == d? -> false
907:	Node d == d? -> true
908:	Node e == a? -> false
909:	Node f == b? -> true
910:	Node g == c? -> true
911:	Node h == d? -> true
912:	Testing Node finalize()......................
913:	Node a = null
914:	Node b = Sass
915:	Node c = Pros
916:	Node d = Joes
917:	Node e = null
918:	Node f = Sass
919:	Node g = Pros
920:	Node h = Joes
921:	Node a = null
922:	Node b = null
923:	Node c = null
924:	Node d = null
925:	Node e = null
926:	Node f = null
927:	Node g = null
928:	Node h = null
929:	Testing default LinkedList constructor.......
930:	Testing toString, empty, size methods........
931:	L1 toString -> Empty LinkedList
932:	L2 toString -> Empty LinkedList
933:	L1 empty? -> true
934:	L2 empty? -> true
935:	L1 size -> 0
936:	L2 size -> 0
937:	Test add (first to the back) of the list.....
938:	addBack -> true	[51]
939:	addBack -> true	[51,50]
940:	addBack -> true	[51,50,-50]
941:	addBack -> true	[51,50,-50,55]
942:	addBack -> false	[51,50,-50,55]
943:	Test add (second to the front) of the list...
944:	addFront -> true	[80,51,50,-50,55]
945:	addFront -> true	[81,80,51,50,-50,55]
946:	addFront -> true	[-80,81,80,51,50,-50,55]
947:	addFront -> true	[88,-80,81,80,51,50,-50,55]
948:	addFront -> false	[88,-80,81,80,51,50,-50,55]
949:	Re-testing empty, size methods...............
950:	L1 empty? -> false	[88,-80,81,80,51,50,-50,55]
951:	L2 empty? -> true	Empty LinkedList
952:	L1 size -> 8	[88,-80,81,80,51,50,-50,55]
953:	L2 size -> 0	Empty LinkedList
954:	Test get method..............................
955:	Getting -1 = null	[88,-80,81,80,51,50,-50,55]
956:	Getting 0 = 88	[88,-80,81,80,51,50,-50,55]
957:	Getting 1 = -80	[88,-80,81,80,51,50,-50,55]
958:	Getting 2 = 81	[88,-80,81,80,51,50,-50,55]
959:	Getting 3 = 80	[88,-80,81,80,51,50,-50,55]
960:	Getting 4 = 51	[88,-80,81,80,51,50,-50,55]
961:	Getting 5 = 50	[88,-80,81,80,51,50,-50,55]
962:	Getting 6 = -50	[88,-80,81,80,51,50,-50,55]
963:	Getting 7 = 55	[88,-80,81,80,51,50,-50,55]
964:	Getting 8 = null	[88,-80,81,80,51,50,-50,55]
965:	Test set method..............................
966:	Setting -1 to 9 -> false	[88,-80,81,80,51,50,-50,55]
967:	Setting 0 to 10 -> true	[10,-80,81,80,51,50,-50,55]
968:	Setting 1 to 11 -> true	[10,11,81,80,51,50,-50,55]
969:	Setting 2 to 12 -> true	[10,11,12,80,51,50,-50,55]
970:	Setting 3 to 13 -> true	[10,11,12,13,51,50,-50,55]
971:	Setting 4 to 14 -> true	[10,11,12,13,14,50,-50,55]
972:	Setting 5 to 15 -> true	[10,11,12,13,14,15,-50,55]
973:	Setting 6 to 16 -> true	[10,11,12,13,14,15,16,55]
974:	Setting 7 to 17 -> true	[10,11,12,13,14,15,16,17]
975:	Setting 8 to 18 -> false	[10,11,12,13,14,15,16,17]
976:	Setting 0 to null -> false	[10,11,12,13,14,15,16,17]
977:	Test equals method...........................
978:	List 1 = [10,11,12,13,14,15,16,17]
979:	List 2 = Empty LinkedList
980:	List1 == List2 -> false
981:	Test clone method............................
982:	List 1 = [10,11,12,13,14,15,16,17]
983:	List 2 = [10,11,12,13,14,15,16,17]
984:	Re-testing equals...
985:	List1 == List2 -> true
986:	Test addAfter method.........................
987:	Adding value 	99	 after index 	-1	 result 	false	[10,11,12,13,14,15,16,17]
988:	Adding value 	100	 after index 	0	 result 	true	[10,100,11,12,13,14,15,16,17]
989:	Adding value 	101	 after index 	1	 result 	true	[10,100,101,11,12,13,14,15,16,17]
990:	Adding value 	102	 after index 	2	 result 	true	[10,100,101,102,11,12,13,14,15,16,17]
991:	Adding value 	103	 after index 	3	 result 	true	[10,100,101,102,103,11,12,13,14,15,16,17]
992:	Adding value 	104	 after index 	4	 result 	true	[10,100,101,102,103,104,11,12,13,14,15,16,17]
993:	Adding value 	105	 after index 	5	 result 	true	[10,100,101,102,103,104,105,11,12,13,14,15,16,17]
994:	Adding value 	106	 after index 	6	 result 	true	[10,100,101,102,103,104,105,106,11,12,13,14,15,16,17]
995:	Adding value 	107	 after index 	7	 result 	true	[10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
996:	Test other edge case
997:	Adding value 	10	 after index 	17	 result 	false	[10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
998:	Test addBefore method.........................
999:	Adding value 	99	 before index 	-1	 result 	false	[10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1000:	Adding value 	100	 before index 	0	 result 	true	[100,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1001:	Adding value 	101	 before index 	1	 result 	true	[100,101,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1002:	Adding value 	102	 before index 	2	 result 	true	[100,101,102,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1003:	Adding value 	103	 before index 	3	 result 	true	[100,101,102,103,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1004:	Adding value 	104	 before index 	4	 result 	true	[100,101,102,103,104,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1005:	Adding value 	105	 before index 	5	 result 	true	[100,101,102,103,104,105,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1006:	Adding value 	106	 before index 	6	 result 	true	[100,101,102,103,104,105,106,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1007:	Adding value 	107	 before index 	7	 result 	true	[100,101,102,103,104,105,106,107,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1008:	Adding value 	108	 before index 	8	 result 	true	[100,101,102,103,104,105,106,107,108,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1009:	Adding value 	109	 before index 	9	 result 	true	[100,101,102,103,104,105,106,107,108,109,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1010:	Adding value 	110	 before index 	10	 result 	true	[100,101,102,103,104,105,106,107,108,109,110,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1011:	Adding value 	111	 before index 	11	 result 	true	[100,101,102,103,104,105,106,107,108,109,110,111,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1012:	Adding value 	112	 before index 	12	 result 	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1013:	Adding value 	113	 before index 	13	 result 	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1014:	Adding value 	114	 before index 	14	 result 	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1015:	Adding value 	115	 before index 	15	 result 	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1016:	Test other edge case
1017:	Adding value 	10	 before index 	33	 result 	false	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1018:	Test front and back methods..................
1019:	Front of list 1 = 100	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1020:	Front of list 2 = 10	[10,11,12,13,14,15,16,17]
1021:	Back of list 1 = 17	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1022:	Back of list 2 = 17	[10,11,12,13,14,15,16,17]
1023:	Clear out list 2
1024:	Front of list 2 = null	Empty LinkedList
1025:	Back of list 2 = null	Empty LinkedList
1026:	Cloning list 2 from list 1
1027:	Test removeFront method......................
1028:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	100
1029:	[101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	101
1030:	[102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	102
1031:	[103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	103
1032:	[104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	104
1033:	[105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	105
1034:	[106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	106
1035:	[107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	107
1036:	[108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	108
1037:	[109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	109
1038:	[110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	110
1039:	[111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	111
1040:	[112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	112
1041:	[113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	113
1042:	[114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	114
1043:	[115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	115
1044:	[10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	10
1045:	[100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	100
1046:	[101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	101
1047:	[102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	102
1048:	[103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	103
1049:	[104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	104
1050:	[105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	105
1051:	[106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	106
1052:	[107,11,12,13,14,15,16,17]	Removing list 1 front = 	107
1053:	[11,12,13,14,15,16,17]	Removing list 1 front = 	11
1054:	[12,13,14,15,16,17]	Removing list 1 front = 	12
1055:	[13,14,15,16,17]	Removing list 1 front = 	13
1056:	[14,15,16,17]	Removing list 1 front = 	14
1057:	[15,16,17]	Removing list 1 front = 	15
1058:	[16,17]	Removing list 1 front = 	16
1059:	[17]	Removing list 1 front = 	17
1060:	Empty LinkedList	Removing list 1 front = 	null
1061:	Cloning list 1 from list 2
1062:	Test removeBack method.......................
1063:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 2 back = 	17
1064:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16]	Removing list 2 back = 	16
1065:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15]	Removing list 2 back = 	15
1066:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14]	Removing list 2 back = 	14
1067:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13]	Removing list 2 back = 	13
1068:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12]	Removing list 2 back = 	12
1069:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11]	Removing list 2 back = 	11
1070:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107]	Removing list 2 back = 	107
1071:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106]	Removing list 2 back = 	106
1072:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105]	Removing list 2 back = 	105
1073:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104]	Removing list 2 back = 	104
1074:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103]	Removing list 2 back = 	103
1075:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102]	Removing list 2 back = 	102
1076:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101]	Removing list 2 back = 	101
1077:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100]	Removing list 2 back = 	100
1078:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10]	Removing list 2 back = 	10
1079:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115]	Removing list 2 back = 	115
1080:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114]	Removing list 2 back = 	114
1081:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113]	Removing list 2 back = 	113
1082:	[100,101,102,103,104,105,106,107,108,109,110,111,112]	Removing list 2 back = 	112
1083:	[100,101,102,103,104,105,106,107,108,109,110,111]	Removing list 2 back = 	111
1084:	[100,101,102,103,104,105,106,107,108,109,110]	Removing list 2 back = 	110
1085:	[100,101,102,103,104,105,106,107,108,109]	Removing list 2 back = 	109
1086:	[100,101,102,103,104,105,106,107,108]	Removing list 2 back = 	108
1087:	[100,101,102,103,104,105,106,107]	Removing list 2 back = 	107
1088:	[100,101,102,103,104,105,106]	Removing list 2 back = 	106
1089:	[100,101,102,103,104,105]	Removing list 2 back = 	105
1090:	[100,101,102,103,104]	Removing list 2 back = 	104
1091:	[100,101,102,103]	Removing list 2 back = 	103
1092:	[100,101,102]	Removing list 2 back = 	102
1093:	[100,101]	Removing list 2 back = 	101
1094:	[100]	Removing list 2 back = 	100
1095:	Empty LinkedList	Removing list 2 back = 	null
1096:	Cloning list 2 from list 1
1097:	Test remove method...........................
1098:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing from list 1 from index: 	33	 removed: 	null
1099:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing from list 1 from index: 	32	 removed: 	null
1100:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing from list 1 from index: 	31	 removed: 	17
1101:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16]	Removing from list 1 from index: 	30	 removed: 	16
1102:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15]	Removing from list 1 from index: 	29	 removed: 	15
1103:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14]	Removing from list 1 from index: 	28	 removed: 	14
1104:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13]	Removing from list 1 from index: 	27	 removed: 	13
1105:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12]	Removing from list 1 from index: 	26	 removed: 	12
1106:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11]	Removing from list 1 from index: 	25	 removed: 	11
1107:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107]	Removing from list 1 from index: 	24	 removed: 	107
1108:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106]	Removing from list 1 from index: 	23	 removed: 	106
1109:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105]	Removing from list 1 from index: 	22	 removed: 	105
1110:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104]	Removing from list 1 from index: 	21	 removed: 	104
1111:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103]	Removing from list 1 from index: 	20	 removed: 	103
1112:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102]	Removing from list 1 from index: 	19	 removed: 	102
1113:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101]	Removing from list 1 from index: 	18	 removed: 	101
1114:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100]	Removing from list 1 from index: 	17	 removed: 	100
1115:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10]	Removing from list 1 from index: 	16	 removed: 	10
1116:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115]	Removing from list 1 from index: 	15	 removed: 	115
1117:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114]	Removing from list 1 from index: 	14	 removed: 	114
1118:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113]	Removing from list 1 from index: 	13	 removed: 	113
1119:	[100,101,102,103,104,105,106,107,108,109,110,111,112]	Removing from list 1 from index: 	12	 removed: 	112
1120:	[100,101,102,103,104,105,106,107,108,109,110,111]	Removing from list 1 from index: 	11	 removed: 	111
1121:	[100,101,102,103,104,105,106,107,108,109,110]	Removing from list 1 from index: 	10	 removed: 	110
1122:	[100,101,102,103,104,105,106,107,108,109]	Removing from list 1 from index: 	9	 removed: 	109
1123:	[100,101,102,103,104,105,106,107,108]	Removing from list 1 from index: 	8	 removed: 	108
1124:	[100,101,102,103,104,105,106,107]	Removing from list 1 from index: 	7	 removed: 	107
1125:	[100,101,102,103,104,105,106]	Removing from list 1 from index: 	6	 removed: 	106
1126:	[100,101,102,103,104,105]	Removing from list 1 from index: 	5	 removed: 	105
1127:	[100,101,102,103,104]	Removing from list 1 from index: 	4	 removed: 	104
1128:	[100,101,102,103]	Removing from list 1 from index: 	3	 removed: 	103
1129:	[100,101,102]	Removing from list 1 from index: 	2	 removed: 	102
1130:	[100,101]	Removing from list 1 from index: 	1	 removed: 	101
1131:	[100]	Removing from list 1 from index: 	0	 removed: 	100
1132:	Empty LinkedList	Removing from list 1 from index: 	-1	 removed: 	null
1133:	Test contains method.........................
1134:	List 1 (empty) contains 10 = false	Empty LinkedList
1135:	List 2 contains 	100	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1136:	List 2 contains 	101	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1137:	List 2 contains 	102	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1138:	List 2 contains 	103	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1139:	List 2 contains 	104	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1140:	List 2 contains 	105	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1141:	List 2 contains 	106	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1142:	List 2 contains 	107	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1143:	List 2 contains 	108	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1144:	List 2 contains 	109	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1145:	List 2 contains 	110	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1146:	List 2 contains 	111	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1147:	List 2 contains 	112	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1148:	List 2 contains 	113	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1149:	List 2 contains 	114	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1150:	List 2 contains 	115	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1151:	List 2 contains 	10	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1152:	List 2 contains 	100	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1153:	List 2 contains 	101	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1154:	List 2 contains 	102	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1155:	List 2 contains 	103	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1156:	List 2 contains 	104	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1157:	List 2 contains 	105	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1158:	List 2 contains 	106	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1159:	List 2 contains 	107	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1160:	List 2 contains 	11	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1161:	List 2 contains 	12	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1162:	List 2 contains 	13	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1163:	List 2 contains 	14	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1164:	List 2 contains 	15	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1165:	List 2 contains 	16	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1166:	List 2 contains 	17	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1167:	List 2 contains 	1000	false	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1168:	Resetting list 1 to: [5,6,7,8,5,6,7,5,6,7]
1169:	Test firstIndexOf and lastIndexOf methods....
1170:	First index of 5: 	0
1171:	Last  index of 5: 	7
1172:	First index of 7: 	2
1173:	Last  index of 7: 	9
1174:	First index of 8: 	3
1175:	Last  index of 8: 	3
1176:	First index of 9: 	-1
1177:	Last  index of 9: 	-1
1178:	Test numberOf method.........................
1179:	[5,6,7,8,5,6,7,5,6,7]
1180:	Number of 5: 	3
1181:	Number of 8: 	1
1182:	Number of 9: 	0
1183:	Test allIndices method.......................
1184:	[5,6,7,8,5,6,7,5,6,7]
1185:	Array -> indices 5: 	[0, 4, 7]
1186:	Array -> indices 8: 	[3]
1187:	Array -> indices 9: 	null
1188:	Cloning list 2 from list 1
1189:	Test remove method...........................
1190:	[5,6,7,8,5,6,7,5,6,7]
1191:	Removing 5: 	true	[6,7,8,5,6,7,5,6,7]
1192:	Removing 8: 	true	[6,7,5,6,7,5,6,7]
1193:	Removing 9: 	false	[6,7,5,6,7,5,6,7]
1194:	Test removeLast method.......................
1195:	[6,7,5,6,7,5,6,7]
1196:	Removing 5: 	true	[6,7,5,6,7,6,7]
1197:	Removing 8: 	false	[6,7,5,6,7,6,7]
1198:	Removing 9: 	false	[6,7,5,6,7,6,7]
1199:	Test removeAll method........................
1200:	[6,7,5,6,7,6,7]
1201:	Removing all 5: 	true	[6,7,6,7,6,7]
1202:	Removing all 6: 	true	[7,7,7]
1203:	Removing all 9: 	false	[7,7,7]
1204:	Cloning list 1 from list 2
1205:	Test removeAll array method..................
1206:	[5,6,7,8,5,6,7,5,6,7]
1207:	Array: 	[5, 6, 9]
1208:	Removing all from array: [7,8,7,7]
1209:	Test removeAll list method..................
1210:	List 1 	[5,6,7,8,5,6,7,5,6,7]
1211:	List 2 	[7,8,7,7]
1212:	Removing all list 2 from list 1...
1213:	List 1 	[5,6,5,6,5,6]
1214:	List 2 	[7,8,7,7]
1215:	Resetting list 1 and 2 to: [5,6,7,8,5,6,7,5,6,7]
1216:	Test containsAll array method................
1217:	List: 	[5,6,7,8,5,6,7,5,6,7] contains array: 	[5, 6, 9]	 is false
1218:	List: 	[5,6,7,8,5,6,7,5,6,7] contains array: 	[5, 6, 7, 8]	 is true
1219:	Test containsAll list method.................
1220:	List: 	[5,6,7,8,5,6,7,5,6,7] contains list: 	[5,6,7,8,5,6,7,5,6,7]	 is true
1221:	Alter list 2...
1222:	List: 	[5,6,7,8,5,6,7,5,6,7] contains list: 	[6,7,8,6,7,5,6,45]	 is false
1223:	Test addAll array method.....................
1224:	[6,7,8,6,7,5,6,45]
1225:	Adding array: 	[5, 6, 7, 8]	 now list 	[6,7,8,6,7,5,6,45,5,6,7,8]
1226:	Test addAll list method......................
1227:	[6,7,8,6,7,5,6,45,5,6,7,8]
1228:	Adding list: 	[5,6,7,8,5,6,7,5,6,7]	 now list 	[6,7,8,6,7,5,6,45,5,6,7,8,5,6,7,8,5,6,7,5,6,7]
1229:	Test subList method..........................
1230:	List 1 = 	[5,6,7,8,5,6,7,5,6,7]
1231:	Pulling out sub-list from 3 to 6: 	[8,5,6,7]
1232:	Pulling out sub-list from 1 to 1: 	[6]
1233:	Pulling out sub-list from 2 to 10: 	null
1234:	Pulling out sub-list from 0 to 9: 	[5,6,7,8,5,6,7,5,6,7]
1235:	Test fromArray method........................
1236:	Array is 	[5, 6, 7, 8]
1237:	List is 	[5,6,7,8]
1238:	Test fromLinkedList method...................
1239:	1st List is 	[5,6,7,8]
1240:	2nd List is 	[5,6,7,8]
1241:	Test toArray method..........................
1242:	List 	[5,6,7,8]	 into array 	[5, 6, 7, 8]
1243:	Testing the imported util LinkedList.........
1244:	Imported constructor...
1245:	Imported add:	[0.0]
1246:	Imported add:	[0.0, 1.23]
1247:	Imported addFirst:	[4.56, 0.0, 1.23]
1248:	Imported addLast:	[4.56, 0.0, 1.23, 7.89]
1249:	Imported size:	4
1250:	Imported isEmpty:	false
1251:	Imported get:	0.0
1252:	Imported set:	4.56
1253:	Imported clone:	[0.01, 0.0, 1.23, 7.89]
1254:	Imported equals:	true
1255:	Imported getFirst:	0.01
1256:	Imported getLast:	7.89
1257:	Imported contains:	true
1258:	Imported removeFirst:	0.01
1259:	Imported removeLast:	7.89
1260:	Imported remove:	1.23
1261:	Imported remove:	false
1262:	Testing the imported util ArrayList.........
1263:	Imported ArrayList:	[a, b, c, d, e]
1264:	Using the enhanced for loop with this object...
1265:	a b c d e Using an iterator object...
1266:	a b c d e Collections testing complete!
1267:	Computer Science 42SAP - Curriculum content running simulated:.............................
1268:	Computer Science 42SAP - AP curriculum - Part 1 content running simulated:.................
1269:	Computer Science 42SAP - AP: Unit 1 (Primitive Types) content running simulated:...........
1270:	Unit 1 - Primitive Types ..................................................................
1271:	1.1 - Why Programming? Why Java?...........................................................
1272:	   1.1.1 - Call System class methods to generate output to the console
1273:	      1.1.1.1 - System.out.print and System.out.println display information on the 
1274:	                 computer monitor 
1275:	      1.1.1.2 - System.out.println moves the cursor to a new line after  the information 
1276:	                 has been displayed, while System.out.print does not     
1277:	   1.1.2 - Create string literals
1278:	      1.1.2.1 - A string literal is enclosed in double quotes     
1279:	System.out.print outputs text to the screen and System.out.println outputs with a line break
1280:	More specifically, the code word "System" refers to the "computer system" and the 
1281:	word "out" refers to outputting, and finally the word "print" or "println" are calls to 
1282:	methods (or "actions") that take the string literal (which is the word or words in between 
1283:	the quotation marks) and outputs it. So the command "System.out.println("literal");" 
1284:	will take the string literal and output it to the default output device - that being the 
1285:	computer screen.
1286:	1.2 - Variables and Data Types.............................................................
1287:	   1.2.1 - Identify the most appropriate data type category for a particular specification
1288:	      1.2.1.1 - A type is a set of values (a domain) and a set of operations on 
1289:	                 them 
1290:	      1.2.1.2 - Data types can be categorized as either primitive or reference 
1291:	      1.2.1.3 - The primitive data types used in this course define the set of operations 
1292:	                 for numbers and Boolean values 
1293:	   1.2.1 - Declare variables of the correct types to represent primitive data
1294:	      1.2.1.1 - The three primitive data types used in this course are int, double, 
1295:	                 and boolean 
1296:	      1.2.1.2 - Each variable has associated memory that is used to hold its value 
1297:	      1.2.1.3 - The memory associated with a variable of a primitive type holds 
1298:	                 an actual primitive value 
1299:	      1.2.1.4 - When a variable is declared final, its value cannot be changed once 
1300:	                 it is initialized 
1301:	Data/information refers to the "kind" of data being stored (or "remembered") by the program 
1302:	in a "variable". A variable is a piece of the computer's memory (storage) that has a "name" 
1303:	(or "address") so that the programmer can refer to it by that name. The "type" refers to the 
1304:	"kind" of data that you are storing (e.g. text, numbers, true/false, etc.). The type must be 
1305:	specified at the time you write a line of code to "create" (or "declare") the variable. A 
1306:	variable can only be one type and only store that specified type of data. However, the data 
1307:	itself can change (or "vary") after the initial declaration. Examples of this are below...
1308:	// Variables declared and assigned initial ("starting") values:
1309:	boolean a = true;
1310:	int     b = 0;
1311:	double  c = 1.0;
1312:	char    d = 'A';
1313:	// Variables content changes ("reassigned"):
1314:	a = false;
1315:	b = 1;
1316:	c = 1.1;
1317:	d = 'B';
1318:	A "final" (or a "constant") is a variable in which the stored value does NOT change 
1319:	(it stays "constant") and it locked at that value. Final (or constant) variables are 
1320:	given the initial value when declared (or initialized) and that value stays locked. These 
1321:	types of values are written in ALL_CAPS with the underscore value used to seperate words in 
1322:	the name. Final variables are more efficient for a number of reasons including ease of code 
1323:	understanding, speed (faster code), easier to update code, and others. Examples of finals 
1324:	are below
1325:	// Constants (finals) declared (initialized)
1326:	final boolean FOUND  = true;
1327:	final int     VALUE  = 1;
1328:	final double  AMOUNT = 2.5;
1329:	final char    CODE   = 'X';
1330:	1.3 - Expressions and Assignment Statements................................................
1331:	   1.3.1 - Evaluate arithmetic expressions in a program code
1332:	      1.3.1.1 - A literal is the source code representation of a fixed value
1333:	      1.3.1.2 - Arithmetic expressions include expressions of type int and double 
1334:	      1.3.1.3 - The arithmetic operators consist of +, , *, /, and % 
1335:	      1.3.1.4 - An arithmetic operation that uses two int values will evaluate to 
1336:	                 an int value 
1337:	      1.3.1.5 - An arithmetic operation that uses a double value will evaluate to 
1338:	                 a double value 
1339:	      1.3.1.6 - Operators can be used to construct compound expressions 
1340:	      1.3.1.7 - During evaluation, operands are associated with operators according 
1341:	                 to operator precedence to determine how they are grouped 
1342:	      1.3.1.8 - An attempt to divide an integer by zero will result in an ArithmeticException 
1343:	                 to occur 
1344:	   1.3.2 - Evaluate what is stored in a variable as a result of an expression with 
1345:	              an assignment statement
1346:	      1.3.2.1 - The assignment operator (=) allows a program to initialize or change 
1347:	                 the value stored in a variable. The value of the expression on the right is 
1348:	                 stored in the variable on the left 
1349:	      1.3.2.2 - During execution, expressions are evaluated to produce a single 
1350:	                 value 
1351:	      1.3.2.3 - The value of an expression has a type based on the evaluation of 
1352:	                 the expression 
1353:	Arithmetic (or "math") statements in code are lines of code (or "statements") that are 
1354:	written to evaluate (or "solve") an equation of logic the program needs to solve. In this 
1355:	context, the word "literal" can also mean a number (like "5"). This usually involves 
1356:	variable types int and double (the number types) used in a math expression or equation. This 
1357:	can involve math operations like +, -, *, / and % (modulus). When multiple int values are 
1358:	evaluated in a formula, they always evaluate to an int answer (solution) and double values 
1359:	will evaluate to a double. Complex (or "compound" expressions can be formed in which 
1360:	the order of operations (or precedence order). This means multiplication and division are 
1361:	evaluated before addition and subtraction. If operations are at the same precedence level, 
1362:	then they are evaluated from left to right.When you try and divide by zero, an error 
1363:	(the "ArithmeticException" error) will occur and the program will stop running. Examples:
1364:	// Arithmetic evaluations using variables
1365:	int    v1 = 5;
1366:	int    v2 = 3;
1367:	int    v3 = (v1 + 5 * v2 / (1 + 2)) % 2;
1368:	double v4 = 5.2;
1369:	double v5 = 3.3;
1370:	double v6 = (v4 + 5.1 * v5 / (1.2 + 2.3)) % 2.2;
1371:	1.4 - Compound Assignment Operators........................................................
1372:	   1.4.1 - Evaluate what is stored in a variable as a result of an expression with 
1373:	              an assignment statement
1374:	      1.4.1.1 - Compound assignment operators (+=, =, *=, /=, %=) can be used in 
1375:	                 place of the assignment operator 
1376:	      1.4.1.2 - The increment operator (++) and decrement operator () are used 
1377:	                 to add 1 or subtract 1 from the stored value of a variable or an array element. 
1378:	                 The new value is assigned to the variable or array element
1379:	Compound statements in this context refers to using shortcuts to quickly add or subtract one 
1380:	(increment or decrement) to a variable. You can also use more complex shorthand compound 
1381:	statements to quickly multiply, divide, even modulus a variable with itself or other 
1382:	variables. For example:
1383:	// Shorthand Compound Arithmetic expressions
1384:	int value = 5;
1385:	value++;    // is the same as "value = value + 1;"
1386:	value--;    // is the same as "value = value + 1;"
1387:	value += 5; // is the same as "value = value + 5;"
1388:	value -= 5; // is the same as "value = value - 5;"
1389:	value *= 5; // is the same as "value = value * 5;"
1390:	value /= 5; // is the same as "value = value / 5;"
1391:	value %= 5; // is the same as "value = value % 5;"
1392:	1.5 - Casting and Ranges of Variables......................................................
1393:	   1.5.1 - Evaluate arithmetic expressions that use casting
1394:	      1.5.1.1 - The casting operators (int) and (double) can be used to create a 
1395:	                 temporary value converted to a different data type
1396:	      1.5.1.2 - Casting a double value to an int causes the digits to the right 
1397:	                 of the decimal point to be truncated
1398:	      1.5.1.3 - Some programming code causes int values to be automatically cast 
1399:	                 (widened) to double values
1400:	      1.5.1.4 - Values of type double can be rounded to the nearest integer by (int)(x 
1401:	                 + 0.5) or (int)(x  0.5) for negative numbers 
1402:	      1.5.1.5 - Integer values in Java are represented by values of type int, which 
1403:	                 are stored using a finite amount (4 bytes) of memory. Therefore, an int value 
1404:	                 must be in the range from Integer.MIN_VALUE to Integer.MAX_VALUE inclusive
1405:	      1.5.1.6 - If an expression would evaluate to an int value outside of the allowed 
1406:	                 range, an integer overflow occurs. This could result in an incorrect value 
1407:	                 within the allowed range 
1408:	Casting is the process of "converting" one data type into another data type. When casting 
1409:	an double to a int, the decimal portion of the double is truncated (cut off) and not rounded 
1410:	off. When a int is cast to a double, the int is "widened" to now accomodate any decimals. 
1411:	A char when cast will turn into it's ASCII value. The process of casting involves putting 
1412:	variable to be cast with the type being cast into in round brackets to the left of that 
1413:	variable. Integer values hold a finite amount of number space (4 bytes) and the built-in 
1414:	constants Integer.MAX_VALUE and MIN_VALUE are the limits of the int. If an expression 
1415:	evaluates an int outside that range, an error will occur (overflow error). For example:
1416:	// Casting data types
1417:	int integer = Integer.MAX_VALUE;
1418:	double doub = Double.MIN_VALUE;
1419:	doub        = (int)integer;
1420:	integer     = (int)doub;
1421:	char letter = 'A';
1422:	integer     = (int)letter;
1423:	Computer Science 42SAP - AP: Unit 3 (Boolean Expressions And If Statements) content running simulated:.
1424:	Unit 3 - Boolean Expressions And If Statements            .................................
1425:	3.1 - Boolean Expressions  ................................................................
1426:	   3.1.1 - Evaluate Boolean expressions that use relational operators in program 
1427:	              code
1428:	      3.1.1.1 - Primitive values and reference values can be compared using relational 
1429:	                 operators (i.e., == and !=) 
1430:	      3.1.1.2 - Arithmetic expression values can be compared using relational operators 
1431:	                 (i.e., <, >, <=, >=) 
1432:	      3.1.1.3 - An expression involving relational operators evaluates to a Boolean 
1433:	                 value 
1434:	A Boolean (true/false) expression is a code statement most likely in a control structure 
1435:	like a conditional statement or loop control structure that evaluates to true or false to 
1436:	make decisions and control the flow of the program. The Boolean expression will require 
1437:	the use of relational operators like: < , > , <= , >= , == , and != those being: "less 
1438:	than", "greater than", "less than or equal to", "greater than or equal to", "equal 
1439:	to", and "not equal to".
1440:	3.2 - if Statements and Control Flow  .....................................................
1441:	   3.2.1 - Represent branching logical processes by using conditional Statements
1442:	      3.2.1.1 -  Conditional statements interrupt the sequential execution of statements 
1443:	      3.2.1.2 -  if statements affect the flow of control by executing different 
1444:	                 statements based on the value of a Boolean Expression 
1445:	      3.2.1.3 -  A one-way selection (if statement) is written when there is a set 
1446:	                 of statements to execute under a certain condition. In this case, the body 
1447:	                 is executed only when the Boolean condition is true 
1448:	A "Conditional Statement" is also known under other names like "branching statement", "if 
1449:	statement", "one-way selection statement", and "control structure". It uses the reserved 
1450:	keyword "if" along with round brackets which contain the Boolean expression, and curly 
1451:	brackets to contain the control block of all code you wish to be controlled by the 
1452:	conditional statement. Brackets are optional if the block is only one line, and you may also 
1453:	move thos lines up to the same line as the conditional statement. For example:
1454:	// Example of if statements
1455:	int a = 10;
1456:	int b = 10;
1457:	if (a == a) {
1458:	    // "equal"
1459:	}
1460:	3.3 - if-else Statements  .................................................................
1461:	   3.3.1 -  Represent branching logical processes by using conditional Statements
1462:	      3.3.1.1 -  A two-way selection is written when there are two sets of statements 
1463:	                 one to be executed when the Boolean condition is true, and another set for 
1464:	                 when the Boolean condition is false. In this case, the body of the "if" is 
1465:	                 executed when the Boolean condition is true, and the body of the "else" is 
1466:	                 executed when the Boolean condition is false 
1467:	The "else" statement is paired with an "if" statement to control the flow of the logic so 
1468:	that the conditional now evaluates to both true and false. This can be called a "two 
1469:	way selection" (for true/false). An "else" must always follow an "if" statement first. 
1470:	For example:
1471:	// if with "else" 
1472:	double c = 1.45, d = 1.5; 
1473:	if (c < d) {
1474:	    // "Less than"
1475:	}
1476:	else {
1477:	    // "Greater than"
1478:	}
1479:	// Shortened lines version
1480:	char e = 'A';
1481:	char f = 'a';
1482:	if (e != f) e = '!';
1483:	else        e = '=';
1484:	3.4 - else if Statements  .................................................................
1485:	   3.4.1 -  Represent branching logical processes by using conditional Statements
1486:	      3.4.1.1 -  A multi-way selection is written when there are a series of conditions 
1487:	                 with different statements for each condition. Multi-way selection is performed 
1488:	                 using if-else-if statements such that exactly one section of code is executed 
1489:	                 based on the first condition that evaluates to true
1490:	When making multiple decisions (more than 2), the "else if" statement is added to an 
1491:	existing "if" statement to have multiple branches of logic for the code to follow. This 
1492:	is much more efficient than seperate "if" statements. This can also be called "multi-way 
1493:	selection" (or "if-else-if"). An "else" statement is also still the final option (but 
1494:	this is not required). For example:
1495:	// Showing a "chain" of else if statements
1496:	int g = 0;
1497:	if (g == 1) {
1498:	    // The first if is true
1499:	}
1500:	else if (g == 2) {
1501:	    // The next if is true
1502:	}
1503:	else if (g == 3) {
1504:	    // The next if (in the "chain" of ifs) is true
1505:	}
1506:	else {
1507:	    // Nothing above is true, so go to this else
1508:	}
1509:	3.5 - Compound Boolean Expressions  .......................................................
1510:	   3.5.1 -  Represent branching logical processes by using nested conditional statements
1511:	      3.5.1.1 -  Nested if statements consist of if statements within if statements 
1512:	   3.5.2 -  Evaluate compound Boolean expressions in program code
1513:	      3.5.2.1 -  Logical operators !(not), &&(and), and ||(or) are used with Boolean 
1514:	                 values. This represents the order these operators will be evaluated 
1515:	      3.5.2.2 -  An expression involving logical operators evaluates to a Boolean 
1516:	                 value 
1517:	      3.5.2.3 -  When the result of a logical expression using && or || can be determined 
1518:	                 by evaluating only the first Boolean operand, the second is not evaluated. 
1519:	                 This is known as short-circuited evaluation 
1520:	The process of "nesting" means to place one conditional statement inside the "block" of 
1521:	another conditional statement. The logical operators: "and", "or", and "not" are 
1522:	represented with the symbols: "&&" (and), "||" (or), and "!" (not). The operator AND 
1523:	is used to combine logical boolean expressions such that ALL expressions need to be true for 
1524:	the entire statement to be true. The operator OR is used to combine logical boolean 
1525:	expressions such that ANY expression can be true for the entire statement to be true. The 
1526:	operator NOT reverses the logic so that true statements are evaluated as false (and visa 
1527:	versa). If the statement contains multiple Boolean expressions and the result of the 
1528:	evaluation of one expression has already determined the expressions result, then the 
1529:	rest of the expressions do not need to be evaluated - this is known as a "short-circuited 
1530:	evaluation". For example:
1531:	// Logical operators and "nesting"
1532:	int    age = 17;
1533:	double iq  = 1.0;
1534:	if (age >= 18 && iq > 90) {
1535:	    // with "and" ("&&") BOTH have to be true
1536:	}
1537:	else if (age >= 18 || iq > 0) {
1538:	    // with "or" ("||") EITHER can be true
1539:	}
1540:	else {
1541:	    // Case if neither evaluates
1542:	    if (age > 0) {
1543:	        // A "nested if statement"
1544:	    }
1545:	}
1546:	3.6 - Equivalent Boolean Expressions  .....................................................
1547:	   3.6.1 -  Compare and contrast equivalent Boolean expressions
1548:	      3.6.1.1 - De Morgans Laws can be applied to Boolean expressions 
1549:	      3.6.1.2 - Truth tables can be used to prove Boolean identities 
1550:	      3.6.1.3 -  Equivalent Boolean expressions will evaluate to the same value 
1551:	                 in all cases 
1552:	Boolean (true/false) expressions turned into logical statements used by control structures 
1553:	like conditional statements are subject to the laws of mathemtical logic such as "De Morgan's 
1554:	Law" (Google search this if you are curious, but it applies to mathematical proofs and is 
1555:	not necessarily applicable to this exam). This just means that complex statements need to be 
1556:	evaluated by using mathematical rules (like "order of operations") and logical operators 
1557:	(like "and, or, not") to determine the final Boolean result. This could determine if a 
1558:	control structure (like an "if" statement) runs a block of code or not.
1559:	3.7 - Comparing Objects  ..................................................................
1560:	   3.7.1 -  Compare object references using Boolean expressions in program code
1561:	      3.7.1.1 -  Two object references are considered aliases when they both reference 
1562:	                 the same object 
1563:	      3.7.1.2 -  Object reference values can be compared, using == and !=, to identify 
1564:	                 aliases 
1565:	      3.7.1.3 -  A reference value can be compared with null, using == or !=, to 
1566:	                 determine if the reference actually references an object 
1567:	      3.7.1.4 -  Often classes have their own equals method, which can be used to 
1568:	                 determine whether two objects of the class are equivalent 
1569:	The use of an advanced data type like an "Object" in code means that comparison 
1570:	operators (like <, >, ==, !=) that are used with primitive data type (like "int, 
1571:	double, char, etc.") are not used. Instead, use the "built-in" method "equals()" to 
1572:	determine the equality of two objects. For example:
1573:	// Use of the built-in equals method with Objects
1574:	String word1 = "edgy";
1575:	String word2 = "edGy";
1576:	if (word1.equals(word2)) {
1577:	    // "W1=W2"
1578:	}
1579:	else if (word1.equalsIgnoreCase(word2)) {
1580:	    // "W1 kind of == W2"
1581:	}
1582:	Computer Science 42SAP - AP: Unit 4 (Iteration) content running simulated:.................
1583:	Unit 4 - Iteration.........................................................................
1584:	4.1 - while Loops  ........................................................................
1585:	   4.1.1 - Represent iterative processes using a while loop
1586:	      4.1.1.1 - Iteration statements change the flow of control by repeating a set 
1587:	                 of statements zero or more times until a condition is met 
1588:	      4.1.1.2 - In loops, the Boolean expression is evaluated before each iteration 
1589:	                 of the loop body, including the first. When the expression evaluates to true, 
1590:	                 the loop body is executed. This continues until the expression evaluates to 
1591:	                 false, whereupon the iteration ceases 4.1.1.3 - A loop is an infinite loop 
1592:	                 when the Boolean expression always evaluates to true 
1593:	      4.1.1.4 - If the Boolean expression evaluates to false initially, the loop 
1594:	                 body is not executed at all
1595:	      4.1.1.5 - Executing a return statement inside an iteration statement will 
1596:	                 halt the loop and exit the method or constructor
1597:	   4.1.2 - For algorithms in the context of a particular specification that does 
1598:	              not require the use of traversals: (A) Identify standard algorithms, (B) Modify 
1599:	              standard algorithms, (C) Develop an algorithm 
1600:	      4.1.2.1 - There are standard algorithms to: (A) Identify if an integer is 
1601:	                 or is not evenly divisible by another integer, (B) Identify the individual 
1602:	                 digits in an integer, (C) Determine the frequency with which a specific criterion 
1603:	                 is met 
1604:	      4.1.2.2 - There are standard algorithms to: (A) Determine a minimum or maximum 
1605:	                 value, (B) Compute a sum, average, or mode
1606:	The word "Iteration" is another word for "Loop" or "Looping" which is a control 
1607:	struture to have code statements "repeat". Like conditional ("if") statements, iteration 
1608:	statements control the flow of a program's logic. Also like if statements, iteration 
1609:	statements are controlled by a Boolean expression (true or false). The result of the Boolean 
1610:	expression will result in the code executing zero or mulitple times (until the expression 
1611:	evaluates to false). The expression is evaluated each time through an iteration of the loop. 
1612:	A loop is called an "infinite" loop if the Boolean expression never evaluates to false 
1613:	(thus the loop never stops looping - or never stops running). It is possible a loop will 
1614:	never run if it evaluates to false before the body (block) of the loop. If you use the 
1615:	keyword "return" inside a loop body (block) then the loop will terminate (end) early and 
1616:	potentially exit any method the loop is written inside. The "while" loop is a event loop or 
1617:	non-deterministic loop, which means it is not usually used for counting but when you do 
1618:	not know how many times the loop needs to run (a certain event can cause the loop to 
1619:	end). Loops are used for a variety of reasons such as: repeating instructions, travelling 
1620:	(traversing) arrays and lists, and searching and sorting values. For example:
1621:	// Example of a simple while loop
1622:	int counter = 0;
1623:	while (counter < 10) {
1624:	    counter++;
1625:	}
1626:	4.2 - for Loops  ..........................................................................
1627:	   4.2.1 - Represent iterative processes using a for loop
1628:	      4.2.1.1 - There are three parts in a for loop header: the initialization, 
1629:	                 the Boolean expression, and the increment. The increment statement can also 
1630:	                 be a decrement statement 
1631:	      4.2.1.2 - In a for loop, the initialization statement is only executed once 
1632:	                 before the first Boolean expression evaluation. The variable being initialized 
1633:	                 is referred to as a loop control variable 
1634:	      4.2.1.3 - In each iteration of a for loop, the increment statement is executed 
1635:	                 after the entire loop body is executed and before the Boolean expression is 
1636:	                 evaluated again 
1637:	      4.2.1.4 - A for loop can be rewritten into an equivalent while loop and vice 
1638:	                 versa 
1639:	      4.2.1.5 - Off by one errors occur when the iteration statement loops one 
1640:	                 time too many or one time too few 
1641:	The "for" loop is another looping form. The for loop is a count controlled loop that 
1642:	generally is used when a loop needs to run a specific number of times. There are three 
1643:	parts to the for loop, that seperate the parts with two semi-colons. The 3 parts represent 
1644:	the starting, ending, and change of the loop. In a for loop a counting variable is 
1645:	generally declared right inside the loop to a starting value, then the Boolean condition 
1646:	to end the loop, then the change value increasing (increment) or decreasing (decrement) 
1647:	that value. A "for" loop can be rewritten as a "while" loop and vice versa. A "off 
1648:	by one" error occurs when a loop runs one too many or one too few times. For Example:
1649:	// Example of a for loop
1650:	for (int i = 0; i < 10; i++) {
1651:	    // potential code body...
1652:	}
1653:	4.3 - Developing Algorithms Using Strings  ................................................
1654:	   4.3.1 - For algorithms in the context of a particular specification that involves 
1655:	              String objects: (A) Identify standard algorithms, (B) Modify standard algorithms, 
1656:	              (C) Develop an Algorithm
1657:	      4.3.1.1 - There are standard algorithms that utilize String traversals to: 
1658:	                 (A) Find if one or more substrings has a particular property, (B) Determine 
1659:	                 the number of substrings that meet specific criteria, (C) Create a new string 
1660:	                 with the characters reversed 
1661:	The String class allows for several "built-in" methods of the String class to manipulate 
1662:	the string and the value it stores. Several of these methods could apply to the A.P. exam 
1663:	including travelling (traversing) string characters, pulling out substrings (parts 
1664:	of the string), reversing a string, etc. For example:
1665:	// Example of string methods with a loop
1666:	String word   = "completion";
1667:	String parts1 = word.substring(3);
1668:	String parts2 = word.substring(1,7);
1669:	for (int i = 0; i < word.length(); i++) {
1670:	    char character = word.charAt(i);
1671:	}
1672:	4.4 - Nested Iteration  ...................................................................
1673:	   4.4.1 - Represent nested iterative processes
1674:	      4.4.1.1 - Nested iteration statements are iteration statements that appear 
1675:	                 in the body of another iteration statement 
1676:	      4.4.1.2 - When a loop is nested inside another loop, the inner loop must complete 
1677:	                 all its iterations before the outer loop can continue 
1678:	Like conditional ("if") statements, looping ("iteration") statments can be "nested", 
1679:	This means you can place a iteration statement inside the block of another iteration 
1680:	statement. The inner loop must complete all of its iterations before the outer loop 
1681:	can continue. For example:
1682:	// Example of nested loops
1683:	for (int i = 0; i < 10; i++) {
1684:	    for (int j = 0; j < 10; j++) {
1685:	        int k = 10;
1686:	        while (k < 10) {
1687:	            // potential code body...
1688:	        }
1689:	    }
1690:	}
1691:	4.5 - Informal Code Analysis  .............................................................
1692:	   4.5.1 - Compute statement execution counts and informal run-time comparison of 
1693:	              iterative statements
1694:	      4.5.1.1 - A statement execution count indicates the number of times a statement 
1695:	                 is executed by the program 
1696:	Expect to "trace" loop values in A.P. exam questions. Examining, computing, and tracing 
1697:	loops are typical A.P. exam questions. You should practice these types of questions.
1698:	Computer Science 42SAP - AP curriculum - Part 2 content running simulated:.................
1699:	Computer Science 42SAP - AP: Unit 2 (Using Objects) content running simulated:.............
1700:	Unit 2 - Using Objects.....................................................................
1701:	2.1 - Objects: Instances of Classes........................................................
1702:	   2.1.1 - Explain the relationship between a class and an object
1703:	      2.1.1.1 - An object is a specific instance of a class with defined attributes 
1704:	      2.1.1.2 - A class is the formal implementation, or blueprint, of the attributes 
1705:	                 and behaviors of an object 
1706:	A "class" is the "blueprint" for creating an "object". In Java, the class is a way to 
1707:	use code to model "things" using properties and methods. The object is what the class 
1708:	"creates" when the class is made into a specific "object" of that class. The various 
1709:	terms used for this vary but all revolve around the same concepts. The term "object" 
1710:	can also be called a "instance" of the class. The term "properties" can also be 
1711:	called "things about the class", or "descriptors", or "adjectives", or 
1712:	"fields". The term "methods" could also be called "what the class can do", or 
1713:	"actions", or "verbs", or "functions". 
1714:	// Example of a simple class with properties and methods
1715:	class Person {
1716:	    String name;
1717:	    int age;
1718:	    void walk() {
1719:	        // code logic could go here
1720:	    }
1721:	    void talk() {
1722:	        // code logic could go here
1723:	    }
1724:	}
1725:	2.2 - Creating and Storing Objects (Instantiation).........................................
1726:	   2.2.1 - Identify, using its signature, the correct constructor being called
1727:	      2.2.1.1 - A signature consists of the constructor name and the parameter list 
1728:	      2.2.1.2 - The parameter list, in the header of a constructor, lists the types 
1729:	                 of the values that are passed and their variable names. These are often referred 
1730:	                 to as formal parameters 
1731:	      2.2.1.3 - A parameter is a value that is passed into a constructor. These 
1732:	                 are often referred to as actual parameters 
1733:	      2.2.1.4 - Constructors are said to be overloaded when there are multiple constructors 
1734:	                 with the same name but a different signature 
1735:	      2.2.1.5 - The actual parameters passed to a constructor must be compatible 
1736:	                 with the types identified in the formal parameter list 
1737:	      2.2.1.6 - Parameters are passed using call by value. Call by  value initializes 
1738:	                 the formal parameters with copies of the actual parameters 
1739:	   2.2.2 - For creating objects: a. Create objects by calling constructors without 
1740:	              parameters. b. Create objects by calling constructors with parameters
1741:	      2.2.2.1 - Every object is created using the keyword new followed by a call 
1742:	                 to one of the classs constructors 
1743:	      2.2.2.2 - A class contains constructors that are invoked to create objects. 
1744:	                 They have the same name as the class 
1745:	      2.2.2.3 - Existing classes and class libraries can be utilized as appropriate 
1746:	                 to create objects 
1747:	      2.2.2.4 - Parameters allow values to be passed to the constructor to establish 
1748:	                 the initial state of the object 
1749:	   2.2.3 - Define variables of the correct types to represent reference data
1750:	      2.2.3.1 - The keyword null is a special value used to indicate that a reference 
1751:	                 is not associated with any object 
1752:	      2.2.3.2 - The memory associated with a variable of a reference type holds 
1753:	                 an object reference value or, if there is no object, null. This value is the 
1754:	                 memory address of the referenced object                
1755:	Methods are a way to break up code into logic modules and it also provides a way to avoid 
1756:	repeating code and be able to reuse sections of code logic. You can think of methods as 
1757:	analogous to "machines" that perform "actions" and you can reuse. They are also analogous to 
1758:	"functions" in math that may take a variable "input" and generate an "answer".  The term 
1759:	"parameter" (and you may have zero, one, or more than one) is the "input" (if needed) to a 
1760:	method that is passed to the method. The value(s) passed are called "argument(s)". When you 
1761:	define the method in the method "signature" line, the round brackets can contain 
1762:	parameters separated by comma (if needed). A method may also give an "output" in the form 
1763:	of its "return" value (which also might not be needed, in which case it is a "void" method).
1764:	A method is "overloaded" if you have more than one method with the exact same name but 
1765:	different parameters. Classes have "constructor" methods that are called when 
1766:	a class is instantiated into an object. Constructor methods do not have a return type 
1767:	(not even the keyword "void"). They must have the exact same name as the class (including a 
1768:	capital letter). They are used to set the properties of the class to starting (or 
1769:	"default") values. If a class has multiple constructor methods, they are said to be 
1770:	overloaded constructors. When a line of code is used to instantiate a class into an instance 
1771:	of that class, the line includes the name of the class, the identifier name of the object, 
1772:	then an equals ("="), then the keyword "new" (which allots new memory for this 
1773:	advanced data type), then a call to a constructor method. If not constructor method 
1774:	is called, then the object references a "null" value until such time it is given a value to 
1775:	reference.
1776:	// Example of a class with constructors and instantiation
1777:	class Person {
1778:	    Person() {
1779:	        // code logic
1780:	    }
1781:	    Person(int age) {
1782:	        // code logic
1783:	    }
1784:	}
1785:	Person person1 = new Person();
1786:	Person person2 = new Person(5);
1787:	2.3 - Calling a Void Method................................................................
1788:	   2.3.1 - Call non-static void methods without parameters
1789:	      2.3.1.1 - An objects behavior refers to what the object can do (or what can 
1790:	                 be done to it) and is defined by methods 
1791:	      2.3.1.2 -  Procedural abstraction allows a programmer to use a method by knowing 
1792:	                 what the method does even if they do not know how the method was written 
1793:	      2.3.1.3 -  A method signature for a method without parameters consists of 
1794:	                 the method name and an empty parameter list
1795:	      2.3.1.4 -  A method or constructor call interrupts the sequential execution 
1796:	                 of statements, causing the program to first execute the statements in the 
1797:	                 method or constructor before continuing. Once the last statement in the method 
1798:	                 or constructor has executed or a return statement is executed, flow of control 
1799:	                 is returned to the point immediately following where the method or constructor 
1800:	                 was called 
1801:	      2.3.1.5 -  Non-static methods are called through objects of the Class 
1802:	      2.3.1.6 -  The dot operator is used along with the object name to call non-static 
1803:	                 methods 
1804:	      2.3.1.7 -  Void methods do not have return values and are therefore not called 
1805:	                 as part of an expression 
1806:	      2.3.1.8 -  Using a null reference to call a method or access an instance variable 
1807:	                 causes a NullPointerException to be thrown 
1808:	A "non-static" method is a method (meaning a "action", "behaviour", "procedure", 
1809:	or "verb") that does not use the "static" modifier word in the method signature line. 
1810:	A method with no prameters (or "inputs") means the method is defined with empty round 
1811:	brackets "( )". The "behavior" or action the method performs is defined in the body 
1812:	block of the method (between the two curly "{ }" brackets). The A.P. term "procedural 
1813:	abstraction" refers to a programmer being able to call a method without knowing how the 
1814:	method was written (also known as "black box" programming). When methods are "called" 
1815:	the execution flow stops, jumps and runs all the method body (or until a "return" 
1816:	statement) and then returns to the next line of execution after the method call line 
1817:	(or part of a code expression line). Methods can also be called from objects (or 
1818:	"instances") of a class using the dot "." operator. Void method do not return anthing 
1819:	(no "outputs") and use the keyword modifier "void" in the method signature in place of 
1820:	the return type.
1821:	// Examples of methods, parameters, return, and calling
1822:	public void show() {
1823:	    System.out.println("*")
1824:	}
1825:	public void show(char value) {
1826:	    System.out.println(value);
1827:	}
1828:	public int double(int number) {
1829:	    return number * 2;
1830:	} 
1831:	show();
1832:	show('A');
1833:	int answer = double(5);
1834:	2.4 - Calling a Void Method with Parameters ...............................................
1835:	   2.4.1 -  Call non-static void methods with parameters
1836:	      2.4.1.1 -  A method signature for a method with parameters consists of the 
1837:	                 method name and the ordered list of parameter types 
1838:	      2.4.1.2 -  Values provided in the parameter list need to correspond to the 
1839:	                 order and type in the method Signature 
1840:	      2.4.1.3 -  Methods are said to be overloaded when there are multiple methods 
1841:	                 with the same name but a different Signature 
1842:	A "non-static void" methods with parameters is a method with no outputs, but has input(s). 
1843:	This means the method signature has defined parameter(s) within the round brackets "( )" 
1844:	seperated by commas (if necessary). When this type of method is called, the "arguments" 
1845:	passed to this method must be in the same order in terms of data type. A method is 
1846:	"overloaded" when you have two or more methods with the same name but different and 
1847:	distinct parameter lists.
1848:	// Examples of method overloading
1849:	public void show() {
1850:	    System.out.println("*")
1851:	}
1852:	public void show(char value) {
1853:	    System.out.println(value);
1854:	}
1855:	public void show(int value) {
1856:	    System.out.println(value);
1857:	}
1858:	2.5 - Calling a Non-void Method  ..........................................................
1859:	   2.5.1 -  Call non-static non-void methods with or without parameters
1860:	      2.5.1.1 -  Non-void methods return a value that is the same type as the return 
1861:	                 type in the signature. To use the return value when calling a non-void method, 
1862:	                 it must be stored in a variable or used as part of an expression 
1863:	A method that does return a value, defines the return "type" in the method signature and 
1864:	the keyword "return" somewhere in the method body (at least once). When calling a return 
1865:	method, the value returned must be stored (in a variable) or used as part of an expression.
1866:	2.6 - String Objects: Concatenation, Literals, and More  ..................................
1867:	   2.6.1 -  For String class: a. Create String objects. b. Call String Methods
1868:	      2.6.1.1 -  String objects can be created by using string literals or by calling 
1869:	                 the String class constructor 
1870:	      2.6.1.2 -  String objects are immutable, meaning that String methods do not 
1871:	                 change the String object 
1872:	      2.6.1.3 -  String objects can be concatenated using the + or += operator, 
1873:	                 resulting in a new String object 
1874:	      2.6.1.4 -  Primitive values can be concatenated with a String object. This 
1875:	                 causes implicit conversion of the values to String objects 
1876:	      2.6.1.5 -  Escape sequences start with a \ and have a special meaning in Java. 
1877:	                 Escape sequences used in this course include \", \\, and \n 
1878:	The "String" class allows you to create String variables, concatenate them (join) 
1879:	together and use "built-in" methods of the String class. String literals (contained in 
1880:	quotes "") can be assigned to String variables or concatenated with Strings. String methods 
1881:	do not change the String ("immutable") object. The "+" or the "+=" operators can be used 
1882:	to concatenate Strings (resulting in a new String object). Primitives (like int, double, 
1883:	etc.) can also be concatenated with String objects. Those are now automatically converted 
1884:	to Strings and then concatenated. Escape sequences is the character "\" followed 
1885:	by another character to make certain outputs or changes to a String object. These include: 
1886:	\" for a quote, \\ for a slash, and \n for a new line.
1887:	// Examples of Strings and escape sequences
1888:	String str1 = "cat";
1889:	String str2 = str1 + "ty";
1890:	str1 += str2;
1891:	str2 = "\n" + str1 + "\\" + "\" dog";
1892:	2.7 - String Methods.......................................................................
1893:	   2.7.1 -  For String class: a. Create String objects. b. Call String methods
1894:	      2.7.1.1 -  Application program interfaces (APIs) and libraries simplify complex 
1895:	                 programming tasks 
1896:	      2.7.1.2 -  Documentation for APIs and libraries are essential to understanding 
1897:	                 the attributes and behaviors of an object of a class 
1898:	      2.7.1.3 -  Classes in the APIs and libraries are grouped into Packages 
1899:	      2.7.1.4 -  The String class is part of the java.lang package. Classes in the 
1900:	                 java.lang package are available by Default 
1901:	      2.7.1.5 -  A String object has index values from 0 to length  1. Attempting 
1902:	                 to access indices outside this range will result in an IndexOutOfBoundsException 
1903:	      2.7.1.6 -  A String object can be concatenated with an object reference, which 
1904:	                 implicitly calls the referenced object's toString method 
1905:	      2.7.1.7 -  The following String methods and constructorsincluding what they 
1906:	                 do and when they are usedare part of the Java Quick Reference: (A) String(String 
1907:	                 str)  Constructs a new String object that represents the same sequence of 
1908:	                 characters as str (B) int length()  Returns the number of characters in a 
1909:	                 String object (C) String substring(int from)  Returns substring(from, length()) 
1910:	                 (D) int indexOf(String str)  Returns the index of the first occurrence of 
1911:	                 str; returns -1 if not found (E) boolean equals(String other)  Returns true 
1912:	                 if this is equal to other; returns false otherwise (F) int compareTo(String 
1913:	                 other)  Returns a value < 0 if this is less than other; returns zero if this 
1914:	                 is equal to other; returns a value > 0 if this is greater than other  
1915:	      2.7.1.8 -  A string identical to the single element substring at position 
1916:	                 index can be created by calling substring(index, index + 1) 
1917:	The "API" or Application Program Interface is a "library" of code that could be imported 
1918:	into a Java project or it could automatically be part of every Java project without needing 
1919:	an import. Classes and libraries are organized into "packages" in Java (also known as 
1920:	"namespaces"). The String class is in the "java.lang" package. Strings are collections 
1921:	of "char" values index from 0 up to the length of the String minus 1 (just like arrays 
1922:	are indexed). String methods used are: the String constructor "String s = new String();", 
1923:	the "length()" method, the "substring(int)" and "substring(int,int)" methods, the 
1924:	"indexOf(String)" method, the "equals(String)" method, and the 
1925:	"compareTo(String)" method.
1926:	// Examples of String methods
1927:	String str3 = new String("chatty");
1928:	// Constructs object with same sequence of characters as str3
1929:	int length = str3.length();
1930:	// Returns the number of characters in a String object
1931:	String str4 = str3.substring(1);
1932:	// Returns substring(from) starting at index "from" to the end
1933:	String str5 = str3.substring(1,3);
1934:	// Returns substring(from, to) starting at index "from" to index "to"
1935:	int index = str3.indexOf("hat");
1936:	// Returns the index of the first occurrence (returns -1 if not found)
1937:	boolean result1 = str3.equals(str4);
1938:	// Returns true if this is equal to other (returns false otherwise)
1939:	int result2 = str3.compareTo(str5);
1940:	// Returns value < 0 if less than other, returns 0 if equal to other,
1941:	// and returns value > 0 if greater than other
1942:	2.8 - Wrapper Classes: Integer and Double  ................................................
1943:	   2.8.1 -  For wrapper classes: a. Create Integer objects, b. Call Integer methods, 
1944:	              c. Create Double objects, d. Call Double Methods
1945:	      2.8.1.1 -  The Integer class and Double class are part of the java.lang package 
1946:	      2.8.1.2 -  The following Integer methods and constructors  including what 
1947:	                 they do and when they are usedare part of the Java Quick Reference: (A) Integer(int 
1948:	                 value)  Constructs a new Integer object that represents the specified int 
1949:	                 value (B) Integer.MIN_VALUE  The minimum value represented by an int or Integer 
1950:	                 (C) Integer.MAX_VALUE  The maximum value represented by an int or Integer 
1951:	                 (D) int intValue()  Returns the value of this Integer as an Int 
1952:	      2.8.1.3 -  The following Double methods and constructors including what they 
1953:	                 do and when they are usedare part of the Java Quick Reference: (A) double 
1954:	                 doubleValue()  Returns the value of this Double as a double 
1955:	      2.8.1.4 -  Autoboxing is the automatic conversion that the Java compiler makes 
1956:	                 between primitive types and their corresponding object wrapper classes. This 
1957:	                 includes converting an int to an Integer and a double to a Double 
1958:	      2.8.1.5 -  The Java compiler applies autoboxing when a primitive value is: 
1959:	                 (A) Passed as a parameter to a method that expects an object of the corresponding 
1960:	                 wrapper class. (B) Assigned to a variable of the corresponding wrapper class 
1961:	      2.8.1.6 -  Unboxing is the automatic conversion that the Java compiler makes 
1962:	                 from the wrapper class to the primitive type. This includes converting an 
1963:	                 Integer to an int and a Double to a double 
1964:	      2.8.1.7 -  The Java compiler applies unboxing when a wrapper class object 
1965:	                 is: (A) Passed as a parameter to a method that expects a value of the corresponding 
1966:	                 primitive type (B) Assigned to a variable of the corresponding primitive type 
1967:	A "wrapper class" is a class type that is based in a primitive data type. For example the 
1968:	primitive data type "int" has the wrapper class "Integer". Similarily, the "Double" 
1969:	wrapper class, wraps around the "double" primitive type. The wrapper classes (using a 
1970:	capital letter) are part of java.lang and have built-in methods like "parseInt()" and 
1971:	"parseDouble()". Other methods include: "Integer(int)" a constructor, 
1972:	"Double(double)" a constructor, "MIN_VALUE" a constant, "MAX_VALUE", "intValue()", and 
1973:	"doubleValue()". Boxing and unboxing can be done between the wrapper classes and the 
1974:	primitive types (known as "autoboxing"). The term "boxing" means the conversion between 
1975:	primitive types and corresponding wrapper. The term "unboxing" means the conversion 
1976:	from the wrapper class to the primitive type.
1977:	// Example of wrapper classes and methods...
1978:	int     integerPrimitive1 = Integer.parseInt("10");
1979:	double  doublePrimitive1  = Double.parseDouble("1.2");
1980:	Integer integerObject     = new Integer("10");
1981:	Double  doubleObject      = new Double("1.2");
1982:	int     integerPrimitive2 = integerObject.intValue();
1983:	double  doublePrimitive2  = doubleObject.doubleValue();
1984:	int     minInteger        = Integer.MIN_VALUE;
1985:	int     maxInteger        = Integer.MAX_VALUE;
1986:	double  minDouble         = Double.MIN_VALUE;
1987:	double  maxDouble         = Double.MAX_VALUE;
1988:	// Boxing and unboxing...
1989:	int     integerPrimitive3 = integerObject1;
1990:	double  doublePrimitive3  = doubleObject1;
1991:	Integer integerObject2    = integerPrimitive3;
1992:	Double  doubleObject2     = doublePrimitive3;
1993:	2.9 - Using the Math Class  ...............................................................
1994:	   2.9.1 -  Call static methods
1995:	      2.9.1.1 - Static methods are called using the dot operator along with the 
1996:	                 class name unless they are defined in the enclosing class 
1997:	   2.9.2 -  Evaluate expressions that use the Math class methods
1998:	      2.9.2.1 -  The Math class is part of the java.lang package 
1999:	      2.9.2.2 -  The Math class contains only static methods 
2000:	      2.9.2.3 -  The following static Math methodsincluding what they do and when 
2001:	                 they are usedare part of the Java Quick Reference: (A) int abs(int x)  Returns 
2002:	                 the absolute value of an int value (B) double abs(double x)  Returns the 
2003:	                 absolute value of a double value (C) double pow(double base, double exponent) 
2004:	                  Returns the value of the first parameter raised to the power of the second 
2005:	                 parameter (D) double sqrt(double x)  Returns the positive square root of 
2006:	                 a double value (E) double random()  Returns a double value greater than or 
2007:	                 equal to 0.0 and less than 1.0 
2008:	      2.9.2.4 -  The values returned from Math.random can be manipulated to produce 
2009:	                 a random int or double in a defined range 
2010:	The "Math" class is part of the java.lang package and has built-in static methods that can 
2011:	be called. Useful methods include: abs, pow, sqrt, and random. Including manipulating the 
2012:	random method in a formula to define random numbers in a range. Examples of this follow...
2013:	// Examples of the Math class methods and randoms...
2014:	int    value1 = Math.abs(-1);
2015:	double value2 = Math.abs(-1.2);
2016:	double value3 = Math.pow(2,3);
2017:	double value4 = Math.sqrt(9);
2018:	double value5 = Math.random();
2019:	final double HIGH = 10.9d;
2020:	final double LOW  = 5.5d;
2021:	double value6 = (HIGH - LOW + 1.0d) * Math.random() + LOW;
2022:	Computer Science 42SAP - AP: Unit 5 (Writing Classes) content running simulated:...........
2023:	Unit 5 - Writing Classes...................................................................
2024:	5.1 - Anatomy of a Class  .................................................................
2025:	   5.1.1 - Designate access and visibility constraints to classes, data, constructors, 
2026:	              and methods
2027:	      5.1.1.1 - The keywords public and private affect the access of  classes, data, 
2028:	                  constructors, and methods 
2029:	      5.1.1.2 - The keyword private restricts access to the declaring class, while 
2030:	                 the keyword public allows access from classes outside the declaring class 
2031:	      5.1.1.3 - Classes are designated public 
2032:	      5.1.1.4 - Access to attributes should be kept internal to the class. Therefore, 
2033:	                 instance variables are designated  as private 
2034:	      5.1.1.5 - Constructors are designated public 
2035:	      5.1.1.6 - Access to behaviors can be internal or external to the class. Therefore, 
2036:	                 methods can be designated as either public or private 
2037:	   5.1.2 - Designate private visibility of instance variables to encapsulate the 
2038:	              attributes of an object
2039:	      5.1.2.1 - Data encapsulation is a technique in which the implementation details 
2040:	                 of a class are kept hidden from the user 
2041:	      5.1.2.2 - When designing a class, programmers make decisions about what data 
2042:	                 to make accessible and modifiable from an external class. Data can be either 
2043:	                 accessible or modifiable, or it can be both or neither 
2044:	      5.1.2.3 - Instance variables are encapsulated by using the private access 
2045:	                 modifier 
2046:	      5.1.2.4 - The provided accessor and mutator methods in a class allow client 
2047:	                 code to use and modify data 
2048:	The properties (attributes) and methods (actions) of a class can be defined in terms of 
2049:	visibility. This means that the keywords "public" and "private" can be used as a 
2050:	modifier in the front of a method signature or at the front of a property declaration line 
2051:	to define the encapsulation level. The public keyword means the property can be accessed (and 
2052:	modified) both inside the class and from other classes outside the class. In terms of methods 
2053:	it means the method can be called within the class (by other methods) and outside the class 
2054:	from other classes using the dot "." operator. Classes and constructor methods are 
2055:	designated public. The concept of "encapsulation" is used to make certain data and actions 
2056:	private and protect them from outside classes and perhaps only allow access through accessor 
2057:	and modifier ("getter" and "setter") methods.
2058:	// Class example private/public properties and methods
2059:	class Apple { 
2060:	    public int number;
2061:	    private double price;
2062:	    public void eat() {
2063:	        // logic here
2064:	    }
2065:	    private void spoil() {
2066:	        // logic here
2067:	    }
2068:	}
2069:	5.2 - Constructors  .......................................................................
2070:	   5.2.1 - Define instance variables for the attributes to be initialized through 
2071:	              the constructors of a class
2072:	      5.2.1.1 - An objects state refers to its attributes and their values at a 
2073:	                 given time and is defined by instance variables belonging to the object. This 
2074:	                 creates a  "has-a" relationship between the object and its instance variables 
2075:	      5.2.1.2 - Constructors are used to set the initial state of an object, which 
2076:	                 should include initial values for all instance variables 
2077:	      5.2.1.3 - Constructor parameters are local variables to the constructor and 
2078:	                 provide data to initialize instance variables 
2079:	      5.2.1.4 - When a mutable object is a constructor parameter, the instance variable 
2080:	                 should be initialized with a copy of the referenced object. In this way, the 
2081:	                 instance variable is not an alias of the original object, and methods are 
2082:	                 prevented from modifying the state of the original object 
2083:	      5.2.1.5 - When no constructor is written, Java provides a no-argument constructor, 
2084:	                 and the instance variables are set to default values 
2085:	A constructor method is a special method defined in a class that is called when a class is 
2086:	instantiated into an instance (or "object") of that class. The constructor method has to have 
2087:	the exact same name as the class (including letter case) and no return type (not even the 
2088:	word void). Constructors are usually used to set the initial (or "default") values for the 
2089:	class properties. This can be said to be setting the "state" of the object. If any of the 
2090:	properties (attributes) are another class level instance variable (not a primitive type), 
2091:	then this class is said to have a "has-a" relationship with that class. This can also be 
2092:	called "association" or "composition" between the classes. Constructors can have 
2093:	parameters passed to the class that can be used in setting the initial state. When no 
2094:	constructor is written, Java provides a no-argument constructor, and the instance 
2095:	variables are set to default values.
2096:	// Class example association and constructors
2097:	class Basket {
2098:	    public Apple apple;
2099:	    public Basket() {
2100:	        // logic here
2101:	    }
2102:	    public Basket(Apple apple) {
2103:	        // logic here
2104:	    }
2105:	}
2106:	5.3 - Documentation with Comments  ........................................................
2107:	   5.3.1 - Describe the functionality and use of program code through comments
2108:	      5.3.1.1 - Comments are ignored by the compiler and are not executed when the 
2109:	                 program is run 
2110:	      5.3.1.2 - Three types of comments in Java include /* */, which generates a 
2111:	                 block of comments, //, which generates a comment on one line, and /** */, 
2112:	                 which are Javadoc comments and are used to create API documentation 
2113:	      5.3.1.3 - A precondition is a condition that must be true just prior to the 
2114:	                 execution of a section of program code in order for the method to behave as 
2115:	                 expected. There is no expectation that the method will check to ensure preconditions 
2116:	                 are satisfied 
2117:	      5.3.1.4 - A postcondition is a condition that must always be true after the 
2118:	                 execution of a section of program code. Postconditions describe the outcome 
2119:	                 of the execution in terms of what is being returned or the state of an object 
2120:	      5.3.1.5 - Programmers write method code to satisfy the postconditions when 
2121:	                 preconditions are met 
2122:	Comments are a documentation system that allows programmers to leave notes for themselves or 
2123:	other programmers. This can serve several purposes including (but not limited to) 
2124:	documenting names and dates, explaining code logic, working through problem solving logic, 
2125:	and others. In Java, the two forward slashes // allows a comment at the end of a line of code or 
2126:	on its own line. A slash and a star /* opens a comment block which will continue until a star 
2127:	and slash */ closes the comment block. The slash and two stars /** open the JavaDoc style of 
2128:	comment block which many IDEs (e.g. NetBeans) recognize and help with commenting and to create 
2129:	API documentation. Methods should be commented with the method's purpose (a brief description), 
2130:	any pre-conditions (the parameters if any), and post-conditions (the return type if any) of the 
2131:	method.
2132:	// Comments...
2133:	// a standard comment
2134:	/* opens a comment block */
2135:	/** JavaDoc comment block */
2136:	5.4 - Accessor Methods  ...................................................................
2137:	   5.4.1 - Define behaviors of an object through non-void methods without parameters 
2138:	              written in a class
2139:	      5.4.1.1 - An accessor method allows other objects to obtain the  value of 
2140:	                 instance variables or static variables 
2141:	      5.4.1.2 - A non-void method returns a single value. Its header includes the 
2142:	                 return type in place of the keyword void 
2143:	      5.4.1.3 - In non-void methods, a return expression compatible with the return 
2144:	                 type is evaluated, and a copy of that value is returned. This is referred 
2145:	                 to as "return by  value."  
2146:	      5.4.1.4 - When the return expression is a reference to an object, a copy of 
2147:	                 that reference is returned, not a copy of the object 
2148:	      5.4.1.5 - The return keyword is used to return the flow of control to the 
2149:	                 point immediately following where the method or constructor was called 
2150:	      5.4.1.6 - The toString method is an overridden method that is included in 
2151:	                 classes to provide a description of a specific object. It generally includes 
2152:	                 what values are stored in the instance data of the object 
2153:	      5.4.1.7 - If System.out.print or System.out.println is passed an object, that 
2154:	                 objects toString method is called, and the returned string is printed 
2155:	Accessor methods are the names given to methods in a class that "access" data. this usually 
2156:	means properties of the class that are encapsulated (private). Other names for 
2157:	accessors are "getters" or "get" methods. The method (behaviours, actions, functions, 
2158:	procedures) of a class are accessed with the dot operator (".") after the name of the 
2159:	object (instance of the class). Non-void methods that return a value can then be used as 
2160:	part of a code line expression. The return type of the method must be compatible with any 
2161:	data types (e.g. variables) being used in the expression. If the return type is a class level 
2162:	type then the method returns a reference to the actual object ("return by reference") not a 
2163:	reference to a copy ("return by value") of the actual object. If the "System.out.print" 
2164:	or "System.out.println" methods are called and an object is passed to those methods, the 
2165:	object's "toString()" method is automatically 
2166:	invoked (called) in the output.
2167:	// Examples of calling methods in a class
2168:	class Fighter {
2169:	    private int health;
2170:	    private Weapon weapon;
2171:	    public int getHealth() {
2172:	        return health;
2173:	    }
2174:	    public Weapon getWeapon() {
2175:	        return weapon;
2176:	    }
2177:	}
2178:	Fighter fighter = new Fighter();
2179:	int hp = fighter.health;
2180:	Weapon club = fighter.getWeapon();
2181:	5.5 - Mutator Methods  ....................................................................
2182:	   5.5.1 - Define behaviors of an object through void methods with or without parameters 
2183:	              written in a class
2184:	      5.5.1.1 - A void method does not return a value. Its header contains the keyword 
2185:	                 void before the method name 
2186:	      5.5.1.2 - A mutator (modifier) method is often a void method that changes 
2187:	                 the values of instance variables or static variables 
2188:	Mutator methods are the name given to methods that "change" a property of a class (usually 
2189:	an encapsulated property). These can be void methods (but are sometimes boolean methods to 
2190:	indicate success or not).
2191:	// Examples of calling mutator methods in a class
2192:	class Fighter {
2193:	    private int health;
2194:	    public int setHealth(int health) {
2195:	        this.health = health;
2196:	    }
2197:	}
2198:	Fighter fighter = new Fighter();
2199:	fighter.setHealth(10);
2200:	5.6 - Writing Methods  ....................................................................
2201:	   5.6.1 - Define behaviors of an object through non-void methods with parameters 
2202:	              written in a class
2203:	      5.6.1.1 - Methods can only access the private data and methods of a parameter 
2204:	                 that is a reference to an object when the parameter is the same type as the 
2205:	                 methods enclosing class 
2206:	      5.6.1.2 - Non-void methods with parameters receive values through parameters, 
2207:	                 use those values, and return a computed value of the specified type 
2208:	      5.6.1.3 - It is good programming practice to not modify mutable objects that 
2209:	                 are passed as parameters unless required in the specification 
2210:	      5.6.1.4 - When an actual parameter is a primitive value, the formal parameter 
2211:	                 is initialized with a copy of that value. Changes to the formal parameter 
2212:	                 have no effect on the corresponding actual parameter 
2213:	      5.6.1.5 - When an actual parameter is a reference to an object, the formal 
2214:	                 parameter is initialized with a copy of that reference, not a copy of the 
2215:	                 object. If the reference is to a mutable object, the method or constructor 
2216:	                 can use this reference to alter the state of the object 
2217:	      5.6.1.6 - Passing a reference parameter results in the formal parameter and 
2218:	                 the actual parameter being aliases. They both refer to the same object 
2219:	Methods are written to model an "action". Also known as functions or procedures, methods may 
2220:	or may not have zero, one, or more than one "input(s)" called "parameters" (or empty round 
2221:	brackets if no inputs are required). Methods may have zero (a "void" method) or one "output" 
2222:	known as the return type. If the parameter is a primitive data type, then a copy of the data 
2223:	from the original primitive type is passed to the method ("pass by value"). If the parameter 
2224:	is an advanced data type ("class" level data) then a reference to that object is passed. This 
2225:	means that any changes the method makes to the object will be reflected (unless the object 
2226:	was an immutable object). Because the passed reference object parameter and the original 
2227:	argument object are "linked" they can be referred to as "aliases".
2228:	5.7 - Static Variables and Methods  .......................................................
2229:	   5.7.1 - Define behaviors of a class through static methods
2230:	      5.7.1.1 - Static methods are associated with the class, not objects of the 
2231:	                 class 
2232:	      5.7.1.2 - Static methods include the keyword static in the header before the 
2233:	                 method name 
2234:	      5.7.1.3 - Static methods cannot access or change the values of instance variables 
2235:	      5.7.1.4 - Static methods can access or change the values of static variables 
2236:	      5.7.1.5 - Static methods do not have a this reference and are unable to use 
2237:	                 the classs instance variables or call non-static methods 
2238:	   5.7.2 - Define the static variables that belong to the class 
2239:	      5.7.2.1 - Static variables belong to the class, with all objects of a class 
2240:	                 sharing a single static variable 
2241:	      5.7.2.2 - Static variables can be designated as either public or private and 
2242:	                 are designated with the static keyword before the variable type 
2243:	      5.7.2.3 - Static variables are used with the class name and the dot operator, 
2244:	                 since they are associated with a class, not objects of a class 
2245:	Although they can be called from an object of a class, "static" methods are generally called 
2246:	from the class name itself. Static methods "belong" to the class itself and therefore 
2247:	do not require you to instantiate an object to call a method from that class. The keyword 
2248:	"static" is included as a modifier word in the method signature line. Static methods 
2249:	cannot access or change the values of instance properties of a class but can change/access 
2250:	static properties. Static properties (variables) also "belong" to the class itself 
2251:	and are "shared" by all objects of the class. Static properties can be either public or 
2252:	private and are also declared using the "static" keyword as a modifier for the 
2253:	property. Static properties are used with the class name and then the dot operator and then 
2254:	the name of the property (although they can also be accessed from an object name). 
2255:	// Static properties and methods
2256:	class Fighter {
2257:	    public static int number;
2258:	    public static void attack() {
2259:	        // logic here
2260:	    }
2261:	}
2262:	Fighter.number = 10;
2263:	Fighter.attack();
2264:	5.8 - Scope and Access  ...................................................................
2265:	   5.8.1 - Explain where variables can be used in the program code
2266:	      5.8.1.1 - Local variables can be declared in the body of constructors and 
2267:	                 methods. These variables may only be used within the constructor or method 
2268:	                 and cannot be declared to be public or private 
2269:	      5.8.1.2 - When there is a local variable with the same name as an instance 
2270:	                 variable, the variable name will refer to the local variable instead of the 
2271:	                 instance variable 
2272:	      5.8.1.3 - Formal parameters and variables declared in a method or constructor 
2273:	                 can only be used within that method or constructor 
2274:	      5.8.1.4 - Through method decomposition, a programmer breaks down a large problem 
2275:	                 into smaller subproblems by creating methods to solve each individual subproblem 
2276:	Variables can be used throughout code in classes and methods and have a "scope" defining where 
2277:	the variable can be accessed and modified. A "local" variable is one which is defined in a 
2278:	code block like a control structure (a loop or if statement) or a method. The scope of that 
2279:	variable is that internal code block and no other variables can have the same name within 
2280:	that scope. A "global" variable is one declared at the class level and its scope is 
2281:	the entire code module (class). When there is a local variable with the same name as a global 
2282:	variable, the variable name will reference the local variable over the global variable. This 
2283:	could be a potential name conflict. The keyword "this" with the dot operator can make an 
2284:	explicit reference to the global variable over the local variable. 
2285:	// Local and global variable scopes
2286:	class Fighter {
2287:	    public int number;
2288:	    public void attack(int number) {
2289:	        this.number = number;
2290:	    }
2291:	}
2292:	5.9 - this Keyword  .......................................................................
2293:	   5.9.1 - Evaluate object reference expressions that use the keyword this
2294:	      5.9.1.1 - Within a non-static method or a constructor, the keyword this is 
2295:	                 a reference to the current object the object whose method or constructor is 
2296:	                 being called 
2297:	      5.9.1.2 - The keyword this can be used to pass the current object as an actual 
2298:	                 parameter in a method call 
2299:	The keyword "this" is an explicit reference to the (eventual) object within a class. It 
2300:	refers to the name of an object that will later be instantiated by the class the word this 
2301:	is used within. The word "this" can be used to give explicit control to a global variable 
2302:	or call a class method. The keyword "this" can also be used to pass the current object 
2303:	as an actual parameter in a method call.
2304:	5.10 - Ethical and Social Implications of Computing Systems  ..............................
2305:	   5.10.1 - Explain the ethical and social implications of computing systems
2306:	      5.10.1.1 - System reliability is limited. Programmers should make an effort 
2307:	                 to maximize system reliability 
2308:	      5.10.1.2 - Legal issues and intellectual property concerns arise when creating 
2309:	                 programs 
2310:	      5.10.1.3 - The creation of programs has impacts on society, economies, and 
2311:	                 culture. These impacts can be beneficial and/or harmful 
2312:	The social and ethical considerations of computing and Computer Science are things as 
2313:	an A.P. student you should be aware of. These are not necessarily testable concepts on the 
2314:	A.P. exam. The general ideas of legality, impact, and reliability of computing systems 
2315:	and software should always be considered by programers and Computer Scientists.
2316:	Computer Science 42SAP - AP: Unit 9 (Inheritance) content running simulated:...............
2317:	Unit 9 - Inheritance           ............................................................
2318:	9.1 - Creating Superclasses and Subclasses  ...............................................
2319:	   9.1.1 -  Create an inheritance relationship from a subclass to the superclass
2320:	      9.1.1.1 - A class hierarchy can be developed by putting common attributes 
2321:	                 and behaviors of related classes into a single class called a superclass 
2322:	      9.1.1.2 - Classes that extend a superclass, called subclasses, can draw upon 
2323:	                 the existing attributes and behaviors  of the superclass without repeating 
2324:	                 these in the code 
2325:	      9.1.1.3 - Extending a subclass from a superclass creates an "is-a" relationship 
2326:	                 from the subclass to the superclass 
2327:	      9.1.1.4 - The keyword extends is used to establish an inheritance relationship 
2328:	                 between a subclass and a superclass. A class can extend only one superclass 
2329:	Add your own example(s) here...
2330:	9.2 - Writing Constructors for Subclasses..................................................
2331:	   9.2.1- Create an inheritance relationship from a subclass to the Superclass
2332:	      9.2.1.1 - Constructors are not inherited 
2333:	      9.2.1.2 - The superclass constructor can be called from the first line of 
2334:	                 a subclass constructor by using the keyword super and passing appropriate 
2335:	                 parameters 
2336:	      9.2.1.3 - The actual parameters passed in the call to the superclass constructor 
2337:	                 provide values that the constructor can use to initialize the objects instance 
2338:	                 variables 
2339:	      9.2.1.4 - When a subclasss constructor does not explicitly call a superclasss 
2340:	                 constructor using super, Java inserts a call to the superclasss no-argument 
2341:	                 constructor
2342:	      9.2.1.5 - Regardless of whether the superclass constructor is called implicitly 
2343:	                 or explicitly, the process of calling superclass constructors continues until 
2344:	                 the Object constructor is called. At this  point, all of the constructors 
2345:	                 within the hierarchy execute beginning with the Object constructor 
2346:	Add your own example(s) here...
2347:	9.3 - Overriding Methods  .................................................................
2348:	   9.3.1 - Create an inheritance relationship from a subclass to the Superclass
2349:	      9.3.1.1 - Method overriding occurs when a public method in a subclass has 
2350:	                 the same method signature as a public method in the superclass 
2351:	      9.3.1.2 - Any method that is called must be defined within its own class or 
2352:	                 its superclass 
2353:	      9.3.1.3 - A subclass is usually designed to have modified (overridden) or 
2354:	                 additional methods or instance Variables 
2355:	      9.3.1.4 - A subclass will inherit all public methods from the superclass; 
2356:	                 these methods remain public in the subclass 
2357:	Add your own example(s) here...
2358:	9.4 - super Keyword  ......................................................................
2359:	   9.4.1 - Create an inheritance relationship from a subclass to the superclass
2360:	      9.4.1.1 - The keyword super can be used to call a superclass's constructors 
2361:	                 and methods 
2362:	      9.4.1.2 - The superclass method can be called in a subclass by using the keyword 
2363:	                 super with the method name and passing appropriate parameters 
2364:	Add your own example(s) here...
2365:	9.5 - Creating References Using Inheritance Hierarchies  ..................................
2366:	   9.5.1 - Define reference variables of a superclass to be assigned to an object 
2367:	              of a subclass in the same hierarchy
2368:	      9.5.1.1 - When a class S is-a class T, T is referred to as a superclass, 
2369:	                 and S is referred to as a subclass 
2370:	      9.5.1.2 - If S is a subclass of T, then assigning an object of type S to a 
2371:	                 reference of type T facilitates Polymorphism 
2372:	      9.5.1.3 - If S is a subclass of T, then a reference of type T can be used 
2373:	                 to refer to an object of type T or S 
2374:	      9.5.1.4 - Declaring references of type T, when S is a subclass of T, is useful 
2375:	                 in the following declarations: (a) Formal method parameters, (b) arrays  
2376:	                 T[] var ArrayList<T> var 
2377:	Add your own example(s) here...
2378:	9.6 - Polymorphism  .......................................................................
2379:	   9.6.1 - Call methods in an inheritance relationship
2380:	      9.6.1.1 - Utilize the Object class through inheritance
2381:	      9.6.1.2 - At compile time, methods in or inherited by the declared type determine 
2382:	                 the correctness of a non-static method call 
2383:	      9.6.1.3 - At run-time, the method in the actual object type is executed for 
2384:	                 a non-static method call 
2385:	Add your own example(s) here...
2386:	9.7 - Object Superclass  ..................................................................
2387:	   9.7.1 - Call Object class methods through inheritance
2388:	      9.7.1.1 - The Object class is the superclass of all other classes in Java 
2389:	      9.7.1.2 - The Object class is part of the java.lang package 
2390:	      9.7.1.3 - The following Object class methods and constructorsincluding what 
2391:	                 they do and when they are usedare part of the Java Quick Reference: (a) boolean 
2392:	                 equals(Object other), (b) String toString() 
2393:	      9.7.1.4 - Subclasses of Object often override the equals and toString methods 
2394:	                 with class specific implementations 
2395:	Add your own example(s) here...
2396:	Computer Science 42SAP - AP curriculum - Part 3 content running simulated:.................
2397:	Computer Science 42SAP - AP: Unit 6 (Arrays) content running simulated:....................
2398:	Unit 6 - Arrays............................................................................
2399:	6.1 - Array Creation and Access  ..........................................................
2400:	   6.1.1 - Represent collections of related primitive or object reference data using 
2401:	              one dimensional (1D - array objects)
2402:	      6.1.1.1 - The use of array objects allows multiple related items to be represented 
2403:	                 using a single variable 
2404:	      6.1.1.2 - The size of an array is established at the time of creation and 
2405:	                 cannot be changed 
2406:	      6.1.1.3 - Arrays can store either primitive data or object reference data 
2407:	      6.1.1.4 - When an array is created using the keyword new, all of its elements 
2408:	                 are initialized with a specific value based on the type of  elements: (a) 
2409:	                 Elements of type int are initialized to 0, (b) Elements of type double are 
2410:	                 initialized to 0.0, (c) Elements of type boolean are initialized to false, 
2411:	                 (d) Elements of a reference type are initialized to the reference value null. 
2412:	                 No objects are automatically created 
2413:	      6.1.1.5 - Initializer lists can be used to create and initialize arrays 
2414:	      6.1.1.6 - Square brackets [ ] are used to access and modify an element in 
2415:	                 a 1D array using an index 
2416:	      6.1.1.7 - The valid index values for an array are 0 through one less than 
2417:	                 the number of elements in the array, inclusive. Using an index value outside 
2418:	                 of this range will result in an ArrayIndexOutOfBoundsException being thrown 
2419:	Add your own example(s) here...
2420:	6.2 - Traversing Arrays  ..................................................................
2421:	   6.2.1 - Traverse the elements in a 1D array
2422:	      6.2.1.1 - Iteration statements can be used to access all the elements in an 
2423:	                 array. This is called traversing the array 
2424:	      6.2.1.2 - Traversing an array with an indexed for loop or while loop requires 
2425:	                 elements to be accessed using their indices 
2426:	      6.2.1.3 - Since the indices for an array start at 0 and end at the number 
2427:	                 of elements  1, off by one errors are easy to make when traversing an array, 
2428:	                 resulting in an ArrayIndexOutOfBoundsException being thrown 
2429:	Add your own example(s) here...
2430:	6.3 - Enhanced for Loop for Arrays  .......................................................
2431:	   6.3.1 - Traverse the elements in a 1D array object using an enhanced for loop
2432:	      6.3.1.1 - An enhanced for loop header includes a variable, referred to as 
2433:	                 the enhanced for loop variable 
2434:	      6.3.1.2 - For each iteration of the enhanced for loop, the enhanced for loop 
2435:	                 variable is assigned a copy of an element without using its index 
2436:	      6.3.1.3 - Assigning a new value to the enhanced for loop variable does not 
2437:	                 change the value stored in the array 
2438:	      6.3.1.4 - Program code written using an enhanced for loop to traverse and 
2439:	                 access elements in an array can be rewritten using an indexed for loop or 
2440:	                 a while loop 
2441:	Add your own example(s) here...
2442:	6.4 - Developing Algorithms Using Arrays  .................................................
2443:	   6.4.1 - For algorithms in the context of a particular specification that requires 
2444:	              the use of array traversals: (a) Identify standard algorithms, (b) Modify standard 
2445:	              algorithms, (c) Develop an algorithm
2446:	      6.4.1.1 - There are standard algorithms that utilize array traversals to: 
2447:	                 (a) Determine a minimum or maximum value, (b) Compute a sum, average, or mode, 
2448:	                 (c) Determine if at least one element has a particular property, (d) Determine 
2449:	                 if all elements have a particular property, (e) Access all consecutive pairs 
2450:	                 of elements, (f) Determine the presence or absence of  duplicate elements, 
2451:	                 (g) Determine the number of elements meeting specific criteria 
2452:	      6.4.1.2 - There are standard array algorithms that utilize traversals to: 
2453:	                 (a) Shift or rotate elements left or right, (b) Reverse the order of the elements 
2454:	Add your own example(s) here...
2455:	Computer Science 42SAP - AP: Unit 8 (2D Arrays) content running simulated:.................
2456:	Unit 8 - 2D Arrays       ..................................................................
2457:	8.1 - 2D Arrays  ..........................................................................
2458:	   8.1.1 - Represent collections of related primitive or object reference data using 
2459:	              two-dimensional (2D) array objects
2460:	      8.1.1.1 - 2D arrays are stored as arrays of arrays. Therefore, the way 2D 
2461:	                 arrays are created and indexed is similar to 1D array objects 
2462:	      8.1.1.2 - For the purposes of the exam, when accessing the element at arr[first][second], 
2463:	                 the first index is used for rows, the second index is used for columns 
2464:	      8.1.1.3 - The initializer list used to create and initialize a 2D array consists 
2465:	                 of initializer lists that represent 1D arrays 
2466:	      8.1.1.4 - The square brackets [row][col] are used to access and modify an 
2467:	                 element in a 2D array 
2468:	      8.1.1.5 - Row-major order refers to an ordering of 2D array elements where 
2469:	                 traversal occurs across each row, while column-major order traversal occurs 
2470:	                 down each column 
2471:	Add your own example(s) here...
2472:	8.2 - Traversing 2D Arrays  ...............................................................
2473:	   8.2.1 - For 2D array objects: (a) Traverse using nested for loops, (b) Traverse 
2474:	              using nested enhanced for loops
2475:	      8.2.1.1 - Nested iteration statements can be written to traverse the 2D array 
2476:	                 in row-major order or column-major Order. 
2477:	      8.2.1.2 - The outer loop of a nested enhanced for loop used to traverse a 
2478:	                 2D array traverses the rows. Therefore, the enhanced for loop variable must 
2479:	                 be the type of each row, which is a 1D array. The inner loop traverses a single 
2480:	                 row.  Therefore, the inner enhanced for loop variable must be the same type 
2481:	                 as the elements stored in the 1D array       
2482:	Add your own example(s) here...
2483:	Computer Science 42SAP - AP curriculum - Part 4 content running simulated:.................
2484:	Computer Science 42SAP - AP: Unit 7 (Array List) content running simulated:................
2485:	Unit 7 - Array List........................................................................
2486:	7.1 - Introduction to ArrayList  ..........................................................
2487:	   7.1.1 - Represent collections of related object reference data using ArrayList 
2488:	              objects
2489:	      7.1.1.1 - An ArrayList object is mutable and contains object references
2490:	      7.1.1.2 - The ArrayList constructor ArrayList() constructs an empty list 
2491:	      7.1.1.3 - Java allows the generic type ArrayList<E>, where the generic type 
2492:	                 E specifies the type of the elements 
2493:	      7.1.1.4 - When ArrayList<E> is specified, the types of the reference parameters 
2494:	                 and return type when using the methods are type E 
2495:	      7.1.1.5 - ArrayList<E> is preferred over ArrayList because it allows the compiler 
2496:	                 to find errors that would otherwise be found at run-time 
2497:	Add your own example(s) here...
2498:	7.2 - ArrayList Methods  ..................................................................
2499:	   7.2.1 - Represent collections of related object reference data using ArrayList 
2500:	              objects
2501:	      7.2.1.1 - The ArrayList class is part of the java.util package.  An import 
2502:	                 statement can be used to make this class available for use in the program 
2503:	      7.2.1.2 - The following ArrayList methodsincluding what they do and when 
2504:	                 they are usedare part of the Java Quick Reference: (a) int size() - Returns 
2505:	                 the number of elements in the list, (b) boolean add(E obj) - Appends obj to 
2506:	                 end of list; returns true, (c) void add(int index, E obj) - Inserts obj at 
2507:	                 position index (0 <= index <= size), moving elements at position index and 
2508:	                 higher to the right (adds 1 to their indices) and adds 1 to size, (d) E get(int 
2509:	                 index) - Returns the element at position index in the list, (e) E set(int 
2510:	                 index, E obj)  Replaces the element at position index with obj; returns the 
2511:	                 element formerly at position index E remove(int index)  Removes element from 
2512:	                 position index, moving elements at position index + 1 and higher to the left 
2513:	                 (subtracts 1 from their indices) and subtracts 1 from  size;  returns the 
2514:	                 element formerly at position index 
2515:	Add your own example(s) here...
2516:	7.3 - Traversing ArrayLists  ..............................................................
2517:	   7.3.1 - For ArrayList objects: (a) Traverse using a for or while loop, (b) Traverse 
2518:	              using an enhanced for loop
2519:	      7.3.1.1 - Iteration statements can be used to access all the elements in an 
2520:	                 ArrayList. This is called traversing the ArrayList 
2521:	      7.3.1.2 - Deleting elements during a traversal of an ArrayList requires using 
2522:	                 special techniques to avoid skipping elements 
2523:	      7.3.1.3 - Since the indices for an ArrayList start at 0 and end at the number 
2524:	                 of elements  1, accessing an index value outside of this range will result 
2525:	                 in an ArrayIndexOutOfBoundsException being thrown 
2526:	      7.3.1.4 - Changing the size of an ArrayList while traversing it using an enhanced 
2527:	                 for loop can result in a ConcurrentModificationException being thrown. Therefore, 
2528:	                 when using an enhanced for loop to traverse an ArrayList, you should not add 
2529:	                 or remove elements 
2530:	Add your own example(s) here...
2531:	7.4 - Developing Algorithms Using ArrayLists  .............................................
2532:	   7.4.1 - For algorithms in the context of a particular specification that requires 
2533:	              the use of ArrayList traversals: (a) Identify standard algorithms, (b) Modify 
2534:	              standard algorithms, (c) Develop an algorithm
2535:	      7.4.1.1 - There are standard ArrayList algorithms that utilize traversals 
2536:	                 to: (a) Insert elements, (b) Delete elements, (c) Apply the same standard 
2537:	                 algorithms that are used with 1D arrays 
2538:	      7.4.1.2 - Some algorithms require multiple String, array, or ArrayList objects 
2539:	                 to be traversed simultaneously
2540:	Add your own example(s) here...
2541:	7.5 - Searching  ..........................................................................
2542:	   7.5.1 - Apply sequential/linear search algorithms to search for specific information 
2543:	              in array or ArrayList objects
2544:	      7.5.1.1 - There are standard algorithms for searching 
2545:	      7.5.1.2 - Sequential/linear search algorithms check each element in order 
2546:	                 until the desired value is found or all elements in the array or ArrayList 
2547:	                 have been checked 
2548:	Add your own example(s) here...
2549:	7.6 - Sorting  ............................................................................
2550:	   7.6.1 - Apply selection sort and insertion sort algorithms to sort the elements 
2551:	              of array or ArrayList objects
2552:	      7.6.1.1 - Selection sort and insertion sort are iterative sorting algorithms 
2553:	                 that can be used to sort elements in an array or ArrayList 
2554:	   7.6.2 - Compute statement execution counts and informal run-time comparison of 
2555:	              sorting algorithms
2556:	      7.6.2.1 - Informal run-time comparisons of program code segments  can be made 
2557:	                 using statement execution counts 
2558:	Add your own example(s) here...
2559:	7.7 - Ethical Issues Around Data Collection  ..............................................
2560:	   7.7.1 - Explain the risks to privacy from collecting and storing personal data 
2561:	              on computer systems
2562:	      7.7.1.1 - When using the computer, personal privacy is at risk.  Programmers 
2563:	                 should attempt to safeguard personal privacy 
2564:	      7.7.1.2 - Computer use and the creation of programs have an impact on personal 
2565:	                 security. These impacts can be beneficial and/or harmful 
2566:	Add your own example(s) here...
2567:	Computer Science 42SAP - AP: Unit 10 (Recursion) content running simulated:................
2568:	Unit 10 - Recursion........................................................................
2569:	10.1 - Recursion  .........................................................................
2570:	   10.1.1 - Determine the result of executing recursive methods
2571:	      10.1.1.1 - A recursive method is a method that calls itself 
2572:	      10.1.1.2 - Recursive methods contain at least one base case, which halts the 
2573:	                 recursion, and at least one recursive call 
2574:	      10.1.1.3 - Each recursive call has its own set of local variables, including 
2575:	                 the formal parameters 
2576:	      10.1.1.4 - Parameter values capture the progress of a recursive process, much 
2577:	                 like loop control variable values capture the progress of a loop 
2578:	      10.1.1.5 - Any recursive solution can be replicated through the use of an 
2579:	                 iterative approach 
2580:	      10.1.1.6 - Recursion can be used to traverse String, array, and ArrayList 
2581:	                 objects 
2582:	Add your own example(s) here...
2583:	10.2 - Recursive Searching and Sorting  ...................................................
2584:	   10.2.1 - Apply recursive search algorithms to information in String, 1D array, 
2585:	              or ArrayList objects
2586:	      10.2.1.1 - Data must be in sorted order to use the binary search algorithm 
2587:	      10.2.1.2 - The binary search algorithm starts at the middle of a sorted array 
2588:	                 or ArrayList and eliminates half of the array or ArrayList in each iteration 
2589:	                 until the desired value is found or all elements have been eliminated 
2590:	      10.2.1.3 - Binary search can be more efficient than sequential/linear search 
2591:	      10.2.1.4 - The binary search algorithm can be written either iteratively or 
2592:	                 recursively 
2593:	   10.2.2 - Apply recursive algorithms to sort elements of array or ArrayList objects
2594:	      10.2.2.1 - Merge sort is a recursive sorting algorithm that can be used to 
2595:	                 sort elements in an array or ArrayList  
2596:	Add your own example(s) here...
2597:	Computer Science 42SAP - Practice Tests content running simulated:.........................
2598:	Computer Science 42SAP - AP Practice Test 1 content running simulated:.....................
2599:	// Question 1...
2600:	Consider the following code segment.
2601:	int a = 5;
2602:	int b = 2;
2603:	double c = 3.0;
2604:	System.out.println(5 + a / b * c - 1);
2605:	What is printed when the code segment is executed?
2606:	(A) 0.666666666666667
2607:	(B) 9.0
2608:	(C) 10.0
2609:	(D) 11.5
2610:	(E) 14.0
2611:	// Answer 1...
2612:	C
2613:	// Question 2...
2614:	Which of the following statements assigns a random
2615:	integer between 25 and 60, inclusive to rn?
2616:	(A) int rnA = (int)(Math.random() * 25) + 36;
2617:	(B) int rnB = (int)(Math.random() * 25) + 60;
2618:	(C) int rnC = (int)(Math.random() * 26) + 60;
2619:	(D) int rnD = (int)(Math.random() * 36) + 25;
2620:	(E) int rnE = (int)(Math.random() * 60) + 25;
2621:	// Answer 2...
2622:	A
2623:	D
2624:	// Question 3...
2625:	Which of the following best describes the value
2626:	of the Boolean expression shown below?
2627:	a && !(b || a)
2628:	(A) The value is always true
2629:	(B) The value is always false
2630:	(C) The value is true when a has the value 
    false, and is false otherwise
2631:	(D) The value is true when b has the value 
    false, and is false otherwise
2632:	(E) The value is true when either a or b has 
    the value true, and is false otherwise
2633:	// Answer 3...
2634:	B
2635:	// Question 4...
2636:	Consider the following code segment
2637:	int val = 48;
2638:	int div = 6;
2639:	while((val % 2 == 0) && div > 0) {
2640:	    if (val % div == 0) {
2641:	        System.out.print(val + " ");
2642:	    }
2643:	    val /= 2;
2644:	    div--;
2645:	}
2646:	What is printed when the code segment is executed?
2647:	(A) 48 12 6
2648:	(B) 48 12 6 3
2649:	(C) 48 12 6 3 1
2650:	(D) 48 24 12 6
2651:	(E) 48 24 12 6 3
2652:	// Answer 4...
2653:	A
2654:	// Question 5...
2655:	Which of the following code segments is equivalent to the code below
2656:	if (x >= 1) x = x * 3;
2657:	if (x > 3) x = 0;
2658:	(A) x = 0
2659:	(B) if (x > 1) x = 0;
2660:	(C) if (x > 3) x = 0;
2661:	(D) if (x >= 1) x = 0;
2662:	(E) none of the above
2663:	// Answer 5...
2664:	B
2665:	// Question 6...
2666:	When is the following Boolean expression true
2667:	(a and b are integers)?
2668:	(a < b) && !(b > a)
2669:	(A) Always true
2670:	(B) Never true
2671:	(C) a = b
2672:	(D) a < b
2673:	(E) a > b
2674:	// Answer 6...
2675:	B
2676:	// Question 7...
2677:	Consider the following code segment
2678:	int i = a random number such that 1 <= i <= n;
2679:	for (int a = 2; a <= i; a++)
2680:	    for (int b = 1; b < i; b++)
2681:	        System.out.println("*");
2682:	(A) 0
2683:	(B) 1
2684:	(C) 2
2685:	(D) n - 1
2686:	(E) n - 2
2687:	// Answer 7...
2688:	B
2689:	// Question 8...
2690:	Consider the following code segment
2691:	int p = 5;
2692:	int q = 2;
2693:	int sum = 0;
2694:	while (p <= 8) {
2695:	    sum += p % q;
2696:	    p++;
2697:	    q++;
2698:	}
2699:	(A) 1
2700:	(B) 0
2701:	(C) 13
2702:	(D) 7
2703:	(E) 4
2704:	// Answer 8...
2705:	D
2706:	// Question 9...
2707:	Consider the following code segment
2708:	for (int i = 0; i <= 3; i++) {
2709:	    for (int j = 1; j <= 5; j+=2) {
2710:	        System.out.println("*");
2711:	    }
2712:	}
2713:	(A) 3
2714:	(B) 6
2715:	(C) 9
2716:	(D) 12
2717:	(E) 15
2718:	// Answer 9...
2719:	D
2720:	// Question 10...
2721:	What are the values of a and b after the for loop
2722:	finishes?
2723:	int a = 10;
2724:	int b = 3;
2725:	int t = 0;
2726:	for (int i = 1; i < 4; i++) {
2727:	    t = a;
2728:	    a = i + b;
2729:	    b = t - i;
2730:	}
2731:	(A) a = 5 and b = -2
2732:	(B) a = 6 and b = 7
2733:	(C) a = 6 and b = 3
2734:	(D) a = 12 and b = 1
2735:	(E) a = 5 and b = 8
2736:	// Answer 10...
2737:	E
2738:	Computer Science 42SAP - AP Practice Test 2 content running simulated:.....................
2739:	// Question 1...
2740:	Consider the following class definition
2741:	public class Example
2742:	{
2743:	     private int x;
2744:	     // constructor not shown
2745:	}
2746:	Which of the following is a correct header for a
2747:	method that would return the value of the private
2748:	instance variable x so that it can be used in a
2749:	class other than Example?
2750:	(A) private int getX()
2751:	(B) private void getX()
2752:	(C) public int getX()
2753:	(D) public void getX()
2754:	(E) public void getX(int x)
2755:	// Answer 1...
2756:	C
2757:	// Question 2...
2758:	Consider the following class definitions
2759:	public class Thing1 {
2760:	     public void calc(int n) {
2761:	          n *= 3;
2762:	          System.out.print(n);
2763:	     }
2764:	}
2765:	public class Thing2 extends Thing1 {
2766:	     public void calc(int n) {
2767:	          n += 2;
2768:	          super.calc(n);
2769:	          System.out.print(n);
2770:	     }
2771:	}
2772:	The following code seqment appears in a class
2773:	other than Thing1 or Thing2
2774:	Thing1 t = new Thing2();
2775:	t.calc(2);
2776:	What is printed as a result of executing the
2777:	code segment?
2778:	(A) 4
2779:	(B) 6
2780:	(C) 68
2781:	(D) 124
2782:	(E) 1212
2783:	// Answer 2...
2784:	D
2785:	// Question 3...
2786:	Consider the following class definitions.
2787:	public class Student {
2788:	    public String getFood() {
2789:	        return "Pizza";
2790:	    }
2791:	    public String getInfo() {
2792:	        return "Studying";
2793:	    }
2794:	}
2795:	public class GradStudent extends Student {
2796:	    public String getFood() {
2797:	        return "Taco";
2798:	    }
2799:	    public String getInfo() {
2800:	        super.getInfo();
2801:	        return "Eating";
2802:	    }
2803:	}
2804:	What is printed when the following code is
2805:	executed?
2806:	Student s = new GradStudent();
2807:	System.out.println(s.getInfo());
2808:	(A) Pizza
2809:	(B) Taco
2810:	(C) Studying
2811:	(D) Eating
2812:	(E) Studying
2813:	    Eating
2814:	// Answer 3...
2815:	D
2816:	// Question 4...
2817:	Given the following class declarations:
2818:	public class Car {
2819:	    private String make;
2820:	    public Car(String theMake) {
2821:	        make = theMake;
2822:	    }
2823:	    public String getMake() {
2824:	        return make;
2825:	    }
2826:	}
2827:	public class ElectricCar extends Car {
2828:	    public ElectricCar() {
2829:	        super("Ford");
2830:	    }
2831:	    public ElectricCar(String theMake) {
2832:	        super(theMake);
2833:	    } 
2834:	}
2835:	Which of the following will cause a compile
2836:	time error?
2837:	(A) Car myCar = new Car();
2838:	(B) Car myCar1 = new ElectricCar();
2839:	(C) ElectricCar myCar2 = new ElectricCar("Ford");
2840:	(D) Car myCar3 = new Car("Ford");
2841:	(E) Car myCar4 = new ElectricCar("Ford");
2842:	// Answer 4...
2843:	A
2844:	// Question 5...
2845:	Given the following declarations.
2846:	public class Vehicle {
2847:	    public void test(Car x, SportsCar y) { }
2848:	}
2849:	public class Car extends Vehicle {
2850:	}
2851:	public class SportsCar extends Car {
2852:	}
2853:	Also consider the following code that appears
2854:	in a different class.
2855:	Vehicle v = new Vehicle();
2856:	Car c = new Car();
2857:	SportsCar sporty = new SportsCar();
2858:	Which of the following is a correct call to test ?
2859:	(A) v.test(sporty, v);
2860:	(B) sporty.test(c, c);
2861:	(C) v.test(sporty, c);
2862:	(D) sporty.test(sporty, v);
2863:	(E) c.test(sporty, sporty);
2864:	// Answer 5...
2865:	E
2866:	// Question 6...
2867:	Class C extends class B, which extends class A. 
2868:	Also, all of the three classes implement a public
2869:	method test(). How can a method in an object of
2870:	class C invoke the test() method defined in class
2871:	A (without creating a new instance of class A)?
2872:	(A) test();
2873:	(B) super.super.test();
2874:	(C) super.test();
2875:	(D) this.test();
2876:	(E) There is no way to call a method in a 
2877:	    grandparent class from a grandchild class
2878:	// Answer 6...
2879:	E
2880:	// Question 7...
2881:	Given the following class declarations. Assume
2882:	that Parent p = new Child(); appears in a client
2883:	program. What is the result of the call p.m1();
2884:	public class Parent {
2885:	    public void m1() {
2886:	        System.out.print("pm1");
2887:	        m2();
2888:	    }
2889:	    public void m2() {
2890:	        System.out.print("pm2");
2891:	    }
2892:	}
2893:	public class Child extends Parent {
2894:	    public void m1() {
2895:	        super.m1();
2896:	        System.out.print("cm1");
2897:	    }
2898:	    public void m2() {
2899:	        super.m2();
2900:	        System.out.print("cm2");
2901:	    }
2902:	}
2903:	(A) pm1pm2cm2cm1
2904:	(B) pm1pm2
2905:	(C) pm1pm2cm1cm2
2906:	(D) pm1cm1
2907:	(E) pm1
2908:	// Answer 7...
2909:	pm1pm2cm2cm1// Question 8...
2910:	Given the following class declarations.
2911:	public class Animal {
2912:	    public void eat() {
2913:	        System.out.println("AE");
2914:	    }
2915:	}
2916:	public class Bear extends Animal {
2917:	    public void growl() {
2918:	        System.out.println("BG");
2919:	    }
2920:	}
2921:	Assume the following declaration is in a 
2922:	different class.
2923:	Animal b = new Bear();
2924:	Which of the following will compile without error?
2925:	I.   b.eat();
2926:	II.  b.growl();
2927:	III. ((Bear)b).growl();
2928:	(A) I only
2929:	(B) II only
2930:	(C) III only
2931:	(D) I and III only
2932:	(E) I, II, and III
2933:	// Answer 8...
2934:	B
2935:	// Question 9...
2936:	Consider the following partial class definitions.
2937:	public class C1 {
2938:	    private int num;
2939:	    private String name;
2940:	    public C1(int theNum) {
2941:	        num = theNum
2942:	    } 
2943:	    public C1(String theName) {
2944:	        name = theName;
2945:	    }
2946:	}
2947:	public class C2 extends C1 {
2948:	    // methods not shown
2949:	}
2950:	Which of the following constructors are valid for
2951:	C2?
2952:	I. public C2() { }
2953:	II. public C2(int quan) { super(quan); }
2954:	III. public C2(String label) { super(label); }
2955:	(A) All three are valid
2956:	(B) II only
2957:	(C) III only
2958:	(D) II and III
2959:	(E) None are valid
2960:	// Answer 9...
2961:	D
2962:	// Question 10...
2963:	Given the following class definition. What are 
2964:	the values of x, y, and z just before method2
2965:	returns?
2966:	public class Class1 {
2967:	    public int method1(int a, int b) {
2968:	        int temp = a;
2969:	        a = b;
2970:	        b = temp;
2971:	        return b;
2972:	    }  
2973:	    public void method2() {
2974:	        int x = 3;
2975:	        int y = 5;
2976:	        int z = method1(x, y);
2977:	    }
2978:	}
2979:	(A) x=3,y=3,z=3
2980:	(B) x=3,y=5,z=3
2981:	(C) x=5,y=3,z=5
2982:	(D) x=5,y=3,z=3
2983:	(E) x=3,y=5,z=5
2984:	// Answer 10...
2985:	B
2986:	Computer Science 42SAP - AP Practice Test 3 content running simulated:.....................
2987:	// Section 1...
2988:	For the next two Free response questions, 
2989:	refer to the description below...
2990:	A travel agency maintains a list of information 
2991:	about airline flights. Flight information 
2992:	includes a departure time and an arrival time.
2993:	You may assume that the two times occur on the 
2994:	same day. These times are represented by 
2995:	objects of the Time class. The declaration for
2996:	the Time class is shown below. It includes a 
2997:	method which returns the difference (in minutes)
2998:	between the current Time object and another Time
2999:	object. 
3000:	public class Time {
3001:	     /** 
3002:	      * @return difference, in minutes, between this
3003:	      * time and other; difference is negative
3004:	      * if other is earlier than this time
3005:	      */
3006:	     public int minutesUntil(Time other) {
3007:	          /* implementation not shown */
3008:	     }
3009:	     // There may be instance variables, constructors,
3010:	     // and methods that are not shown.
3011:	}
3012:	For example, assume that t1 and t2 are Time 
3013:	objects where t1 represents 1:00 p.m. and t2 
3014:	represents 2:15 p.m. The call t1.minutesUntil(t2) 
3015:	will return 75 and the call t2.minutesUntil(t1) 
3016:	will return -75. The declaration for the Flight class 
3017:	is shown below. It has methods to access the 
3018:	departure time and the arrival time of a flight. 
3019:	You may assume that the departure time of a 
3020:	flight is earlier than its arrival time.
3021:	public class Flight {
3022:	      /** @return time at which the flight departs */
3023:	      public Time getDepartureTime() {
3024:	           /* implementation not shown */ 
3025:	      }
3026:	      /** @return time at which the flight arrives */
3027:	      public Time getArrivalTime() {
3028:	           /* implementation not shown */ 
3029:	      }
3030:	      // There may be instance variables, constructors, 
3031:	      // and methods that are not shown.
3032:	}
3033:	A trip consists of a sequence of flights and is 
3034:	represented by the Trip class. The Trip class 
3035:	contains a List of Flight objects that are stored 
3036:	in chronological order. You may assume that for 
3037:	each flight after the first flight in the list, 
3038:	the departure time of the flight is later than 
3039:	the arrival time of the preceding flight in the 
3040:	list. A partial declaration of the Trip class is 
3041:	shown below. You will write two methods for the 
3042:	Trip class.
3043:	public class Trip {
3044:	     /** 
3045:	       * The list of flights (if any) that make up 
3046:	       * this trip, stored in chronological order
3047:	       */
3048:	     private List<Flight> flights;
3049:	     /** 
3050:	       * @return the number of minutes from the 
3051:	       * departure of the first flight to the arrival 
3052:	       * of the last flight if there are one or more 
3053:	       * flights in the trip; 0, if there are no 
3054:	       * flights in the trip
3055:	       */
3056:	     public int getDuration() {
3057:	          /* to be implemented in part (a) */ 
3058:	     }
3059:	     /** 
3060:	       * Precondition: the departure time for each 
3061:	       * flight is later than the arrival time of its 
3062:	       * preceding flight
3063:	       * @return the smallest number of minutes 
3064:	       * between the arrival of a flight and the 
3065:	       * departure of the flight immediately after it, 
3066:	       * if there are two or more flights in the 
3067:	       * trip; -1, if there are fewer than two flights 
3068:	       * in the trip
3069:	       */
3070:	     public int getShortestLayover() {
3071:	          /* to be implemented in part (b) */
3072:	     }
3073:	       // There may be instance variables, constructors,
3074:	       // and methods that are not shown
3075:	}
3076:	// Question 1...
3077:	Complete method getDuration below.  
3078:	// An answer could be...
3079:	public int getDuration() {
3080:	    int totalDuration = 0;
3081:	    for (Flight flight : flights) {
3082:	        Time departure = flight.getDepartureTime();
3083:	        Time arrival   = flight.getArrivalTime();
3084:	        int  duration  = departure.minutesUntil(arrival);
3085:	        totalDuration  = totalDuration + duration;
3086:	    }
3087:	    return totalDuration;
3088:	}
3089:	// Question 2...
3090:	Write the Trip method getShortestLayover. A 
3091:	layover is the number of minutes from the arrival 
3092:	of one flight in a trip to the departure of the 
3093:	flight immediately after it. If there are two or 
3094:	more flights in the trip, the method should return 
3095:	the shortest layover of the trip; otherwise, it 
3096:	should return -1. For example, assume that the 
3097:	instance variable flights of a Trip object vacation 
3098:	contains the following flight information.
3099:	          Departure   Arrival   Layover
3100:	            Time      Time     (minutes)
3101:	         +---------+----------+
3102:	Flight 0 | 11:30am |  12:15pm |
3103:	         +---------+----------+ }  60
3104:	Flight 1 |  1:15pm |   3:45pm |
3105:	         +---------+----------+ }  15
3106:	Flight 2 |  4:00pm |   6:45pm |
3107:	         +---------+----------+ }  210
3108:	Flight 3 | 10:15pm |  11:00pm |
3109:	         +---------+----------+
3110:	The call vacation.getShortestLayover() should 
3111:	return 15. Complete method getShortestLayover() 
3112:	below.
3113:	public int getShortestLayover()
3114:	// An answer could be...
3115:	public int getShortestLayover() {
3116:	    if (flights.isEmpty()) return -1;
3117:	    int shortestLayover = Integer.MAX_VALUE;
3118:	    int i = 0;
3119:	    while (i < flights.size()) {
3120:	        Flight currentFlight = flights.get(i);
3121:	        i++;
3122:	        Flight nextFlight    = flights.get(i);
3123:	        Time arrival         = currentFlight.getArrivalTime();
3124:	        Time departure       = nextFlight.getDepartureTime();
3125:	        int layover = Math.abs(arrival.minutesUntil(departure));
3126:	        if (layover < shortestLayover) {
3127:	            shortestLayover = layover;
3128:	        }
3129:	        i++;
3130:	    }
3131:	    return shortestLayover;
3132:	}
3133:	// Section 1...
3134:	For the next three Free response questions, refer 
3135:	to the description below...
3136:	Consider the hierarchy of classes shown in the 
3137:	following diagram
3138:	         +----------+ 
3139:	         |    Pet   |
3140:	         +----------+
3141:	            /    \
3142:	 +----------+    +----------+
3143:	 |    Cat   |    |    Dog   |
3144:	 +----------+    +----------+
3145:	                       \
3146:	                       +----------+
3147:	                       | Loud Dog |
3148:	                       +----------+
3149:	Note that a Cat 'is-a' Pet, a Dog 'is-a' Pet, and 
3150:	a LoudDog 'is-a' Dog. The class Pet is specified 
3151:	as an abstract class as shown in the following 
3152:	declaration. Each Pet has a name that is 
3153:	specified when it is constructed.
3154:	public abstract class Pet {
3155:	    private String name;
3156:	    public Pet(String petName) {
3157:	        name = petName;
3158:	    }
3159:	    public String getName() {
3160:	        return name;
3161:	    }
3162:	    public abstract String speak();
3163:	}
3164:	The subclass Dog has the partial class 
3165:	declaration shown below.
3166:	public class Dog extends Pet {
3167:	    public Dog(String petName) {
3168:	        /* implementation not shown */
3169:	    }
3170:	    public String speak() {
3171:	        /* implementation not shown */
3172:	    }
3173:	}
3174:	// Question 3...
3175:	Given the class hierarchy shown above, write a 
3176:	complete class declaration for the class Cat, 
3177:	including implementations of its constructor 
3178:	and method(s). The Cat method speak returns 
3179:	'meow' when it is invoked.
3180:	// An answer could be...
3181:	public class Cat extends Pet {
3182:	    public Cat(String petName) {
3183:	        super(petName);
3184:	    }
3185:	    public String speak() {
3186:	        return "meow";
3187:	    }
3188:	}
3189:	// Question 4...
3190:	Assume that class Dog has been declared as shown 
3191:	at the beginning of the question. If the String 
3192:	dog-sound is returned by the Dog method speak, 
3193:	then the LoudDog method method speak returns a 
3194:	String containing dog-sound repeated two times. 
3195:	Given the class hierarchy shown previously, 
3196:	write a complete class declaration for the class 
3197:	LoudDog including implementations of its 
3198:	constructor and method(s).
3199:	// An answer could be...
3200:	public class LoudDog extends Dog {
3201:	    public LoudDog(String petName) {
3202:	        super(petName);
3203:	    }
3204:	    public String speak() {
3205:	        return super.speak() + super.speak();
3206:	    }
3207:	}
3208:	// Question 5...
3209:	Consider the following partial declaration of 
3210:	class Kennel
3211:	public class Kennel {
3212:	    private ArrayList<Pet> petList;
3213:	     /**
3214:	      * For every Pet in the kennel, prints the name 
3215:	      * followed by the result of a call to its speak 
3216:	      * method, one line per Pet
3217:	      */
3218:	     public void allSpeak() {
3219:	        /* to be implemented */
3220:	     }
3221:	     // There may be instance variables, constructors, 
3222:	     // and methods that are not shown
3223:	}
3224:	Write the Kennel method allSpeak For each Pet in 
3225:	the kennel, allSpeak prints a line with the name 
3226:	of the Pet followed by the result of a call to 
3227:	its speak method. In writing allSpeak you may use 
3228:	any of the methods defined for any of the classes 
3229:	specified for this problem. Assume that these 
3230:	methods work as specified, regardless of what 
3231:	you wrote in previous questions. Complete method
3232:	allSpeak below
3233:	public void allSpeak()
3234:	// An answer could be...
3235:	public void allSpeak() {
3236:	    for (Pet pet : petList) {
3237:	        System.out.println(pet.getName() + pet.speak());
3238:	    }
3239:	}
3240:	Computer Science 42SAP - AP Practice Test 4 content running simulated:.....................
3241:	// Question 1...
3242:	(A) 
3243:	(B) 
3244:	(C) 
3245:	(D) 
3246:	(E) 
3247:	// Answer 1...
3248:	// Question 2...
3249:	(A) 
3250:	(B) 
3251:	(C) 
3252:	(D) 
3253:	(E) 
3254:	// Answer 2...
3255:	// Question 3...
3256:	(A) 
3257:	(B) 
3258:	(C) 
3259:	(D) 
3260:	(E) 
3261:	// Answer 3...
3262:	// Question 4...
3263:	(A) 
3264:	(B) 
3265:	(C) 
3266:	(D) 
3267:	(E) 
3268:	// Answer 4...
3269:	// Question 5...
3270:	(A) 
3271:	(B) 
3272:	(C) 
3273:	(D) 
3274:	(E) 
3275:	// Answer 5...
3276:	// Question 6...
3277:	(A) 
3278:	(B) 
3279:	(C) 
3280:	(D) 
3281:	(E) 
3282:	// Answer 6...
3283:	// Question 7...
3284:	(A) 
3285:	(B) 
3286:	(C) 
3287:	(D) 
3288:	(E) 
3289:	// Answer 7...
3290:	// Question 8...
3291:	(A) 
3292:	(B) 
3293:	(C) 
3294:	(D) 
3295:	(E) 
3296:	// Answer 8...
3297:	// Question 9...
3298:	(A) 
3299:	(B) 
3300:	(C) 
3301:	(D) 
3302:	(E) 
3303:	// Answer 9...
3304:	// Question 10...
3305:	(A) 
3306:	(B) 
3307:	(C) 
3308:	(D) 
3309:	(E) 
3310:	// Answer 10...
3311:	Computer Science 42SAP - Student Driven 'fun' Days content running simulated:..............
3312:	Computer Science 42SAP - More Post Secondary content running simulated:....................
3313:	Computer Science 42SAP - Permanent Storage Post Secondary content running simulated:.......
3314:	// Learn about 'error traps'
3315:	Divide by zero -> java.lang.ArithmeticException: / by zero
3316:	// Create sample data to use
3317:	// Save ONE piece of data to that permanent file
3318:	// Now involve the user to get a file name
3319:	~~~ SIMULATED {File Chooser null  simulated message} DIALOG: 
3320:	File already exists!
3321:	// Open file with one line (no user involvment)
3322:	line read was Defenestration
3323:	// Open file with multiple lines (user picks file)
3324:	~~~ SIMULATED {File Chooser null  simulated message} DIALOG: 
3325:	This line read was  sr utility.collections.LinkedList- I 	NOT_FOUNDI lengthI longestWordL headt Lutility/collections/Node;L tailq ~ xp   d   sr utility.collections.Node52 ... (line shortened) ...
3326:	This line read was detailMessaget Ljava/lang/String;[ 
3327:	This line read was stackTracet [Ljava/lang/StackTraceElement;L suppressedExceptionst Ljava/util/List;xpq ~ 	t 2testing.prerequisite.cs40s.advancedclasses.Athleteur [Ljava.lang.StackTraceElement;F ... (line shortened) ...
3328:	This line read was lineNumberL classLoaderNameq ~ L declaringClassq ~ L fileNameq ~ L 
3329:	This line read was methodNameq ~ L 
3330:	This line read was moduleNameq ~ L 
3331:	This line read was moduleVersionq ~ xp  pt java.io.ObjectOutputStreamt ObjectOutputStream.javat writeObject0t 	java.baset 22.0.2sq ~ 
3332:	This line read was   1pq ~ q ~ t defaultWriteFieldsq ~ q ~ sq ~ 
3333:	This line read was   pq ~ q ~ t writeSerialDataq ~ q ~ sq ~ 
3334:	This line read was   pq ~ q ~ t writeOrdinaryObjectq ~ q ~ sq ~ 
3335:	This line read was   pq ~ q ~ q ~ q ~ q ~ sq ~ 
3336:	This line read was   1pq ~ q ~ q ~ q ~ q ~ sq ~ 
3337:	This line read was   pq ~ q ~ q ~ q ~ q ~ sq ~ 
3338:	This line read was   pq ~ q ~ q ~ q ~ q ~ sq ~ 
3339:	This line read was   pq ~ q ~ q ~ q ~ q ~ sq ~ 
3340:	This line read was   fpq ~ q ~ t writeObjectq ~ q ~ sq ~ 
3341:	This line read was   t appt utility.io.FileHandlert FileHandler.javat 
3342:	This line read was saveObjectppsq ~ 
3343:	This line read was   q ~ "q ~ #q ~ $q ~ %ppsq ~ 
3344:	This line read was   q ~ "t *testing.postsecondary.PermanentStorageTestt PermanentStorageTest.javat <init>ppsq ~ 
3345:	This line read was    q ~ "t .testing.postsecondary.MorePostSecondaryContentt MorePostSecondaryContent.javaq ~ *ppsq ~ 
3346:	This line read was    qq ~ "t testing.Testert Tester.javat 
3347:	This line read was postSecondaryppsq ~ 
3348:	This line read was    Bq ~ "q ~ /q ~ 0q ~ *ppsq ~ 
3349:	This line read was    2q ~ "q ~ /q ~ 0q ~ *ppsq ~ 
3350:	This line read was    q ~ "t mainpackage.MainClasst MainClass.javat mainppsr java.util.Collections$EmptyListz<  xpx
3351:	// Class to save/open one line (no user)
3352:	Before: Defenestration
3353:	After : Defenestration
3354:	// Class to save/open multiple lines (with user)
3355:	~~~ SIMULATED {File Chooser null  simulated message} DIALOG: 
3356:	~~~ SIMULATED {File Chooser null  simulated message} DIALOG: 
3357:	Before: [I look at my watch for the hour,But I find it has run out of power,I yell out Oh No!,I have got to go!,For I fear that the milk has gone sour]
3358:	After:  [I look at my watch for the hour,But I find it has run out of power,I yell out Oh No!,I have got to go!,For I fear that the milk has gone sour]
3359:	// Now save/open on a complex data type
3360:	File open: java.io.NotSerializableException: testing.prerequisite.cs40s.advancedclasses.Athlete
3361:	File open: java.io.WriteAbortedException: writing aborted; java.io.NotSerializableException: testing.prerequisite.cs40s.advancedclasses.Athlete
3362:	Before: Athlete: Husky: HighSchool: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Athlete@22a637e7
3363:	File open: java.io.NotSerializableException: testing.prerequisite.cs40s.advancedclasses.Athlete
3364:	File open: java.io.WriteAbortedException: writing aborted; java.io.NotSerializableException: testing.prerequisite.cs40s.advancedclasses.Athlete
3365:	Before: [Athlete: Husky: HighSchool: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Athlete@6fe7aac8,Athlete: Husky: HighSchool: Student Over-riding from ... (line shortened) ...
3366:	After:  null
3367:	Computer Science 42SAP - Stacks and Queues Post Secondary content running simulated:.......
3368:	// Create objects for testing...
3369:	// Create and Test a stack object...
3370:	// Test toString, size, isEmpty, and push methods...
3371:	Empty = true	Size = 0	Empty Stack
3372:	// Loop through adding random values
3373:	Empty = false	Size = 1	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@1ab3a8c8] <- bottom
3374:	Empty = false	Size = 2	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@43195e57,testing.prerequisite.cs40s.advancedclasses.Box@1ab3a8c8] <- bottom
3375:	Empty = false	Size = 3	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@333291e3,testing.prerequisite.cs40s.advancedclasses.Box@43195e57,testing.prerequisite.cs40s.advancedclasses.Box@1ab3 ... (line shortened) ...
3376:	Empty = false	Size = 4	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@479d31f3,testing.prerequisite.cs40s.advancedclasses.Box@333291e3,testing.prerequisite.cs40s.advancedclasses.Box@4319 ... (line shortened) ...
3377:	Empty = false	Size = 5	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@40ef3420,testing.prerequisite.cs40s.advancedclasses.Box@479d31f3,testing.prerequisite.cs40s.advancedclasses.Box@3332 ... (line shortened) ...
3378:	Empty = false	Size = 6	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@498d318c,testing.prerequisite.cs40s.advancedclasses.Box@40ef3420,testing.prerequisite.cs40s.advancedclasses.Box@479d ... (line shortened) ...
3379:	Empty = false	Size = 7	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@6e171cd7,testing.prerequisite.cs40s.advancedclasses.Box@498d318c,testing.prerequisite.cs40s.advancedclasses.Box@40ef ... (line shortened) ...
3380:	Empty = false	Size = 8	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@402bba4f,testing.prerequisite.cs40s.advancedclasses.Box@6e171cd7,testing.prerequisite.cs40s.advancedclasses.Box@498d ... (line shortened) ...
3381:	Empty = false	Size = 9	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@795cd85e,testing.prerequisite.cs40s.advancedclasses.Box@402bba4f,testing.prerequisite.cs40s.advancedclasses.Box@6e17 ... (line shortened) ...
3382:	Empty = false	Size = 10	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@59fd97a8,testing.prerequisite.cs40s.advancedclasses.Box@795cd85e,testing.prerequisite.cs40s.advancedclasses.Box@402 ... (line shortened) ...
3383:	// Test clone method...
3384:	Clone stack: Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@59fd97a8,testing.prerequisite.cs40s.advancedclasses.Box@795cd85e,testing.prerequisite.cs40s.advancedclasses.Box@402bba4f,testi ... (line shortened) ...
3385:	// Test equals method...
3386:	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@59fd97a8,testing.prerequisite.cs40s.advancedclasses.Box@795cd85e,testing.prerequisite.cs40s.advancedclasses.Box@402bba4f,testing.prerequisi ... (line shortened) ...
3387:	// Now change the copy
3388:	// Now check again
3389:	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@59fd97a8,testing.prerequisite.cs40s.advancedclasses.Box@795cd85e,testing.prerequisite.cs40s.advancedclasses.Box@402bba4f,testing.prerequisi ... (line shortened) ...
3390:	// Re-clone the stack, and output
3391:	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@59fd97a8,testing.prerequisite.cs40s.advancedclasses.Box@795cd85e,testing.prerequisite.cs40s.advancedclasses.Box@402bba4f,testing.prerequisi ... (line shortened) ...
3392:	// Text the pop method...
3393:	Clone stack:	Empty = false	Size = 10	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@59fd97a8,testing.prerequisite.cs40s.advancedclasses.Box@795cd85e,testing.prerequisite.cs40s.advancedcl ... (line shortened) ...
3394:	// Loop through removing values
3395:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@59fd97a8	Empty = false	Size = 9	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@795cd85e,testing.prerequisite.cs40s.advancedclasse ... (line shortened) ...
3396:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@795cd85e	Empty = false	Size = 8	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@402bba4f,testing.prerequisite.cs40s.advancedclasse ... (line shortened) ...
3397:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@402bba4f	Empty = false	Size = 7	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@6e171cd7,testing.prerequisite.cs40s.advancedclasse ... (line shortened) ...
3398:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@6e171cd7	Empty = false	Size = 6	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@498d318c,testing.prerequisite.cs40s.advancedclasse ... (line shortened) ...
3399:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@498d318c	Empty = false	Size = 5	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@40ef3420,testing.prerequisite.cs40s.advancedclasse ... (line shortened) ...
3400:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@40ef3420	Empty = false	Size = 4	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@479d31f3,testing.prerequisite.cs40s.advancedclasse ... (line shortened) ...
3401:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@479d31f3	Empty = false	Size = 3	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@333291e3,testing.prerequisite.cs40s.advancedclasse ... (line shortened) ...
3402:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@333291e3	Empty = false	Size = 2	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@43195e57,testing.prerequisite.cs40s.advancedclasse ... (line shortened) ...
3403:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@43195e57	Empty = false	Size = 1	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@1ab3a8c8] <- bottom
3404:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@1ab3a8c8	Empty = true	Size = 0	Empty Stack
3405:	Popped -> null	Empty = true	Size = 0	Empty Stack
3406:	// Test peek (top is wrapper no testing needed)...
3407:	Clone Top = null
3408:	Stack Top = testing.prerequisite.cs40s.advancedclasses.Box@59fd97a8
3409:	// Test to array and to linked list...
3410:	[testing.prerequisite.cs40s.advancedclasses.Box@59fd97a8,testing.prerequisite.cs40s.advancedclasses.Box@795cd85e,testing.prerequisite.cs40s.advancedclasses.Box@402bba4f,testing.prerequisite.cs40s.adva ... (line shortened) ...
3411:	Array   	[testing.prerequisite.cs40s.advancedclasses.Box@59fd97a8,testing.prerequisite.cs40s.advancedclasses.Box@795cd85e,testing.prerequisite.cs40s.advancedclasses.Box@402bba4f,testing.prerequisite.c ... (line shortened) ...
3412:	// Test our constructors...
3413:	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@59fd97a8,testing.prerequisite.cs40s.advancedclasses.Box@795cd85e,testing.prerequisite.cs40s.advancedclasses.Box@402bba4f,testing.prerequisi ... (line shortened) ...
3414:	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@59fd97a8,testing.prerequisite.cs40s.advancedclasses.Box@795cd85e,testing.prerequisite.cs40s.advancedclasses.Box@402bba4f,testing.prerequisi ... (line shortened) ...
3415:	// Test the Queue object...
3416:	// Test toString,size,isEmpty, and enqueue methods...
3417:	Empty = true	Size = 0	Empty Queue
3418:	// Loop through adding random values
3419:	Empty = false	Size = 1	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@dbf57b3] <- front
3420:	Empty = false	Size = 2	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@384ad17b,testing.prerequisite.cs40s.advancedclasses.Box@dbf57b3] <- front
3421:	Empty = false	Size = 3	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@61862a7f,testing.prerequisite.cs40s.advancedclasses.Box@384ad17b,testing.prerequisite.cs40s.advancedclasses.Box@dbf ... (line shortened) ...
3422:	Empty = false	Size = 4	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@441772e,testing.prerequisite.cs40s.advancedclasses.Box@61862a7f,testing.prerequisite.cs40s.advancedclasses.Box@384a ... (line shortened) ...
3423:	Empty = false	Size = 5	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@7334aada,testing.prerequisite.cs40s.advancedclasses.Box@441772e,testing.prerequisite.cs40s.advancedclasses.Box@6186 ... (line shortened) ...
3424:	Empty = false	Size = 6	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@1d9b7cce,testing.prerequisite.cs40s.advancedclasses.Box@7334aada,testing.prerequisite.cs40s.advancedclasses.Box@441 ... (line shortened) ...
3425:	Empty = false	Size = 7	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@4d9e68d0,testing.prerequisite.cs40s.advancedclasses.Box@1d9b7cce,testing.prerequisite.cs40s.advancedclasses.Box@733 ... (line shortened) ...
3426:	Empty = false	Size = 8	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@42e99e4a,testing.prerequisite.cs40s.advancedclasses.Box@4d9e68d0,testing.prerequisite.cs40s.advancedclasses.Box@1d9 ... (line shortened) ...
3427:	Empty = false	Size = 9	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@14dd9eb7,testing.prerequisite.cs40s.advancedclasses.Box@42e99e4a,testing.prerequisite.cs40s.advancedclasses.Box@4d9 ... (line shortened) ...
3428:	Empty = false	Size = 10	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedclasses.Box@14dd9eb7,testing.prerequisite.cs40s.advancedclasses.Box@42 ... (line shortened) ...
3429:	// Test clone method...
3430:	Clone Queue 			Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedclasses.Box@14dd9eb7,testing.prerequisite.cs40s.advancedclasses.Box@42e99e4a,te ... (line shortened) ...
3431:	// Test equals method...
3432:	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedclasses.Box@14dd9eb7,testing.prerequisite.cs40s.advancedclasses.Box@42e99e4a,testing.prerequis ... (line shortened) ...
3433:	// Now change the duplicate
3434:	// Now check again
3435:	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedclasses.Box@14dd9eb7,testing.prerequisite.cs40s.advancedclasses.Box@42e99e4a,testing.prerequis ... (line shortened) ...
3436:	// Re-clone the queue, and output
3437:	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedclasses.Box@14dd9eb7,testing.prerequisite.cs40s.advancedclasses.Box@42e99e4a,testing.prerequis ... (line shortened) ...
3438:	// Test the dequeue method...
3439:	Clone queue:	Empty = false	Size = 10	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedclasses.Box@14dd9eb7,testing.prerequisite.cs40s.advancedc ... (line shortened) ...
3440:	// Loop through removing values
3441:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@dbf57b3	Empty = false	Size = 9	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedclas ... (line shortened) ...
3442:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@384ad17b	Empty = false	Size = 8	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedcla ... (line shortened) ...
3443:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@61862a7f	Empty = false	Size = 7	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedcla ... (line shortened) ...
3444:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@441772e	Empty = false	Size = 6	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedclas ... (line shortened) ...
3445:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@7334aada	Empty = false	Size = 5	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedcla ... (line shortened) ...
3446:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@1d9b7cce	Empty = false	Size = 4	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedcla ... (line shortened) ...
3447:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@4d9e68d0	Empty = false	Size = 3	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedcla ... (line shortened) ...
3448:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@42e99e4a	Empty = false	Size = 2	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedcla ... (line shortened) ...
3449:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@14dd9eb7	Empty = false	Size = 1	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee] <- front
3450:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee	Empty = true	Size = 0	Empty Queue
3451:	Dequeued -> null	Empty = true	Size = 0	Empty Queue
3452:	// Test front and back...
3453:	Clone Front = null
3454:	Queue Front = testing.prerequisite.cs40s.advancedclasses.Box@dbf57b3
3455:	Clone Back  = null
3456:	Queue Back  = testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee
3457:	// Test to array and to linked list...
3458:	[testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedclasses.Box@14dd9eb7,testing.prerequisite.cs40s.advancedclasses.Box@42e99e4a,testing.prerequisite.cs40s.adva ... (line shortened) ...
3459:	Array   	[testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedclasses.Box@14dd9eb7,testing.prerequisite.cs40s.advancedclasses.Box@42e99e4a,testing.prerequisite.c ... (line shortened) ...
3460:	// Test our constructors...
3461:	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedclasses.Box@14dd9eb7,testing.prerequisite.cs40s.advancedclasses.Box@42e99e4a,testing.prerequis ... (line shortened) ...
3462:	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedclasses.Box@14dd9eb7,testing.prerequisite.cs40s.advancedclasses.Box@42e99e4a,testing.prerequis ... (line shortened) ...
3463:	// Constructors from stack to queue (and back)...
3464:	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedclasses.Box@14dd9eb7,testing.prerequisite.cs40s.advancedclasses.Box@42e99e4a,testing.prerequis ... (line shortened) ...
3465:	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@52e6fdee,testing.prerequisite.cs40s.advancedclasses.Box@14dd9eb7,testing.prerequisite.cs40s.advancedclasses.Box@42e99e4a,testing.prerequisi ... (line shortened) ...
3466:	Computer Science 42SAP - Searching and Sorting Post Secondary content running simulated:...
3467:	// Search: linear search and binary search
3468:	// Sort: bubble sort and the selection sort
3469:	// Create some constants (edges) for the data
3470:	// Create some random data to search through and sort
3471:	// Including edge cases to test
3472:	// Create data to store the results...
3473:	// The simpliest of searches
3474:	Array [100,11,95,63,24,94,80,85,98,91,67,79,83,23,74,19,24,21,15,0,25,23,43,23,44,45,34,70,79,28,13,82,92,93,90,83,96,15,8,52,27,74,38,49,65,69,71,6,35,11,30,100,15,1,66,82,78,9,90,37,64,45,62,51,62,6 ... (line shortened) ...
3475:	// Now the linear search on all test data
3476:	Array [100,11,95,63,24,94,80,85,98,91,67,79,83,23,74,19,24,21,15,0,25,23,43,23,44,45,34,70,79,28,13,82,92,93,90,83,96,15,8,52,27,74,38,49,65,69,71,6,35,11,30,100,15,1,66,82,78,9,90,37,64,45,62,51,62,6 ... (line shortened) ...
3477:	Array [100,11,95,63,24,94,80,85,98,91,67,79,83,23,74,19,24,21,15,0,25,23,43,23,44,45,34,70,79,28,13,82,92,93,90,83,96,15,8,52,27,74,38,49,65,69,71,6,35,11,30,100,15,1,66,82,78,9,90,37,64,45,62,51,62,6 ... (line shortened) ...
3478:	Array [100,11,95,63,24,94,80,85,98,91,67,79,83,23,74,19,24,21,15,0,25,23,43,23,44,45,34,70,79,28,13,82,92,93,90,83,96,15,8,52,27,74,38,49,65,69,71,6,35,11,30,100,15,1,66,82,78,9,90,37,64,45,62,51,62,6 ... (line shortened) ...
3479:	Array [100,11,95,63,24,94,80,85,98,91,67,79,83,23,74,19,24,21,15,0,25,23,43,23,44,45,34,70,79,28,13,82,92,93,90,83,96,15,8,52,27,74,38,49,65,69,71,6,35,11,30,100,15,1,66,82,78,9,90,37,64,45,62,51,62,6 ... (line shortened) ...
3480:	Array [100,11,95,63,24,94,80,85,98,91,67,79,83,23,74,19,24,21,15,0,25,23,43,23,44,45,34,70,79,28,13,82,92,93,90,83,96,15,8,52,27,74,38,49,65,69,71,6,35,11,30,100,15,1,66,82,78,9,90,37,64,45,62,51,62,6 ... (line shortened) ...
3481:	// Simple sort...
3482:	Sorted Array: 	[0,0,1,6,6,8,9,10,11,11,11,13,15,15,15,17,19,21,23,23,23,24,24,24,24,25,25,26,26,27,28,28,29,30,31,31,32,33,34,35,37,38,43,44,45,45,46,48,49,49,51,52,55,61,61,62,62,63,64,65,65,66,66,67 ... (line shortened) ...
3483:	// We will re-scramble array for further testing
3484:	Sorted Array: 	[20,100,67,63,22,85,24,50,71,46,6,47,27,33,39,60,58,84,7,71,87,23,48,86,47,98,89,0,62,2,87,33,95,67,44,4,88,0,36,51,5,5,96,48,70,1,91,7,82,25,92,85,31,19,2,70,58,28,12,92,100,96,73,0,57 ... (line shortened) ...
3485:	// Now bubble sort (from bubbles rising from water)
3486:	Original Array 	[20,100,67,63,22,85,24,50,71,46,6,47,27,33,39,60,58,84,7,71,87,23,48,86,47,98,89,0,62,2,87,33,95,67,44,4,88,0,36,51,5,5,96,48,70,1,91,7,82,25,92,85,31,19,2,70,58,28,12,92,100,96,73,0,5 ... (line shortened) ...
3487:	// Now selection sort (from selecting the smallest)
3488:	Original Array 	[20,100,67,63,22,85,24,50,71,46,6,47,27,33,39,60,58,84,7,71,87,23,48,86,47,98,89,0,62,2,87,33,95,67,44,4,88,0,36,51,5,5,96,48,70,1,91,7,82,25,92,85,31,19,2,70,58,28,12,92,100,96,73,0,5 ... (line shortened) ...
3489:	// Now binary search (named after two or dividing)
3490:	// NOTE: binary search can only happen on sorted list
3491:	// Redo some of the test data...
3492:	Array [0,0,0,1,1,2,2,2,2,4,5,5,6,7,7,11,12,13,16,17,18,19,20,22,23,24,24,25,25,26,27,28,31,33,33,36,37,39,40,42,42,44,45,46,47,47,47,48,48,50,51,57,58,58,60,60,61,62,63,64,65,65,65,66,67,67,67,70,70,7 ... (line shortened) ...
3493:	Array [0,0,0,1,1,2,2,2,2,4,5,5,6,7,7,11,12,13,16,17,18,19,20,22,23,24,24,25,25,26,27,28,31,33,33,36,37,39,40,42,42,44,45,46,47,47,47,48,48,50,51,57,58,58,60,60,61,62,63,64,65,65,65,66,67,67,67,70,70,7 ... (line shortened) ...
3494:	Array [0,0,0,1,1,2,2,2,2,4,5,5,6,7,7,11,12,13,16,17,18,19,20,22,23,24,24,25,25,26,27,28,31,33,33,36,37,39,40,42,42,44,45,46,47,47,47,48,48,50,51,57,58,58,60,60,61,62,63,64,65,65,65,66,67,67,67,70,70,7 ... (line shortened) ...
3495:	Array [0,0,0,1,1,2,2,2,2,4,5,5,6,7,7,11,12,13,16,17,18,19,20,22,23,24,24,25,25,26,27,28,31,33,33,36,37,39,40,42,42,44,45,46,47,47,47,48,48,50,51,57,58,58,60,60,61,62,63,64,65,65,65,66,67,67,67,70,70,7 ... (line shortened) ...
3496:	Array [0,0,0,1,1,2,2,2,2,4,5,5,6,7,7,11,12,13,16,17,18,19,20,22,23,24,24,25,25,26,27,28,31,33,33,36,37,39,40,42,42,44,45,46,47,47,47,48,48,50,51,57,58,58,60,60,61,62,63,64,65,65,65,66,67,67,67,70,70,7 ... (line shortened) ...
3497:	// Use class for searching and sorting
3498:	// Create random linked list data
3499:	// Create random array data
3500:	// Place all test cases into another linked list
3501:	// Execute the linear search on all list test data...
3502:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3503:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3504:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3505:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3506:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3507:	// Execute the linear search on all array test data...
3508:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3509:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3510:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3511:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3512:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3513:	// Execute all the sorts on all test data...
3514:	// Bubble sort LinkedList data...
3515:	Before: 	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea, ... (line shortened) ...
3516:	// Bubble sort array data...
3517:	Before: 	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea, ... (line shortened) ...
3518:	// Selection sort LinkedList data...
3519:	Before: 	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea, ... (line shortened) ...
3520:	// Selection sort array data...
3521:	Before: 	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea, ... (line shortened) ...
3522:	// Shell sort LinkedList data...
3523:	Before: 	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea, ... (line shortened) ...
3524:	// Shell sort array data...
3525:	Before: 	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea, ... (line shortened) ...
3526:	// Insertion sort LinkedList data...
3527:	Before: 	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea, ... (line shortened) ...
3528:	// Insertion sort array data...
3529:	Before: 	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea, ... (line shortened) ...
3530:	// Quick sort LinkedList data...
3531:	Before: 	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea, ... (line shortened) ...
3532:	// Quick sort array data...
3533:	Before: 	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea, ... (line shortened) ...
3534:	// Merge sort LinkedList data...
3535:	Before: 	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea, ... (line shortened) ...
3536:	// Merge sort array data...
3537:	Before: 	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea, ... (line shortened) ...
3538:	// Heap sort LinkedList data...
3539:	Before: 	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea, ... (line shortened) ...
3540:	// Heap sort array data...
3541:	Before: 	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea, ... (line shortened) ...
3542:	// Execute the binary search on all List test data...
3543:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3544:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3545:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3546:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3547:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3548:	// Execute the binary search on all Array test data...
3549:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3550:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3551:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3552:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3553:	[zips,paid,dung,cunt,eves,fags,wops,sing,Lura,exam,aloe,Fawn,best,jaws,goof,Snow,miss,hoes,fair,Shay,Alia,Doti,Ezri,suns,baud,slow,Hale,econ,bong,sues,spic,Loki,Tupi,trey,Klan,Deon,Msgr,Clea,fail,tree ... (line shortened) ...
3554:	Computer Science 42SAP - Binary Trees Post Secondary content running simulated:............
3555:	// Constants/variables for creating random values...
3556:	// Creating some TreeNode objects...
3557:	// Linking the TreeNodes...
3558:	// Testing TreeNode equals...
3559:	// Testing TreeNode toString...
3560:	55
3561:	16
3562:	45
3563:	// Creating a Tree object...
3564:	// Test the insert method...
3565:	// Insert one more...
3566:	// Test the search of the tree...
3567:	Should be found     = true
3568:	Should NOT be found = false
3569:	// Test toString() and pre, post, in order traversals
3570:	Binary Tree:
Order: [99,62,47,38,19,31]
Pre:   [99,62,47,38,19,31]
Post:  [31,19,38,47,62,99]
In:    [19,31,38,47,62,99]
3571:	// Building second tree (test clone) and test equals
3572:	1st tree -> [19,31,38,47,62,99]
3573:	2nd tree -> [28,31,52,60,68,69]
3574:	1st!=2nd
3575:	// Building a third tree (test clone) and test equals
3576:	1st tree -> [19,31,38,47,62,99]
3577:	3rd tree -> [19,31,38,47,62,99]
3578:	1st==3rd
3579:	// Build all our data structures from each other...
3580:	// Create variable objects...
3581:	// Create array from variables...
3582:	// Create LinkedList from array...
3583:	// Create Stack from LinkedList...
3584:	// Create Queue from Stack...
3585:	// Create Tree from Queue...
3586:	// Output variables,array,list,stack,queue,tree...
3587:	holey
3588:	youth
3589:	orson
3590:	grace
3591:	manly
3592:	[holey,youth,orson,grace,manly]
3593:	[holey,youth,orson,grace,manly]
3594:	Stack top -> [holey,youth,orson,grace,manly] <- bottom
3595:	Queue back -> [holey,youth,orson,grace,manly] <- front
3596:	Binary Tree:
Order: [holey,youth,orson,grace,manly]
Pre:   [holey,grace,youth,orson,manly]
Post:  [grace,manly,orson,youth,holey]
In:    [grace,holey,manly,orson,youth]
3597:	// Now re-building queue from tree
3598:	// Now re-building stack from queue
3599:	// Now re-building LinkedList from stack...
3600:	// Now re-building array from LinkedList...
3601:	// Output array,list,stack,queue,tree again...
3602:	[grace,holey,manly,orson,youth]
3603:	[grace,holey,manly,orson,youth]
3604:	Stack top -> [grace,holey,manly,orson,youth] <- bottom
3605:	Queue back -> [grace,holey,manly,orson,youth] <- front
3606:	Binary Tree:
Order: [holey,youth,orson,grace,manly]
Pre:   [holey,grace,youth,orson,manly]
Post:  [grace,manly,orson,youth,holey]
In:    [grace,holey,manly,orson,youth]

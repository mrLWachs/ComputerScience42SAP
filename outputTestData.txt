1:	Computer Science 42SAP - Mr. Wachs' Computer Science content running simulated:............
2:	Computer Science 42SAP - Computer Science 20S Course content running simulated:............
3:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
4:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
5:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
6:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
7:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
8:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
9:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
10:	Computer Science 42SAP - Computer Science 30S Course content running simulated:............
11:	Hello World I'm in The world!
12:	Good-bye World
13:	Make a quote " 
14:	Make a slash \ 
15:	Make a 	 tab 
16:	Make a 
 new line break
17:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
18:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
19:	~~~ SIMULATED {Message Information Title  simulated message} DIALOG: 
20:	~~~ SIMULATED {Message Question Title  simulated message} DIALOG: 
21:	~~~ SIMULATED {Message Warning Title  simulated message} DIALOG: 
22:	~~~ SIMULATED {Message Error Title  simulated message} DIALOG: 
23:	~~~ SIMULATED {Message Plain Title  simulated message} DIALOG: 
24:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
25:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
26:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
27:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
28:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
29:	~~~ SIMULATED {Confirm null  simulated message} DIALOG: 
30:	~~~ SIMULATED {Confirm Information  simulated message} DIALOG: 
31:	~~~ SIMULATED {Confirm Question  simulated message} DIALOG: 
32:	~~~ SIMULATED {Confirm Warning  simulated message} DIALOG: 
33:	~~~ SIMULATED {Confirm Error  simulated message} DIALOG: 
34:	~~~ SIMULATED {Confirm Plain  simulated message} DIALOG: 
35:	a = false
36:	b = 1
37:	c = 1.2
38:	d = A
39:	e = apple
40:	x = 0
41:	x = 20
42:	y = 30
43:	y = 30
44:	x = 28
45:	y = 5
46:	z = 3
47:	3.141592653589793,99,Y,true,Wachs
48:	f = 25
49:	g = 25.0
50:	g = 25.9999999999999
51:	h = 25
52:	k = 2.9999999999
53:	l = 2
54:	m = 2.0
55:	n = A
56:	o = 65
57:	p = F
58:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
59:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
60:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
61:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
62:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
63:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
64:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
65:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
66:	word hippopotomonsprosesquippedaiophobia is length 35
67:	word hippopotomonsprosesquippedaiophobia in upper case is HIPPOPOTOMONSPROSESQUIPPEDAIOPHOBIA
68:	answer1 = 3.141592653589793
69:	answer2 = 0.8775825618903728
70:	answer3 = 1.0
71:	answer4 = 125.0
72:	answer5 = 3.0
73:	answer6 = -0.6931471805599453
74:	seed = 0.553542641965421
75:	number = 6.53542641965421
76:	value = 6
77:	card = 40
78:	equal
79:	less than
80:	!=
81:	kind of equal
82:	Keep trying...
83:	counter = 0
84:	counter = 1
85:	counter = 2
86:	counter = 3
87:	counter = 4
88:	counter = 5
89:	counter = 6
90:	counter = 7
91:	counter = 8
92:	counter = 9
93:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
94:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
95:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
96:	0
97:	1
98:	2
99:	3
100:	4
101:	5
102:	6
103:	7
104:	8
105:	9
106:	i = 100
107:	i = 90
108:	i = 80
109:	i = 70
110:	i = 60
111:	i = 50
112:	i = 40
113:	i = 30
114:	i = 20
115:	i = 10
116:	i = 0
117:	counting = 100
118:	counting = 200
119:	counting = 400
120:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
121:	~~~ SIMULATED {Input null  simulated message} DIALOG: 
122:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
123:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
124:	Start learning methods...
125:	*
126:	*
127:	something
128:	Spider-man
129:	Batman
130:	Superman
131:	Omni-man
132:	Mr. Wachs
133:	Dalmations
134:	Dalmations
135:	Dalmations
136:	Dalmations
137:	Dalmations
138:	Dalmations
139:	Dalmations
140:	Dalmations
141:	Dalmations
142:	Dalmations
143:	Dalmations
144:	Dalmations
145:	Dalmations
146:	Dalmations
147:	Dalmations
148:	Dalmations
149:	Dalmations
150:	Dalmations
151:	Dalmations
152:	Dalmations
153:	Dalmations
154:	Dalmations
155:	Dalmations
156:	Dalmations
157:	Dalmations
158:	Dalmations
159:	Dalmations
160:	Dalmations
161:	Dalmations
162:	Dalmations
163:	Dalmations
164:	Dalmations
165:	Dalmations
166:	Dalmations
167:	Dalmations
168:	Dalmations
169:	Dalmations
170:	Dalmations
171:	Dalmations
172:	Dalmations
173:	Dalmations
174:	Dalmations
175:	Dalmations
176:	Dalmations
177:	Dalmations
178:	Dalmations
179:	Dalmations
180:	Dalmations
181:	Dalmations
182:	Dalmations
183:	Dalmations
184:	Dalmations
185:	Dalmations
186:	Dalmations
187:	Dalmations
188:	Dalmations
189:	Dalmations
190:	Dalmations
191:	Dalmations
192:	Dalmations
193:	Dalmations
194:	Dalmations
195:	Dalmations
196:	Dalmations
197:	Dalmations
198:	Dalmations
199:	Dalmations
200:	Dalmations
201:	Dalmations
202:	Dalmations
203:	Dalmations
204:	Dalmations
205:	Dalmations
206:	Dalmations
207:	Dalmations
208:	Dalmations
209:	Dalmations
210:	Dalmations
211:	Dalmations
212:	Dalmations
213:	Dalmations
214:	Dalmations
215:	Dalmations
216:	Dalmations
217:	Dalmations
218:	Dalmations
219:	Dalmations
220:	Dalmations
221:	Dalmations
222:	Dalmations
223:	Dalmations
224:	Dalmations
225:	Dalmations
226:	Dalmations
227:	Dalmations
228:	Dalmations
229:	Dalmations
230:	Dalmations
231:	Dalmations
232:	Dalmations
233:	Dalmations
234:	Problems
235:	Problems
236:	Problems
237:	Problems
238:	Problems
239:	Problems
240:	Problems
241:	Problems
242:	Problems
243:	Problems
244:	Problems
245:	Problems
246:	Problems
247:	Problems
248:	Problems
249:	Problems
250:	Problems
251:	Problems
252:	Problems
253:	Problems
254:	Problems
255:	Problems
256:	Problems
257:	Problems
258:	Problems
259:	Problems
260:	Problems
261:	Problems
262:	Problems
263:	Problems
264:	Problems
265:	Problems
266:	Problems
267:	Problems
268:	Problems
269:	Problems
270:	Problems
271:	Problems
272:	Problems
273:	Problems
274:	Problems
275:	Problems
276:	Problems
277:	Problems
278:	Problems
279:	Problems
280:	Problems
281:	Problems
282:	Problems
283:	Problems
284:	Problems
285:	Problems
286:	Problems
287:	Problems
288:	Problems
289:	Problems
290:	Problems
291:	Problems
292:	Problems
293:	Problems
294:	Problems
295:	Problems
296:	Problems
297:	Problems
298:	Problems
299:	Problems
300:	Problems
301:	Problems
302:	Problems
303:	Problems
304:	Problems
305:	Problems
306:	Problems
307:	Problems
308:	Problems
309:	Problems
310:	Problems
311:	Problems
312:	Problems
313:	Problems
314:	Problems
315:	Problems
316:	Problems
317:	Problems
318:	Problems
319:	Problems
320:	Problems
321:	Problems
322:	Problems
323:	Problems
324:	Problems
325:	Problems
326:	Problems
327:	Problems
328:	Problems
329:	Problems
330:	Problems
331:	Problems
332:	Problems
333:	Number was 6
334:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
335:	~~~ SIMULATED {Message Learning  simulated message} DIALOG: 
336:	Completed learning methods!
337:	Start Learning Arrays...
338:	666
339:	0 = 666
340:	1 = 0
341:	2 = 0
342:	3 = 0
343:	4 = 0
344:	5 = 0
345:	6 = 0
346:	7 = 0
347:	8 = 0
348:	9 = 0
349:	10 = 0
350:	11 = 0
351:	12 = 0
352:	13 = 0
353:	14 = 0
354:	15 = 0
355:	16 = 0
356:	17 = 0
357:	18 = 0
358:	19 = 0
359:	20 = 0
360:	21 = 0
361:	22 = 0
362:	23 = 0
363:	24 = 0
364:	25 = 0
365:	26 = 0
366:	27 = 0
367:	28 = 0
368:	29 = 0
369:	30 = 0
370:	31 = 0
371:	32 = 0
372:	33 = 0
373:	34 = 0
374:	35 = 0
375:	36 = 0
376:	37 = 0
377:	38 = 0
378:	39 = 0
379:	40 = 0
380:	41 = 0
381:	42 = 0
382:	43 = 0
383:	44 = 0
384:	45 = 0
385:	46 = 0
386:	47 = 0
387:	48 = 0
388:	49 = 0
389:	50 = 0
390:	51 = 0
391:	52 = 0
392:	53 = 0
393:	54 = 0
394:	55 = 0
395:	56 = 0
396:	57 = 0
397:	58 = 0
398:	59 = 0
399:	60 = 0
400:	61 = 0
401:	62 = 0
402:	63 = 0
403:	64 = 0
404:	65 = 0
405:	66 = 0
406:	67 = 0
407:	68 = 0
408:	69 = 0
409:	70 = 0
410:	71 = 0
411:	72 = 0
412:	73 = 0
413:	74 = 0
414:	75 = 0
415:	76 = 0
416:	77 = 0
417:	78 = 0
418:	79 = 0
419:	80 = 0
420:	81 = 0
421:	82 = 0
422:	83 = 0
423:	84 = 0
424:	85 = 0
425:	86 = 0
426:	87 = 0
427:	88 = 0
428:	89 = 0
429:	90 = 0
430:	91 = 0
431:	92 = 0
432:	93 = 0
433:	94 = 0
434:	95 = 0
435:	96 = 0
436:	97 = 0
437:	98 = 0
438:	99 = 333
439:	0 = 666 again!
440:	1 = 0 again!
441:	2 = 0 again!
442:	3 = 0 again!
443:	4 = 0 again!
444:	5 = 0 again!
445:	6 = 0 again!
446:	7 = 0 again!
447:	8 = 0 again!
448:	9 = 0 again!
449:	10 = 0 again!
450:	11 = 0 again!
451:	12 = 0 again!
452:	13 = 0 again!
453:	14 = 0 again!
454:	15 = 0 again!
455:	16 = 0 again!
456:	17 = 0 again!
457:	18 = 0 again!
458:	19 = 0 again!
459:	20 = 0 again!
460:	21 = 0 again!
461:	22 = 0 again!
462:	23 = 0 again!
463:	24 = 0 again!
464:	25 = 0 again!
465:	26 = 0 again!
466:	27 = 0 again!
467:	28 = 0 again!
468:	29 = 0 again!
469:	30 = 0 again!
470:	31 = 0 again!
471:	32 = 0 again!
472:	33 = 0 again!
473:	34 = 0 again!
474:	35 = 0 again!
475:	36 = 0 again!
476:	37 = 0 again!
477:	38 = 0 again!
478:	39 = 0 again!
479:	40 = 0 again!
480:	41 = 0 again!
481:	42 = 0 again!
482:	43 = 0 again!
483:	44 = 0 again!
484:	45 = 0 again!
485:	46 = 0 again!
486:	47 = 0 again!
487:	48 = 0 again!
488:	49 = 0 again!
489:	50 = 0 again!
490:	51 = 0 again!
491:	52 = 0 again!
492:	53 = 0 again!
493:	54 = 0 again!
494:	55 = 0 again!
495:	56 = 0 again!
496:	57 = 0 again!
497:	58 = 0 again!
498:	59 = 0 again!
499:	60 = 0 again!
500:	61 = 0 again!
501:	62 = 0 again!
502:	63 = 0 again!
503:	64 = 0 again!
504:	65 = 0 again!
505:	66 = 0 again!
506:	67 = 0 again!
507:	68 = 0 again!
508:	69 = 0 again!
509:	70 = 0 again!
510:	71 = 0 again!
511:	72 = 0 again!
512:	73 = 0 again!
513:	74 = 0 again!
514:	75 = 0 again!
515:	76 = 0 again!
516:	77 = 0 again!
517:	78 = 0 again!
518:	79 = 0 again!
519:	80 = 0 again!
520:	81 = 0 again!
521:	82 = 0 again!
522:	83 = 0 again!
523:	84 = 0 again!
524:	85 = 0 again!
525:	86 = 0 again!
526:	87 = 0 again!
527:	88 = 0 again!
528:	89 = 0 again!
529:	90 = 0 again!
530:	91 = 0 again!
531:	92 = 0 again!
532:	93 = 0 again!
533:	94 = 0 again!
534:	95 = 0 again!
535:	96 = 0 again!
536:	97 = 0 again!
537:	98 = 0 again!
538:	99 = 333 again!
539:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
540:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
541:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
542:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
543:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
544:	Random character was E
545:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
546:	~~~ SIMULATED {Message null  simulated message} DIALOG: 
547:	~~~ SIMULATED {Message The Matrix...  simulated message} DIALOG: 
548:	~~~ SIMULATED {Message Tic-Tac-Toe...  simulated message} DIALOG: 
549:	Completed learning Arrays!
550:	Start learning classes...
551:	Completed learning classes!
552:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
553:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
554:	~~~ SIMULATED {GUI Frame null  simulated message} DIALOG: 
555:	Computer Science 42SAP - Computer Science 40S Course content running simulated:............
556:	Recursion test started...
557:	Recursive factorials............................
558:	-1 factorial = 1
559:	0 factorial = 1
560:	1 factorial = 1
561:	2 factorial = 2
562:	3 factorial = 6
563:	4 factorial = 24
564:	5 factorial = 120
565:	6 factorial = 720
566:	7 factorial = 5040
567:	8 factorial = 40320
568:	9 factorial = 362880
569:	10 factorial = 3628800
570:	11 factorial = 39916800
571:	12 factorial = 479001600
572:	13 factorial = 6227020800
573:	14 factorial = 87178291200
574:	15 factorial = 1307674368000
575:	16 factorial = 20922789888000
576:	17 factorial = 355687428096000
577:	18 factorial = 6402373705728000
578:	19 factorial = 121645100408832000
579:	20 factorial = 2432902008176640000
580:	Recursive powers................................
581:	-5 to the exponent -5 = -3.2E-4
582:	-4 to the exponent -5 = -9.765625E-4
583:	-3 to the exponent -5 = -0.00411522633744856
584:	-2 to the exponent -5 = -0.03125
585:	-1 to the exponent -5 = -1.0
586:	0 to the exponent -5 = 4.9E-324
587:	1 to the exponent -5 = 1.0
588:	2 to the exponent -5 = 0.03125
589:	3 to the exponent -5 = 0.00411522633744856
590:	4 to the exponent -5 = 9.765625E-4
591:	5 to the exponent -5 = 3.2E-4
592:	6 to the exponent -5 = 1.286008230452675E-4
593:	7 to the exponent -5 = 5.9499018266198606E-5
594:	8 to the exponent -5 = 3.0517578125E-5
595:	9 to the exponent -5 = 1.6935087808430286E-5
596:	10 to the exponent -5 = 1.0E-5
597:	-5 to the exponent -4 = 0.0016
598:	-4 to the exponent -4 = 0.00390625
599:	-3 to the exponent -4 = 0.012345679012345678
600:	-2 to the exponent -4 = 0.0625
601:	-1 to the exponent -4 = 1.0
602:	0 to the exponent -4 = 4.9E-324
603:	1 to the exponent -4 = 1.0
604:	2 to the exponent -4 = 0.0625
605:	3 to the exponent -4 = 0.012345679012345678
606:	4 to the exponent -4 = 0.00390625
607:	5 to the exponent -4 = 0.0016
608:	6 to the exponent -4 = 7.716049382716049E-4
609:	7 to the exponent -4 = 4.1649312786339027E-4
610:	8 to the exponent -4 = 2.44140625E-4
611:	9 to the exponent -4 = 1.5241579027587258E-4
612:	10 to the exponent -4 = 1.0E-4
613:	-5 to the exponent -3 = -0.008
614:	-4 to the exponent -3 = -0.015625
615:	-3 to the exponent -3 = -0.037037037037037035
616:	-2 to the exponent -3 = -0.125
617:	-1 to the exponent -3 = -1.0
618:	0 to the exponent -3 = 4.9E-324
619:	1 to the exponent -3 = 1.0
620:	2 to the exponent -3 = 0.125
621:	3 to the exponent -3 = 0.037037037037037035
622:	4 to the exponent -3 = 0.015625
623:	5 to the exponent -3 = 0.008
624:	6 to the exponent -3 = 0.004629629629629629
625:	7 to the exponent -3 = 0.0029154518950437317
626:	8 to the exponent -3 = 0.001953125
627:	9 to the exponent -3 = 0.0013717421124828531
628:	10 to the exponent -3 = 0.001
629:	-5 to the exponent -2 = 0.04
630:	-4 to the exponent -2 = 0.0625
631:	-3 to the exponent -2 = 0.1111111111111111
632:	-2 to the exponent -2 = 0.25
633:	-1 to the exponent -2 = 1.0
634:	0 to the exponent -2 = 4.9E-324
635:	1 to the exponent -2 = 1.0
636:	2 to the exponent -2 = 0.25
637:	3 to the exponent -2 = 0.1111111111111111
638:	4 to the exponent -2 = 0.0625
639:	5 to the exponent -2 = 0.04
640:	6 to the exponent -2 = 0.027777777777777776
641:	7 to the exponent -2 = 0.02040816326530612
642:	8 to the exponent -2 = 0.015625
643:	9 to the exponent -2 = 0.012345679012345678
644:	10 to the exponent -2 = 0.01
645:	-5 to the exponent -1 = -0.2
646:	-4 to the exponent -1 = -0.25
647:	-3 to the exponent -1 = -0.3333333333333333
648:	-2 to the exponent -1 = -0.5
649:	-1 to the exponent -1 = -1.0
650:	0 to the exponent -1 = 4.9E-324
651:	1 to the exponent -1 = 1.0
652:	2 to the exponent -1 = 0.5
653:	3 to the exponent -1 = 0.3333333333333333
654:	4 to the exponent -1 = 0.25
655:	5 to the exponent -1 = 0.2
656:	6 to the exponent -1 = 0.16666666666666666
657:	7 to the exponent -1 = 0.14285714285714285
658:	8 to the exponent -1 = 0.125
659:	9 to the exponent -1 = 0.1111111111111111
660:	10 to the exponent -1 = 0.1
661:	-5 to the exponent 0 = 1.0
662:	-4 to the exponent 0 = 1.0
663:	-3 to the exponent 0 = 1.0
664:	-2 to the exponent 0 = 1.0
665:	-1 to the exponent 0 = 1.0
666:	0 to the exponent 0 = 1.0
667:	1 to the exponent 0 = 1.0
668:	2 to the exponent 0 = 1.0
669:	3 to the exponent 0 = 1.0
670:	4 to the exponent 0 = 1.0
671:	5 to the exponent 0 = 1.0
672:	6 to the exponent 0 = 1.0
673:	7 to the exponent 0 = 1.0
674:	8 to the exponent 0 = 1.0
675:	9 to the exponent 0 = 1.0
676:	10 to the exponent 0 = 1.0
677:	-5 to the exponent 1 = -5.0
678:	-4 to the exponent 1 = -4.0
679:	-3 to the exponent 1 = -3.0
680:	-2 to the exponent 1 = -2.0
681:	-1 to the exponent 1 = -1.0
682:	0 to the exponent 1 = 0.0
683:	1 to the exponent 1 = 1.0
684:	2 to the exponent 1 = 2.0
685:	3 to the exponent 1 = 3.0
686:	4 to the exponent 1 = 4.0
687:	5 to the exponent 1 = 5.0
688:	6 to the exponent 1 = 6.0
689:	7 to the exponent 1 = 7.0
690:	8 to the exponent 1 = 8.0
691:	9 to the exponent 1 = 9.0
692:	10 to the exponent 1 = 10.0
693:	-5 to the exponent 2 = 25.0
694:	-4 to the exponent 2 = 16.0
695:	-3 to the exponent 2 = 9.0
696:	-2 to the exponent 2 = 4.0
697:	-1 to the exponent 2 = 1.0
698:	0 to the exponent 2 = 0.0
699:	1 to the exponent 2 = 1.0
700:	2 to the exponent 2 = 4.0
701:	3 to the exponent 2 = 9.0
702:	4 to the exponent 2 = 16.0
703:	5 to the exponent 2 = 25.0
704:	6 to the exponent 2 = 36.0
705:	7 to the exponent 2 = 49.0
706:	8 to the exponent 2 = 64.0
707:	9 to the exponent 2 = 81.0
708:	10 to the exponent 2 = 100.0
709:	-5 to the exponent 3 = -125.0
710:	-4 to the exponent 3 = -64.0
711:	-3 to the exponent 3 = -27.0
712:	-2 to the exponent 3 = -8.0
713:	-1 to the exponent 3 = -1.0
714:	0 to the exponent 3 = 0.0
715:	1 to the exponent 3 = 1.0
716:	2 to the exponent 3 = 8.0
717:	3 to the exponent 3 = 27.0
718:	4 to the exponent 3 = 64.0
719:	5 to the exponent 3 = 125.0
720:	6 to the exponent 3 = 216.0
721:	7 to the exponent 3 = 343.0
722:	8 to the exponent 3 = 512.0
723:	9 to the exponent 3 = 729.0
724:	10 to the exponent 3 = 1000.0
725:	-5 to the exponent 4 = 625.0
726:	-4 to the exponent 4 = 256.0
727:	-3 to the exponent 4 = 81.0
728:	-2 to the exponent 4 = 16.0
729:	-1 to the exponent 4 = 1.0
730:	0 to the exponent 4 = 0.0
731:	1 to the exponent 4 = 1.0
732:	2 to the exponent 4 = 16.0
733:	3 to the exponent 4 = 81.0
734:	4 to the exponent 4 = 256.0
735:	5 to the exponent 4 = 625.0
736:	6 to the exponent 4 = 1296.0
737:	7 to the exponent 4 = 2401.0
738:	8 to the exponent 4 = 4096.0
739:	9 to the exponent 4 = 6561.0
740:	10 to the exponent 4 = 10000.0
741:	-5 to the exponent 5 = -3125.0
742:	-4 to the exponent 5 = -1024.0
743:	-3 to the exponent 5 = -243.0
744:	-2 to the exponent 5 = -32.0
745:	-1 to the exponent 5 = -1.0
746:	0 to the exponent 5 = 0.0
747:	1 to the exponent 5 = 1.0
748:	2 to the exponent 5 = 32.0
749:	3 to the exponent 5 = 243.0
750:	4 to the exponent 5 = 1024.0
751:	5 to the exponent 5 = 3125.0
752:	6 to the exponent 5 = 7776.0
753:	7 to the exponent 5 = 16807.0
754:	8 to the exponent 5 = 32768.0
755:	9 to the exponent 5 = 59049.0
756:	10 to the exponent 5 = 100000.0
757:	-5 to the exponent 6 = 15625.0
758:	-4 to the exponent 6 = 4096.0
759:	-3 to the exponent 6 = 729.0
760:	-2 to the exponent 6 = 64.0
761:	-1 to the exponent 6 = 1.0
762:	0 to the exponent 6 = 0.0
763:	1 to the exponent 6 = 1.0
764:	2 to the exponent 6 = 64.0
765:	3 to the exponent 6 = 729.0
766:	4 to the exponent 6 = 4096.0
767:	5 to the exponent 6 = 15625.0
768:	6 to the exponent 6 = 46656.0
769:	7 to the exponent 6 = 117649.0
770:	8 to the exponent 6 = 262144.0
771:	9 to the exponent 6 = 531441.0
772:	10 to the exponent 6 = 1000000.0
773:	-5 to the exponent 7 = -78125.0
774:	-4 to the exponent 7 = -16384.0
775:	-3 to the exponent 7 = -2187.0
776:	-2 to the exponent 7 = -128.0
777:	-1 to the exponent 7 = -1.0
778:	0 to the exponent 7 = 0.0
779:	1 to the exponent 7 = 1.0
780:	2 to the exponent 7 = 128.0
781:	3 to the exponent 7 = 2187.0
782:	4 to the exponent 7 = 16384.0
783:	5 to the exponent 7 = 78125.0
784:	6 to the exponent 7 = 279936.0
785:	7 to the exponent 7 = 823543.0
786:	8 to the exponent 7 = 2097152.0
787:	9 to the exponent 7 = 4782969.0
788:	10 to the exponent 7 = 1.0E7
789:	-5 to the exponent 8 = 390625.0
790:	-4 to the exponent 8 = 65536.0
791:	-3 to the exponent 8 = 6561.0
792:	-2 to the exponent 8 = 256.0
793:	-1 to the exponent 8 = 1.0
794:	0 to the exponent 8 = 0.0
795:	1 to the exponent 8 = 1.0
796:	2 to the exponent 8 = 256.0
797:	3 to the exponent 8 = 6561.0
798:	4 to the exponent 8 = 65536.0
799:	5 to the exponent 8 = 390625.0
800:	6 to the exponent 8 = 1679616.0
801:	7 to the exponent 8 = 5764801.0
802:	8 to the exponent 8 = 1.6777216E7
803:	9 to the exponent 8 = 4.3046721E7
804:	10 to the exponent 8 = 1.0E8
805:	-5 to the exponent 9 = -1953125.0
806:	-4 to the exponent 9 = -262144.0
807:	-3 to the exponent 9 = -19683.0
808:	-2 to the exponent 9 = -512.0
809:	-1 to the exponent 9 = -1.0
810:	0 to the exponent 9 = 0.0
811:	1 to the exponent 9 = 1.0
812:	2 to the exponent 9 = 512.0
813:	3 to the exponent 9 = 19683.0
814:	4 to the exponent 9 = 262144.0
815:	5 to the exponent 9 = 1953125.0
816:	6 to the exponent 9 = 1.0077696E7
817:	7 to the exponent 9 = 4.0353607E7
818:	8 to the exponent 9 = 1.34217728E8
819:	9 to the exponent 9 = 3.87420489E8
820:	10 to the exponent 9 = 1.0E9
821:	-5 to the exponent 10 = 9765625.0
822:	-4 to the exponent 10 = 1048576.0
823:	-3 to the exponent 10 = 59049.0
824:	-2 to the exponent 10 = 1024.0
825:	-1 to the exponent 10 = 1.0
826:	0 to the exponent 10 = 0.0
827:	1 to the exponent 10 = 1.0
828:	2 to the exponent 10 = 1024.0
829:	3 to the exponent 10 = 59049.0
830:	4 to the exponent 10 = 1048576.0
831:	5 to the exponent 10 = 9765625.0
832:	6 to the exponent 10 = 6.0466176E7
833:	7 to the exponent 10 = 2.82475249E8
834:	8 to the exponent 10 = 1.073741824E9
835:	9 to the exponent 10 = 3.486784401E9
836:	10 to the exponent 10 = 1.0E10
837:	Recursion complete!
838:	Start learing Advanced Classes..
839:	Object1 as a string = java.lang.Object@68ceda24
840:	Object2 as a string = java.lang.Object@281e3708
841:	Object3 as a string = java.lang.Object@281e3708
842:	Person  as a string = Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Person@35a50a4c
843:	Student as a string = Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Student@1f021e6c
844:	Teacher as a string = Teacher Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Teacher@103f852
845:	String  as a string = squirrel
846:	O2==O3
847:	P1==P2
848:	P2==P3
849:	P1==P3
850:	person==john
851:	S1==S2
852:	Students are equal!
853:	Teachers are equal!
854:	person1 : Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Person@587c290d
855:	clone of: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Person@587c290d
856:	student1: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Student@4516af24
857:	clone of: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Student@4ae82894
858:	teacher1: Teacher Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Teacher@543788f3
859:	clone of: Teacher Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Teacher@6d3af739
860:	Student total = 5
861:	Student total = 5
862:	Student total = 7
863:	Student total = 10
864:	Gender = male
865:	Alive = false
866:	Doctor: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Doctor@4bb4de6a
867:	DiskJockey: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.DiskJockey@7ba18f1b
868:	MrWachs: Teacher Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.MrWachs@2f8f5f62
869:	Husky: HighSchool: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Husky@1068e947
870:	Piper: HighSchool: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Piper@7dc222ae
871:	Athlete: Husky: HighSchool: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Athlete@aecb35a
872:	Round 1...
873:	Round 2...
874:	Round 3...
875:	Round 4...
876:	Class name: Boolean, Hash code: 1231, To String: true
877:	Class name: Integer, Hash code: 0, To String: 0
878:	Class name: Double, Hash code: 300063655, To String: 3.14
879:	Class name: Character, Hash code: 97, To String: a
880:	Class name: String, Hash code: 3556498, To String: test
881:	Class name: Athlete, Hash code: 183284570, To String: Athlete: Husky: HighSchool: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Athlete@aecb35a
882:	Class name: JOptionPane, Hash code: 1475491159, To String: utility.io.JOptionPane@57f23557
883:	Class name: Object, Hash code: 1024429571, To String: java.lang.Object@3d0f8e03
884:	Class name: Boolean, Hash code: 1231, To String: true
885:	Class name: Integer, Hash code: 0, To String: 0
886:	Class name: Double, Hash code: 300063655, To String: 3.14
887:	Class name: Character, Hash code: 97, To String: a
888:	Class name: String, Hash code: 3556498, To String: test
889:	Class name: Athlete, Hash code: 183284570, To String: Athlete: Husky: HighSchool: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Athlete@aecb35a
890:	Completed learning Advanced Classes!
891:	Collections testing begins...
892:	Testing Node constructors....................
893:	Testing Node toString()......................
894:	Node a = null
895:	Node b = Sass
896:	Node c = Pros
897:	Node d = Joes
898:	Testing Node clone().........................
899:	Node e = null
900:	Node f = Sass
901:	Node g = Pros
902:	Node h = Joes
903:	Testing Node equal().........................
904:	Node a == b? -> false
905:	Node b == c? -> false
906:	Node c == d? -> false
907:	Node d == d? -> true
908:	Node e == a? -> false
909:	Node f == b? -> true
910:	Node g == c? -> true
911:	Node h == d? -> true
912:	Testing Node finalize()......................
913:	Node a = null
914:	Node b = Sass
915:	Node c = Pros
916:	Node d = Joes
917:	Node e = null
918:	Node f = Sass
919:	Node g = Pros
920:	Node h = Joes
921:	Node a = null
922:	Node b = null
923:	Node c = null
924:	Node d = null
925:	Node e = null
926:	Node f = null
927:	Node g = null
928:	Node h = null
929:	Testing default LinkedList constructor.......
930:	Testing toString, empty, size methods........
931:	L1 toString -> Empty LinkedList
932:	L2 toString -> Empty LinkedList
933:	L1 empty? -> true
934:	L2 empty? -> true
935:	L1 size -> 0
936:	L2 size -> 0
937:	Test add (first to the back) of the list.....
938:	addBack -> true	[51]
939:	addBack -> true	[51,50]
940:	addBack -> true	[51,50,-50]
941:	addBack -> true	[51,50,-50,55]
942:	addBack -> false	[51,50,-50,55]
943:	Test add (second to the front) of the list...
944:	addFront -> true	[80,51,50,-50,55]
945:	addFront -> true	[81,80,51,50,-50,55]
946:	addFront -> true	[-80,81,80,51,50,-50,55]
947:	addFront -> true	[88,-80,81,80,51,50,-50,55]
948:	addFront -> false	[88,-80,81,80,51,50,-50,55]
949:	Re-testing empty, size methods...............
950:	L1 empty? -> false	[88,-80,81,80,51,50,-50,55]
951:	L2 empty? -> true	Empty LinkedList
952:	L1 size -> 8	[88,-80,81,80,51,50,-50,55]
953:	L2 size -> 0	Empty LinkedList
954:	Test get method..............................
955:	Getting -1 = null	[88,-80,81,80,51,50,-50,55]
956:	Getting 0 = 88	[88,-80,81,80,51,50,-50,55]
957:	Getting 1 = -80	[88,-80,81,80,51,50,-50,55]
958:	Getting 2 = 81	[88,-80,81,80,51,50,-50,55]
959:	Getting 3 = 80	[88,-80,81,80,51,50,-50,55]
960:	Getting 4 = 51	[88,-80,81,80,51,50,-50,55]
961:	Getting 5 = 50	[88,-80,81,80,51,50,-50,55]
962:	Getting 6 = -50	[88,-80,81,80,51,50,-50,55]
963:	Getting 7 = 55	[88,-80,81,80,51,50,-50,55]
964:	Getting 8 = null	[88,-80,81,80,51,50,-50,55]
965:	Test set method..............................
966:	Setting -1 to 9 -> false	[88,-80,81,80,51,50,-50,55]
967:	Setting 0 to 10 -> true	[10,-80,81,80,51,50,-50,55]
968:	Setting 1 to 11 -> true	[10,11,81,80,51,50,-50,55]
969:	Setting 2 to 12 -> true	[10,11,12,80,51,50,-50,55]
970:	Setting 3 to 13 -> true	[10,11,12,13,51,50,-50,55]
971:	Setting 4 to 14 -> true	[10,11,12,13,14,50,-50,55]
972:	Setting 5 to 15 -> true	[10,11,12,13,14,15,-50,55]
973:	Setting 6 to 16 -> true	[10,11,12,13,14,15,16,55]
974:	Setting 7 to 17 -> true	[10,11,12,13,14,15,16,17]
975:	Setting 8 to 18 -> false	[10,11,12,13,14,15,16,17]
976:	Setting 0 to null -> false	[10,11,12,13,14,15,16,17]
977:	Test equals method...........................
978:	List 1 = [10,11,12,13,14,15,16,17]
979:	List 2 = Empty LinkedList
980:	List1 == List2 -> false
981:	Test clone method............................
982:	List 1 = [10,11,12,13,14,15,16,17]
983:	List 2 = [10,11,12,13,14,15,16,17]
984:	Re-testing equals...
985:	List1 == List2 -> true
986:	Test addAfter method.........................
987:	Adding value 	99	 after index 	-1	 result 	false	[10,11,12,13,14,15,16,17]
988:	Adding value 	100	 after index 	0	 result 	true	[10,100,11,12,13,14,15,16,17]
989:	Adding value 	101	 after index 	1	 result 	true	[10,100,101,11,12,13,14,15,16,17]
990:	Adding value 	102	 after index 	2	 result 	true	[10,100,101,102,11,12,13,14,15,16,17]
991:	Adding value 	103	 after index 	3	 result 	true	[10,100,101,102,103,11,12,13,14,15,16,17]
992:	Adding value 	104	 after index 	4	 result 	true	[10,100,101,102,103,104,11,12,13,14,15,16,17]
993:	Adding value 	105	 after index 	5	 result 	true	[10,100,101,102,103,104,105,11,12,13,14,15,16,17]
994:	Adding value 	106	 after index 	6	 result 	true	[10,100,101,102,103,104,105,106,11,12,13,14,15,16,17]
995:	Adding value 	107	 after index 	7	 result 	true	[10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
996:	Test other edge case
997:	Adding value 	10	 after index 	17	 result 	false	[10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
998:	Test addBefore method.........................
999:	Adding value 	99	 before index 	-1	 result 	false	[10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1000:	Adding value 	100	 before index 	0	 result 	true	[100,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1001:	Adding value 	101	 before index 	1	 result 	true	[100,101,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1002:	Adding value 	102	 before index 	2	 result 	true	[100,101,102,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1003:	Adding value 	103	 before index 	3	 result 	true	[100,101,102,103,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1004:	Adding value 	104	 before index 	4	 result 	true	[100,101,102,103,104,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1005:	Adding value 	105	 before index 	5	 result 	true	[100,101,102,103,104,105,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1006:	Adding value 	106	 before index 	6	 result 	true	[100,101,102,103,104,105,106,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1007:	Adding value 	107	 before index 	7	 result 	true	[100,101,102,103,104,105,106,107,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1008:	Adding value 	108	 before index 	8	 result 	true	[100,101,102,103,104,105,106,107,108,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1009:	Adding value 	109	 before index 	9	 result 	true	[100,101,102,103,104,105,106,107,108,109,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1010:	Adding value 	110	 before index 	10	 result 	true	[100,101,102,103,104,105,106,107,108,109,110,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1011:	Adding value 	111	 before index 	11	 result 	true	[100,101,102,103,104,105,106,107,108,109,110,111,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1012:	Adding value 	112	 before index 	12	 result 	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1013:	Adding value 	113	 before index 	13	 result 	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1014:	Adding value 	114	 before index 	14	 result 	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1015:	Adding value 	115	 before index 	15	 result 	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1016:	Test other edge case
1017:	Adding value 	10	 before index 	33	 result 	false	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1018:	Test front and back methods..................
1019:	Front of list 1 = 100	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1020:	Front of list 2 = 10	[10,11,12,13,14,15,16,17]
1021:	Back of list 1 = 17	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1022:	Back of list 2 = 17	[10,11,12,13,14,15,16,17]
1023:	Clear out list 2
1024:	Front of list 2 = null	Empty LinkedList
1025:	Back of list 2 = null	Empty LinkedList
1026:	Cloning list 2 from list 1
1027:	Test removeFront method......................
1028:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	100
1029:	[101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	101
1030:	[102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	102
1031:	[103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	103
1032:	[104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	104
1033:	[105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	105
1034:	[106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	106
1035:	[107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	107
1036:	[108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	108
1037:	[109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	109
1038:	[110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	110
1039:	[111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	111
1040:	[112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	112
1041:	[113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	113
1042:	[114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	114
1043:	[115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	115
1044:	[10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	10
1045:	[100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	100
1046:	[101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	101
1047:	[102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	102
1048:	[103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	103
1049:	[104,105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	104
1050:	[105,106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	105
1051:	[106,107,11,12,13,14,15,16,17]	Removing list 1 front = 	106
1052:	[107,11,12,13,14,15,16,17]	Removing list 1 front = 	107
1053:	[11,12,13,14,15,16,17]	Removing list 1 front = 	11
1054:	[12,13,14,15,16,17]	Removing list 1 front = 	12
1055:	[13,14,15,16,17]	Removing list 1 front = 	13
1056:	[14,15,16,17]	Removing list 1 front = 	14
1057:	[15,16,17]	Removing list 1 front = 	15
1058:	[16,17]	Removing list 1 front = 	16
1059:	[17]	Removing list 1 front = 	17
1060:	Empty LinkedList	Removing list 1 front = 	null
1061:	Cloning list 1 from list 2
1062:	Test removeBack method.......................
1063:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing list 2 back = 	17
1064:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16]	Removing list 2 back = 	16
1065:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15]	Removing list 2 back = 	15
1066:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14]	Removing list 2 back = 	14
1067:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13]	Removing list 2 back = 	13
1068:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12]	Removing list 2 back = 	12
1069:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11]	Removing list 2 back = 	11
1070:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107]	Removing list 2 back = 	107
1071:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106]	Removing list 2 back = 	106
1072:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105]	Removing list 2 back = 	105
1073:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104]	Removing list 2 back = 	104
1074:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103]	Removing list 2 back = 	103
1075:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102]	Removing list 2 back = 	102
1076:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101]	Removing list 2 back = 	101
1077:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100]	Removing list 2 back = 	100
1078:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10]	Removing list 2 back = 	10
1079:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115]	Removing list 2 back = 	115
1080:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114]	Removing list 2 back = 	114
1081:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113]	Removing list 2 back = 	113
1082:	[100,101,102,103,104,105,106,107,108,109,110,111,112]	Removing list 2 back = 	112
1083:	[100,101,102,103,104,105,106,107,108,109,110,111]	Removing list 2 back = 	111
1084:	[100,101,102,103,104,105,106,107,108,109,110]	Removing list 2 back = 	110
1085:	[100,101,102,103,104,105,106,107,108,109]	Removing list 2 back = 	109
1086:	[100,101,102,103,104,105,106,107,108]	Removing list 2 back = 	108
1087:	[100,101,102,103,104,105,106,107]	Removing list 2 back = 	107
1088:	[100,101,102,103,104,105,106]	Removing list 2 back = 	106
1089:	[100,101,102,103,104,105]	Removing list 2 back = 	105
1090:	[100,101,102,103,104]	Removing list 2 back = 	104
1091:	[100,101,102,103]	Removing list 2 back = 	103
1092:	[100,101,102]	Removing list 2 back = 	102
1093:	[100,101]	Removing list 2 back = 	101
1094:	[100]	Removing list 2 back = 	100
1095:	Empty LinkedList	Removing list 2 back = 	null
1096:	Cloning list 2 from list 1
1097:	Test remove method...........................
1098:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing from list 1 from index: 	33	 removed: 	null
1099:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing from list 1 from index: 	32	 removed: 	null
1100:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]	Removing from list 1 from index: 	31	 removed: 	17
1101:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16]	Removing from list 1 from index: 	30	 removed: 	16
1102:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15]	Removing from list 1 from index: 	29	 removed: 	15
1103:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14]	Removing from list 1 from index: 	28	 removed: 	14
1104:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13]	Removing from list 1 from index: 	27	 removed: 	13
1105:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12]	Removing from list 1 from index: 	26	 removed: 	12
1106:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11]	Removing from list 1 from index: 	25	 removed: 	11
1107:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107]	Removing from list 1 from index: 	24	 removed: 	107
1108:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106]	Removing from list 1 from index: 	23	 removed: 	106
1109:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105]	Removing from list 1 from index: 	22	 removed: 	105
1110:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104]	Removing from list 1 from index: 	21	 removed: 	104
1111:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103]	Removing from list 1 from index: 	20	 removed: 	103
1112:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102]	Removing from list 1 from index: 	19	 removed: 	102
1113:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101]	Removing from list 1 from index: 	18	 removed: 	101
1114:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100]	Removing from list 1 from index: 	17	 removed: 	100
1115:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10]	Removing from list 1 from index: 	16	 removed: 	10
1116:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115]	Removing from list 1 from index: 	15	 removed: 	115
1117:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114]	Removing from list 1 from index: 	14	 removed: 	114
1118:	[100,101,102,103,104,105,106,107,108,109,110,111,112,113]	Removing from list 1 from index: 	13	 removed: 	113
1119:	[100,101,102,103,104,105,106,107,108,109,110,111,112]	Removing from list 1 from index: 	12	 removed: 	112
1120:	[100,101,102,103,104,105,106,107,108,109,110,111]	Removing from list 1 from index: 	11	 removed: 	111
1121:	[100,101,102,103,104,105,106,107,108,109,110]	Removing from list 1 from index: 	10	 removed: 	110
1122:	[100,101,102,103,104,105,106,107,108,109]	Removing from list 1 from index: 	9	 removed: 	109
1123:	[100,101,102,103,104,105,106,107,108]	Removing from list 1 from index: 	8	 removed: 	108
1124:	[100,101,102,103,104,105,106,107]	Removing from list 1 from index: 	7	 removed: 	107
1125:	[100,101,102,103,104,105,106]	Removing from list 1 from index: 	6	 removed: 	106
1126:	[100,101,102,103,104,105]	Removing from list 1 from index: 	5	 removed: 	105
1127:	[100,101,102,103,104]	Removing from list 1 from index: 	4	 removed: 	104
1128:	[100,101,102,103]	Removing from list 1 from index: 	3	 removed: 	103
1129:	[100,101,102]	Removing from list 1 from index: 	2	 removed: 	102
1130:	[100,101]	Removing from list 1 from index: 	1	 removed: 	101
1131:	[100]	Removing from list 1 from index: 	0	 removed: 	100
1132:	Empty LinkedList	Removing from list 1 from index: 	-1	 removed: 	null
1133:	Test contains method.........................
1134:	List 1 (empty) contains 10 = false	Empty LinkedList
1135:	List 2 contains 	100	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1136:	List 2 contains 	101	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1137:	List 2 contains 	102	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1138:	List 2 contains 	103	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1139:	List 2 contains 	104	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1140:	List 2 contains 	105	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1141:	List 2 contains 	106	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1142:	List 2 contains 	107	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1143:	List 2 contains 	108	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1144:	List 2 contains 	109	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1145:	List 2 contains 	110	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1146:	List 2 contains 	111	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1147:	List 2 contains 	112	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1148:	List 2 contains 	113	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1149:	List 2 contains 	114	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1150:	List 2 contains 	115	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1151:	List 2 contains 	10	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1152:	List 2 contains 	100	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1153:	List 2 contains 	101	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1154:	List 2 contains 	102	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1155:	List 2 contains 	103	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1156:	List 2 contains 	104	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1157:	List 2 contains 	105	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1158:	List 2 contains 	106	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1159:	List 2 contains 	107	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1160:	List 2 contains 	11	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1161:	List 2 contains 	12	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1162:	List 2 contains 	13	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1163:	List 2 contains 	14	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1164:	List 2 contains 	15	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1165:	List 2 contains 	16	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1166:	List 2 contains 	17	true	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1167:	List 2 contains 	1000	false	[100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,10,100,101,102,103,104,105,106,107,11,12,13,14,15,16,17]
1168:	Resetting list 1 to: [5,6,7,8,5,6,7,5,6,7]
1169:	Test firstIndexOf and lastIndexOf methods....
1170:	First index of 5: 	0
1171:	Last  index of 5: 	7
1172:	First index of 7: 	2
1173:	Last  index of 7: 	9
1174:	First index of 8: 	3
1175:	Last  index of 8: 	3
1176:	First index of 9: 	-1
1177:	Last  index of 9: 	-1
1178:	Test numberOf method.........................
1179:	[5,6,7,8,5,6,7,5,6,7]
1180:	Number of 5: 	3
1181:	Number of 8: 	1
1182:	Number of 9: 	0
1183:	Test allIndices method.......................
1184:	[5,6,7,8,5,6,7,5,6,7]
1185:	Array -> indices 5: 	[0, 4, 7]
1186:	Array -> indices 8: 	[3]
1187:	Array -> indices 9: 	null
1188:	Cloning list 2 from list 1
1189:	Test remove method...........................
1190:	[5,6,7,8,5,6,7,5,6,7]
1191:	Removing 5: 	true	[6,7,8,5,6,7,5,6,7]
1192:	Removing 8: 	true	[6,7,5,6,7,5,6,7]
1193:	Removing 9: 	false	[6,7,5,6,7,5,6,7]
1194:	Test removeLast method.......................
1195:	[6,7,5,6,7,5,6,7]
1196:	Removing 5: 	true	[6,7,5,6,7,6,7]
1197:	Removing 8: 	false	[6,7,5,6,7,6,7]
1198:	Removing 9: 	false	[6,7,5,6,7,6,7]
1199:	Test removeAll method........................
1200:	[6,7,5,6,7,6,7]
1201:	Removing all 5: 	true	[6,7,6,7,6,7]
1202:	Removing all 6: 	true	[7,7,7]
1203:	Removing all 9: 	false	[7,7,7]
1204:	Cloning list 1 from list 2
1205:	Test removeAll array method..................
1206:	[5,6,7,8,5,6,7,5,6,7]
1207:	Array: 	[5, 6, 9]
1208:	Removing all from array: [7,8,7,7]
1209:	Test removeAll list method..................
1210:	List 1 	[5,6,7,8,5,6,7,5,6,7]
1211:	List 2 	[7,8,7,7]
1212:	Removing all list 2 from list 1...
1213:	List 1 	[5,6,5,6,5,6]
1214:	List 2 	[7,8,7,7]
1215:	Resetting list 1 and 2 to: [5,6,7,8,5,6,7,5,6,7]
1216:	Test containsAll array method................
1217:	List: 	[5,6,7,8,5,6,7,5,6,7] contains array: 	[5, 6, 9]	 is false
1218:	List: 	[5,6,7,8,5,6,7,5,6,7] contains array: 	[5, 6, 7, 8]	 is true
1219:	Test containsAll list method.................
1220:	List: 	[5,6,7,8,5,6,7,5,6,7] contains list: 	[5,6,7,8,5,6,7,5,6,7]	 is true
1221:	Alter list 2...
1222:	List: 	[5,6,7,8,5,6,7,5,6,7] contains list: 	[6,7,8,6,7,5,6,45]	 is false
1223:	Test addAll array method.....................
1224:	[6,7,8,6,7,5,6,45]
1225:	Adding array: 	[5, 6, 7, 8]	 now list 	[6,7,8,6,7,5,6,45,5,6,7,8]
1226:	Test addAll list method......................
1227:	[6,7,8,6,7,5,6,45,5,6,7,8]
1228:	Adding list: 	[5,6,7,8,5,6,7,5,6,7]	 now list 	[6,7,8,6,7,5,6,45,5,6,7,8,5,6,7,8,5,6,7,5,6,7]
1229:	Test subList method..........................
1230:	List 1 = 	[5,6,7,8,5,6,7,5,6,7]
1231:	Pulling out sub-list from 3 to 6: 	[8,5,6,7]
1232:	Pulling out sub-list from 1 to 1: 	[6]
1233:	Pulling out sub-list from 2 to 10: 	null
1234:	Pulling out sub-list from 0 to 9: 	[5,6,7,8,5,6,7,5,6,7]
1235:	Test fromArray method........................
1236:	Array is 	[5, 6, 7, 8]
1237:	List is 	[5,6,7,8]
1238:	Test fromLinkedList method...................
1239:	1st List is 	[5,6,7,8]
1240:	2nd List is 	[5,6,7,8]
1241:	Test toArray method..........................
1242:	List 	[5,6,7,8]	 into array 	[5, 6, 7, 8]
1243:	Testing the imported util LinkedList.........
1244:	Imported constructor...
1245:	Imported add:	[0.0]
1246:	Imported add:	[0.0, 1.23]
1247:	Imported addFirst:	[4.56, 0.0, 1.23]
1248:	Imported addLast:	[4.56, 0.0, 1.23, 7.89]
1249:	Imported size:	4
1250:	Imported isEmpty:	false
1251:	Imported get:	0.0
1252:	Imported set:	4.56
1253:	Imported clone:	[0.01, 0.0, 1.23, 7.89]
1254:	Imported equals:	true
1255:	Imported getFirst:	0.01
1256:	Imported getLast:	7.89
1257:	Imported contains:	true
1258:	Imported removeFirst:	0.01
1259:	Imported removeLast:	7.89
1260:	Imported remove:	1.23
1261:	Imported remove:	false
1262:	Testing the imported util ArrayList.........
1263:	Imported ArrayList:	[a, b, c, d, e]
1264:	Using the enhanced for loop with this object...
1265:	a b c d e Using an iterator object...
1266:	a b c d e Collections testing complete!
1267:	Computer Science 42SAP - Curriculum content running simulated:.............................
1268:	Computer Science 42SAP - AP curriculum - Unit 1: Using Objects and Methods content running simulated:.
1269:	Unit 1 - Using Objects and Methods.........................................................
1270:	1.1 - Introduction to Algorithms, Programming, and Compilers...............................
1271:	   1.1.1 - Represent patterns and algorithms found in everyday life using written 
1272:	              language or diagrams.
1273:	      1.1.1.1 - Algorithms define step-by-step processes to follow when completing 
1274:	                 a task or solving a problem. These algorithms can be represented using written 
1275:	                 language or diagrams.
1276:	      1.1.1.2 - Sequencing defines an order for when steps in a process are completed. 
1277:	                 Steps in a process are completed one at a time.
1278:	   1.1.2 - Explain the code compilation and execution process. 
1279:	      1.1.2.1 - Code can be written in any text editor; however, an integrated development 
1280:	                 environment (IDE) is often used to write programs because it provides tools 
1281:	                 for a programmer to write, compile, and run code. 
1282:	      1.1.2.2 - A compiler checks code for some errors. Errors detectable by the 
1283:	                 compiler need to be fixed before the program can be run.
1284:	   1.1.3 - Identify types of programming errors.
1285:	      1.1.3.1 - A syntax error is a mistake in the program where the rules of the 
1286:	                 programming language are not followed. These errors are detected by the compiler. 
1287:	      1.1.3.2 - A logic error is a mistake in the algorithm or program that causes 
1288:	                 it to behave incorrectly or unexpectedly. These errors are detected by testing 
1289:	                 the program with specific data to see if it produces the expected outcome. 
1290:	      1.1.3.3 - A run-time error is a mistake in the program that occurs during 
1291:	                 the execution of a program. Run-time errors typically cause the program to 
1292:	                 terminate abnormally. 
1293:	      1.1.3.4 - An exception is a type of run-time error that occurs as a result 
1294:	                 of an unexpected error that was not detected by the compiler. It interrupts 
1295:	                 the normal flow of the program's execution.
1296:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1297:	// comment here
1298:	code here
1299:	standard output here
1300:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1301:	1.2 - Variables and Data Types.............................................................
1302:	   1.2.1 - Identify the most appropriate data type category for a particular specification. 
1303:	      1.2.1.1 - A data type is a set of values and a corresponding set of operations 
1304:	                 on those values. Data types can be categorized as either primitive or reference. 
1305:	      1.2.1.2 - The primitive data types used in this course define the set of values 
1306:	                 and corresponding operations on those values for numbers and Boolean values. 
1307:	      1.2.1.3 - A reference type is used to define objects that are not primitive 
1308:	                 types.
1309:	   1.2.2 - Develop code to declare variables to store numbers and Boolean values.
1310:	      1.2.2.1 - The three primitive data types used in this course are int, double, 
1311:	                 and boolean. An int value is an integer. A double value is a real number. 
1312:	                 A boolean value is either true or false. Note: the other five primitive data 
1313:	                 types (long, short, byte, float, and char) are outside the scope of the AP 
1314:	                 Computer Science A course and exam. 
1315:	      1.2.2.2 - A variable is a storage location that holds a value, which can change 
1316:	                 while the program is running. Every variable has a name and an associated 
1317:	                 data type. A variable of a primitive type holds a primitive value from that 
1318:	                 type.
1319:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1320:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1321:	1.3 - Expressions and Output...............................................................
1322:	   1.3.1 - Develop code to generate output and determine the result that would be 
1323:	              displayed.
1324:	      1.3.1.1 - System.out.print and System.out.println display information on the 
1325:	                 computer display. System.out.println moves the cursor to a new line after 
1326:	                 the information has been displayed, while System.out.print does not.
1327:	   1.3.2 - Develop code to utilize string literals and determine the result of using 
1328:	              string literals.
1329:	      1.3.2.1 - A literal is the code  representation of a fixed value. 
1330:	      1.3.2.2 - A string literal is a sequence of characters enclosed in double 
1331:	                 quotes. 
1332:	      1.3.2.3 - Escape sequences are special sequences of characters that can be 
1333:	                 included in a string. They start with a \ and have a special meaning in Java. 
1334:	                 Escape sequences used in this course include double quote \", backslash \\, 
1335:	                 and newline \n.
1336:	   1.3.3 - Develop code for arithmetic expressions and determine the result of these 
1337:	              expressions. 
1338:	      1.3.3.1 - Arithmetic expressions, which consist of numeric values, variables, 
1339:	                 and operators, include expressions of type int and double. 
1340:	      1.3.3.2 - The arithmetic operators consist of addition +, subtraction -, multiplication 
1341:	                 *, division /, and remainder %. An  arithmetic operation that uses two int 
1342:	                 values will evaluate to an int value. An arithmetic operation that uses at 
1343:	                 least one double value will evaluate to a double value. Note: Expressions 
1344:	                 that result in special double values (e.g., infinities and NaN) are outside 
1345:	                 the scope of the AP Computer Science A course and exam.
1346:	      1.3.3.3 - When dividing numeric values that are both int values, the result 
1347:	                 is only the integer portion of the quotient. When dividing numeric values 
1348:	                 that use at least one double value, the result is the quotient. 
1349:	      1.3.3.4 - The remainder operator % is used to compute the remainder when one 
1350:	                 number a is divided by another number b. Note: The use of values less than 
1351:	                 0 for a and the use of values less than or equal to 0 for b is outside the 
1352:	                 scope of the AP Computer Science A course and exam. 
1353:	      1.3.3.5 - Operators can be used to construct compound expressions. At compile 
1354:	                 time, numeric values are associated with operators according to operator precedence 
1355:	                 to determine how they are grouped. Parentheses can be used to modify operator 
1356:	                 precedence. Multiplication, division, and remainder have precedence over addition 
1357:	                 and subtraction. Operators with the same precedence are evaluated from left 
1358:	                 to right. 
1359:	      1.3.3.6 - An attempt to divide an integer by the integer zero will result 
1360:	                 in an ArithmeticException. Note: The use of dividing by zero when one numeric 
1361:	                 value is a double is outside the scope of the AP Computer Science A course 
1362:	                 and exam)
1363:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1364:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1365:	1.4 - Assignment Statements and Input......................................................
1366:	   1.4.1 - Develop code for assignment statements with expressions and determine 
1367:	              the value that is stored in the variable as a result of these statements. 
1368:	      1.4.1.1 - Every variable must be assigned a value before it can be used in 
1369:	                 an expression. That value must be from a compatible data type. A variable 
1370:	                 is initialized the first time it is assigned a value. Reference types can 
1371:	                 be assigned a new object or null if there is no object. The literal null is 
1372:	                 a special value used to indicate that a reference is not associated with any 
1373:	                 object. 
1374:	      1.4.1.2 - The assignment operator = allows a program to initialize or change 
1375:	                 the value stored in a variable. The value of the expression on the right is 
1376:	                 stored in the variable on the left. Note: The use of assignment operators 
1377:	                 inside expressions (e.g., a = b = 4; or a[i += 5]) is outside the scope of 
1378:	                 the AP Computer Science A course and exam.
1379:	      1.4.1.3 - During execution, an expression is evaluated to produce a single 
1380:	                 value. The value of an expression has a type based on the evaluation of the 
1381:	                 expression)
1382:	   1.4.2 - Develop code to read input.
1383:	      1.4.2.1 - Input can come in a variety of forms, such as tactile, audio, visual, 
1384:	                 or text. The Scanner class is one way to obtain text input from the keyboard. 
1385:	                 Note: Any specific form of input from the user is outside the scope of the 
1386:	                 AP Computer Science A course and exam.
1387:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1388:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1389:	1.5 - Casting and Range of Variables.......................................................
1390:	   1.5.1 - Develop code to cast primitive values to different primitive types in 
1391:	              arithmetic expressions and determine the value that is produced as a result.
1392:	      1.5.1.1 - The casting operators (int) and (double) can be used to convert 
1393:	                 from a double value to an int value (or vice versa). 
1394:	      1.5.1.2 - Casting a double value to an int value causes the digits to the 
1395:	                 right of the decimal point to be truncated. 
1396:	      1.5.1.3 - Some code causes int values to be automatically cast (widened) to 
1397:	                 double values. 
1398:	      1.5.1.4 - Values of type double can be rounded to the nearest integer by (int) 
1399:	                 (x + 0.5) for non-negative numbers or (int)(x - 0.5) for negative numbers.
1400:	   1.5.2 - Describe conditions when an integer expression evaluates to a value out 
1401:	              of range.
1402:	      1.5.2.1 - The constant Integer.MAX_VALUE holds the value of the largest possible 
1403:	                 int value. The constant Integer.MIN_VALUE holds the value of the smallest 
1404:	                 possible int value. 
1405:	      1.5.2.2 - Integer values in Java are represented by values of type int, which 
1406:	                 are stored using a finite amount (4 bytes) of memory. Therefore, an int value 
1407:	                 must be in the range from Integer.MIN_VALUE to Integer.MAX_VALUE inclusive.
1408:	      1.5.2.3 - If an expression would evaluate to an int value outside of the allowed 
1409:	                 range, an integer overflow occurs. The result is an int value in the allowed 
1410:	                 range but not necessarily the value expected.
1411:	   1.5.3 - Describe conditions that limit accuracy of expressions.
1412:	      1.5.3.1 - Computers allot a specified amount of memory to store data based 
1413:	                 on the data type. If an expression would evaluate to a double that is more 
1414:	                 precise than can be stored in the allotted amount of memory, a round-off error 
1415:	                 occurs. The result will be rounded to the representable value. To avoid rounding 
1416:	                 errors that naturally occur, use int values. Note: Other special decimal data 
1417:	                 types that can be used to avoid rounding errors are outside the scope of the 
1418:	                 AP Computer Science A course and exam.
1419:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1420:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1421:	1.6 - Compound Assignment Operators........................................................
1422:	   1.6.1 - Develop code for assignment statements with compound assignment operators 
1423:	              and determine the value that is stored in the variable as a result.
1424:	      1.6.1.1 - Compound assignment operators +=, −=, *=, /=, and %= can be used 
1425:	                 in place of the assignment operator in numeric expressions. A compound assignment 
1426:	                 operator performs the indicated arithmetic operation between  the value on 
1427:	                 the left and the value on the right and then assigns the result to the variable 
1428:	                 on the left. 
1429:	      1.6.1.2 - The post-increment operator ++ and postdecrement operator -- are 
1430:	                 used to add 1 or subtract 1 from the stored value of a numeric variable. The 
1431:	                 new value is assigned to the variable. Note: The use of increment and decrement 
1432:	                 operators in prefix form (e.g., ++x) is outside the scope of the AP Computer 
1433:	                 Science A course and exam. The use of increment and decrement operators inside 
1434:	                 other expressions (e.g., arr[x++]) is outside the scope of the AP Computer 
1435:	                 Science A course and exam.
1436:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1437:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1438:	1.7 - Application Program Interface (API) and Libraries....................................
1439:	   1.7.1 - Identify the attributes and behaviors of a class found in the libraries 
1440:	              contained in an API.
1441:	      1.7.1.1 - Libraries are collections of classes. An application programming 
1442:	                 interface (API) specification informs the programmer how to use those classes. 
1443:	                 Documentation found in API specifications and libraries is  essential to understanding 
1444:	                 the attributes and behaviors of a class defined by the API. A class defines 
1445:	                 a specific reference type. Classes in the APIs and libraries are grouped into 
1446:	                 packages. Existing classes and class libraries can be utilized to create objects. 
1447:	      1.7.1.2 - Attributes refer to the data related to the class and are stored 
1448:	                 in variables. Behaviors refer to what instances of the class can do (or what 
1449:	                 can be done with them) and are defined by methods.
1450:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1451:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1452:	1.8 - Documentation with Comments..........................................................
1453:	   1.8.1 - Describe the functionality and use of code through comments.
1454:	      1.8.1.1 - Comments are written for both the original programmer and other 
1455:	                 programmers to understand the code and its functionality, but are ignored 
1456:	                 by the compiler and are not executed when the program is run. Three types 
1457:	                 of comments in Java include /* */, which generates a block of comments; //, 
1458:	                 which generates a comment on one line; and /** */, which are Javadoc comments 
1459:	                 and are used to create API documentation. 
1460:	      1.8.1.2 - A precondition is a condition that must be true just prior to the 
1461:	                 execution of a method in order for it to behave as expected. There is no expectation 
1462:	                 that the method will check to ensure preconditions are satisfied. 
1463:	      1.8.1.3 - A postcondition is a condition that must always be true after the 
1464:	                 execution of a method. Postconditions describe the outcome of the execution 
1465:	                 in terms of what is being returned or the current value of the attributes 
1466:	                 of an object)
1467:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1468:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1469:	1.9 - Method Signatures....................................................................
1470:	   1.9.1 - Identify the correct method to call based on documentation and method 
1471:	              signatures.
1472:	      1.9.1.1 - A method is a named block of code that only runs when it is called. 
1473:	                 A block of code is any section of code that is enclosed in braces. Procedural 
1474:	                 abstraction allows a programmer to use a method by knowing what the method 
1475:	                 does even if they do not know how the method was written. 
1476:	      1.9.1.2 - A parameter is a variable declared in the header of a method or 
1477:	                 constructor and can be used inside the body of the method. This allows values 
1478:	                 or arguments to be passed and used by a method or constructor. A method signature 
1479:	                 for a method with parameters consists of the method name and the ordered list 
1480:	                 of parameter types. A method signature for a method without parameters consists 
1481:	                 of the method name and an empty parameter list)
1482:	   1.9.2 - Describe how to call methods.
1483:	      1.9.2.1 - A void method does not have a return value and is therefore not 
1484:	                 called as part of an expression. 
1485:	      1.9.2.2 - A non-void method returns a value that is the same type as the return 
1486:	                 type in the header. To use the return value when calling a non-void method, 
1487:	                 it must be stored in a variable or used as part of an expression. 
1488:	      1.9.2.3 - An argument is a value that is passed into a method when the method 
1489:	                 is called. The arguments passed to a method must be compatible in number and 
1490:	                 order with the types identified in the parameter list of the method signature. 
1491:	                 When calling methods, arguments are passed using call by value. Call by value 
1492:	                 initializes the parameters with copies of the arguments. 
1493:	      1.9.2.4 - Methods are said to be overloaded when there are multiple methods 
1494:	                 with the same name but different signatures. 
1495:	      1.9.2.5 - A method call interrupts the sequential execution of statements, 
1496:	                 causing the program to first execute the statements in the method before continuing. 
1497:	                 Once the last statement in the method has been executed or a return statement 
1498:	                 is executed, the flow of control is returned to the point immediately following 
1499:	                 where the method was called)
1500:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1501:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1502:	1.10 - Calling Class Methods...............................................................
1503:	   1.10.1 - Develop code to call class methods and determine the result of those 
1504:	              calls.
1505:	      1.10.1.1 - Class methods are associated with the class, not instances of the 
1506:	                 class. Class methods include the keyword static in the header before the method 
1507:	                 name. 
1508:	      1.10.1.2 - Class methods are typically called using the class name along with 
1509:	                 the dot operator. When the method call occurs in the defining class, the use 
1510:	                 of the class name is optional in the call)
1511:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1512:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1513:	1.11 - Math Class..........................................................................
1514:	   1.11.1 - Develop code to write expressions that incorporate calls to built-in 
1515:	              mathematical libraries and determine the value that is produced as a result.
1516:	      1.11.1.1 - The Math class is part of the java.lang package. Classes in the 
1517:	                 java.lang package are available by default. 
1518:	      1.11.1.2 - The Math class contains only class methods. The following Math 
1519:	                 class methods - including what they do and when they are used - are part of 
1520:	                 the Java Quick Reference: (a) static int abs(int x) returns the absolute value 
1521:	                 of an int value. (b) static double abs(double x) returns the absolute value 
1522:	                 of a double value. (c) static double pow(double base, double exponent) returns 
1523:	                 the value of the first parameter raised to the power of the second parameter. 
1524:	                 (d) static double sqrt(double x) returns the nonnegative square root of a 
1525:	                 double value. (e) static double random() returns a double value greater than 
1526:	                 or equal to 0.0 and less than 1.0. 
1527:	      1.11.1.3 - The values returned from Math.random() can be manipulated using 
1528:	                 arithmetic and casting operators toproduce a random int or double in a defined 
1529:	                 range based on specified criteria. Each endpoint of the range can be inclusive, 
1530:	                 meaning the value is included, or exclusive, meaning the value is not included.
1531:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1532:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1533:	1.12 - Objects: Instances of Classes.......................................................
1534:	   1.12.1 - Explain the relationship between a class and an object.
1535:	      1.12.1.1 - An object is a specific instance of a class with defined attributes. 
1536:	                 A class is the formal implementation, or blueprint, of the attributes and 
1537:	                 behaviors of an object.
1538:	      1.12.1.2 - A class hierarchy can be developed by putting common attributes 
1539:	                 and behaviors of related classes into a single class called a superclass. 
1540:	                 Classes that extend a superclass, called subclasses, can draw upon the existing 
1541:	                 attributes and behaviors of the superclass without replacing these in the 
1542:	                 code. This creates an inheritance relationship from the subclasses to the 
1543:	                 superclass. Note: Designing and implementing inheritance relationships are 
1544:	                 outside the scope of the AP Computer Science A course and exam.
1545:	      1.12.1.3 - All classes in Java are subclasses of the Object class.
1546:	   1.12.2 - Develop code to declare variables to store reference types.
1547:	      1.12.2.1 - A variable of a reference type holds an object reference, which 
1548:	                 can be thought of as the memory address of that object.
1549:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1550:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1551:	1.13 - Object Creation and Storage (Instantiation).........................................
1552:	   1.13.1 - Identify, using its signature, the correct constructor being called.
1553:	      1.13.1.1 - A class contains constructors that are called to create objects. 
1554:	                 They have the same name as the class.
1555:	      1.13.1.2 - A constructor signature consists of the constructor's name, which 
1556:	                 is the same as the class name, and the ordered list of parameter types. The 
1557:	                 parameter list, in the header of a constructor, lists the types of the values 
1558:	                 that are passed and their variable names.
1559:	      1.13.1.3 - Constructors are said to be overloaded when there are multiple 
1560:	                 constructors with different signatures.
1561:	   1.13.2 - Develop code to declare variables of the correct types to hold object 
1562:	              references.
1563:	      1.13.2.1 - A variable of a reference type holds an object reference or, if 
1564:	                 there is no object, null
1565:	   1.13.3 - Develop code to create an object by calling a constructor.
1566:	      1.13.3.1 - An object is typically created using the keyword new followed by 
1567:	                 a call to one of the class's constructors.
1568:	      1.13.3.2 - Parameters allow constructors to accept values to establish the 
1569:	                 initial values of the attributes of the object.
1570:	      1.13.3.3 - A constructor argument is a value that is passed into a constructor 
1571:	                 when the constructor is called. The arguments passed to a constructor must 
1572:	                 be compatible in order and number with the types identified in the parameter 
1573:	                 list in the constructor signature. When calling constructors, arguments are 
1574:	                 passed using call by value. Call by value initializes the parameters with 
1575:	                 copies of the arguments.
1576:	      1.13.3.4 - A constructor call interrupts the sequential execution of statements, 
1577:	                 causing the program to first execute the statements in the constructor before 
1578:	                 continuing. Once the last statement in the constructor has been executed, 
1579:	                 the flow of control is returned to the point immediately following where the 
1580:	                 constructor was called.
1581:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1582:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1583:	1.14 - Calling Instance Methods............................................................
1584:	   1.14.1 - Develop code to call instance methods and determine the result of these 
1585:	              calls.
1586:	      1.14.1.1 - Instance methods are called on objects of the class. The dot operator 
1587:	                 is used along with the object name to call instance methods.
1588:	      1.14.1.2 - A method call on a null reference will result in a NullPointerException.
1589:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1590:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1591:	1.15 - String Manipulation.................................................................
1592:	   1.15.1 - Develop code to create string objects and determine the result of creating 
1593:	              and combining strings. 
1594:	      1.15.1.1 - A String object represents a sequence of characters and can be 
1595:	                 created by using a string literal or by calling the String class constructor.
1596:	      1.15.1.2 - The String class is part of the java.lang package. Classes in the 
1597:	                 java.lang package are available by default. 
1598:	      1.15.1.3 - A String object is immutable, meaning once a String object is created, 
1599:	                 its attributes cannot be changed. Methods called on a String object do not 
1600:	                 change the content of the String object.
1601:	      1.15.1.4 - Two String objects can be concatenated together or combined using 
1602:	                 the + or += operator, resulting in a new String object. A primitive value 
1603:	                 can be concatenated with a String object. This causes the implicit conversion 
1604:	                 of the primitive value to a String object.
1605:	      1.15.1.5 - A String object can be concatenated with any object, which implicitly 
1606:	                 calls the object's toString method (a behavior that is guaranteed to exist 
1607:	                 by the inheritance relationship every class has with the Object class). An 
1608:	                 object's toString method returns a string value representing the object. Subclasses 
1609:	                 of Object often override the toString method with class specific implementation. 
1610:	                 Method overriding occurs when a public method in a subclass has the same method 
1611:	                 signature as a public method in the superclass, but the behavior of the method 
1612:	                 is specific to the subclass. Note: Overriding the toString method of a class 
1613:	                 is outside the scope of the AP Computer Science A course and exam.
1614:	   1.15.2 - Develop code to call methods on string objects and determine the result 
1615:	              of calling these methods.
1616:	      1.15.2.1 - A String object has index values from 0 to one less than the length 
1617:	                 of the string. Attempting to access indices outside this range will result 
1618:	                 in an IndexOutOfBoundsException.
1619:	      1.15.2.2 - The following String methods - including what they do and when 
1620:	                 they are used - are part of the Java Quick Reference: (a)  int length() returns 
1621:	                 the number of characters in a String object. (b) String substring(int from, 
1622:	                 int to) returns the substring beginning at index from and ending at index 
1623:	                 to - 1. (c) String substring(int from) returns substring(from, length()). 
1624:	                 (d) int indexOf(String str) returns the index of the first occurrence of str; 
1625:	                 returns -1 if not found. (e) boolean equals(Object other) returns true if 
1626:	                 this corresponds to the same sequence of characters as other; returns false 
1627:	                 otherwise. (f) int compareTo(String other) returns a value < 0 if this is 
1628:	                 less than other; returns zero if this is equal to other; returns a value > 
1629:	                 0 if this is greater than other. Strings are ordered based upon the alphabet. 
1630:	                 Note: Using the equals method to compare one String object with an object 
1631:	                 of a type other than String is outside the scope of the AP Computer Science 
1632:	                 A course and exam1.15.2.3 - A string identical to the single element substring 
1633:	                 at position index can be created by calling substring(index, index + 1).
1634:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1635:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1636:	Computer Science 42SAP - AP curriculum - Unit 2: Selection and Iteration  content running simulated:.
1637:	Unit 2 - Selection and Iteration...........................................................
1638:	2.1 - Algorithms with Selection and Repetition.............................................
1639:	   2.1.1 - Represent patterns and algorithms that involve selection and repetition 
1640:	              found in everyday life using written language or diagrams.
1641:	      2.1.1.1 - The building blocks of algorithms include sequencing, selection, 
1642:	                 and repetition. 
1643:	      2.1.1.2 - Algorithms can contain selection, through decision making, and repetition, 
1644:	                 via looping.
1645:	      2.1.1.3 - Selection occurs when a choice of how the execution of an algorithm 
1646:	                 will proceed is based on a true or false decision.
1647:	      2.1.1.4 - Repetition is when a process repeats itself until a desired outcome 
1648:	                 is reached.
1649:	      2.1.1.5 - The order in which sequencing, selection, and repetition are used 
1650:	                 contributes to the outcome of the algorithm.
1651:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1652:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1653:	2.2 - Boolean Expressions..................................................................
1654:	   2.2.1 - Develop code to create Boolean expressions with relational operators 
1655:	              and determine the result of these expressions.
1656:	      2.2.1.1 - Values can be compared using the relational operators == and != 
1657:	                 to determine whether the values are the same. With primitive types, this compares 
1658:	                 the actual primitive values. With reference types, this compares the object 
1659:	                 references.
1660:	      2.2.1.2 - Numeric values can be compared using the relational operators <, 
1661:	                 >, <=, and >= to determine the relationship between the values.
1662:	      2.2.1.3 - An expression involving relational operators evaluates to a Boolean 
1663:	                 value.
1664:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1665:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1666:	2.3 - if Statements........................................................................
1667:	   2.3.1 - Develop code to represent branching logical processes by using selection 
1668:	              statements and determine the result of these processes.
1669:	      2.3.1.1 - Selection statements change the sequential execution of statements.
1670:	      2.3.1.2 - An if statement is a type of selection statement that affects the 
1671:	                 flow of control by executing different segments of code based on the value 
1672:	                 of a Boolean expression.
1673:	      2.3.1.3 - A one-way selection (if statement) is used when there is a segment 
1674:	                 of code to execute under a certain condition. In this case, the body is executed 
1675:	                 only when the Boolean expression is true.
1676:	      2.3.1.4 - A two-way selection (if-else statement) is used when there are two 
1677:	                 segments of code - one to be executed when the Boolean expression is true 
1678:	                 and another segment for when the Boolean expression is false. In this case, 
1679:	                 the body of the if is executed when the Boolean expression is true, and the 
1680:	                 body of the else is executed when the Boolean expression is false.
1681:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1682:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1683:	2.4 - Nested if Statements.................................................................
1684:	   2.4.1 - Develop code to represent nested branching logical processes and determine 
1685:	              the result of these processes.
1686:	      2.4.1.1 - Nested if statements consist of if, if-else, or if-else-if statements 
1687:	                 within if, if-else, or if-else-if statements.
1688:	      2.4.1.2 - The Boolean expression of the inner nested if statement is evaluated 
1689:	                 only if the Boolean expression of the outer if statement evaluates to true.
1690:	      2.4.1.3 - A multiway selection (if-else-if) is used when there are a series 
1691:	                 of expressions with different segments of code for each condition. Multiway 
1692:	                 selection is performed such that no more than one segment of code is executed 
1693:	                 based on the first expression that evaluates to true. If no expression evaluates 
1694:	                 to true and there is a trailing else statement, then the body of the else 
1695:	                 is executed.
1696:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1697:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1698:	2.5 - Compound Boolean Expressions.........................................................
1699:	   2.5.1 - Develop code to represent compound Boolean expressions and determine 
1700:	              the result of these expressions.
1701:	      2.5.1.1 - Logical operators ! (not), && (and), and || (or) are used with Boolean 
1702:	                 expressions. The expression !a evaluates to true if a is false and evaluates 
1703:	                 to false otherwise. The expression a && b evaluates to true if both a and 
1704:	                 b are true and evaluates to false otherwise. The expression a || b evaluates 
1705:	                 to true if a is true, b is true, or both, and evaluates to false otherwise. 
1706:	                 The order of precedence for evaluating logical operators is ! (not), && (and), 
1707:	                 then || (or). An expression involving logical operators evaluates to a Boolean 
1708:	                 value. 
1709:	      2.5.1.2 - Short-circuit evaluation occurs when the result of a logical operation 
1710:	                 using && or || can be determined by evaluating only the first Boolean expression. 
1711:	                 In this case, the second Boolean expression is not evaluated.
1712:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1713:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1714:	2.6 - Comparing Boolean Expressions........................................................
1715:	   2.6.1 - Compare equivalent Boolean expressions.
1716:	      2.6.1.1 - Two Boolean expressions are equivalent if they evaluate to the same 
1717:	                 value in all cases. Truth tables can be used to prove Boolean expressions 
1718:	                 are equivalent.
1719:	      2.6.1.2 - De Morgan's law can be applied to Boolean expressions to create 
1720:	                 equivalent Boolean expressions. Under De Morgan's law, the Boolean expression 
1721:	                 !(a && b) is equivalent to !a || !b and the Boolean expression !(a || b) is 
1722:	                 equivalent to !a && !b. 
1723:	   2.6.2 - Develop code to compare object references using Boolean expressions and 
1724:	              determine the result of these expressions.
1725:	      2.6.2.1 - Two different variables can hold references to the same object. 
1726:	                 Object references can be compared using == and !=. 
1727:	      2.6.2.2 - An object reference can be compared with null, using == or !=, to 
1728:	                 determine if the reference actually references an object. 
1729:	      2.6.2.3 - Classes often define their own equals method, which can be used 
1730:	                 to specify the criteria for equivalency for two objects of the class. The 
1731:	                 equivalency of two objects is most often determined using attributes from 
1732:	                 the two objects. Note: Overriding the equals method is outside the scope of 
1733:	                 the AP Computer Science A course and exam.
1734:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1735:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1736:	2.7 - while Loops..........................................................................
1737:	   2.7.1 - Identify when an iterative process is required to achieve a desired result.
1738:	      2.7.1.1 - Iteration is a form of repetition. Iteration statements change the 
1739:	                 flow of control by repeating a segment of code zero or more times as long 
1740:	                 as the Boolean expression controlling the loop evaluates to true. 
1741:	      2.7.1.2 - An infinite loop occurs when the Boolean expression in an iterative 
1742:	                 statement always evaluates to true.
1743:	      2.7.1.3 - The loop body of an iterative statement will not execute if the 
1744:	                 Boolean expression initially evaluates to false.
1745:	      2.7.1.4 - Off by one errors occur when the iteration statement loops one time 
1746:	                 too many or one time too few.
1747:	   2.7.2 - Develop code to represent iterative processes using while loops and determine 
1748:	              the result of these processes.
1749:	      2.7.2.1 - A while loop is a type of iterative statement. In while loops, the 
1750:	                 Boolean expression is evaluated before each iteration of the loop body, including 
1751:	                 the first. When the expression evaluates to true, the loop body is executed. 
1752:	                 This continues until the Boolean expression evaluates to false, whereupon 
1753:	                 the iteration terminates.
1754:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1755:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1756:	2.8 - for Loops............................................................................
1757:	   2.8.1 - Develop code to represent iterative processes using for loops and determine 
1758:	              the result of these processes.
1759:	      2.8.1.1 - A for loop is a type of iterative statement. There are three parts 
1760:	                 in a for loop header: the initialization, the Boolean expression, and the 
1761:	                 update.
1762:	      2.8.1.2 - In a for loop, the initialization statement is only executed once 
1763:	                 before the first Boolean expression evaluation. The variable being initialized 
1764:	                 is referred to as a loop control variable. The Boolean expression is evaluated 
1765:	                 immediately after the loop control variable is initialized and then following 
1766:	                 each execution of the increment statement until it is false. In each iteration, 
1767:	                 the update is executed after the entire loop body is executed and before the 
1768:	                 Boolean expression is evaluated again.
1769:	      2.8.1.3 - A for loop can be rewritten into an equivalent while loop (and vice 
1770:	                 versa).
1771:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1772:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1773:	2.9 - Implementing Selection and Iteration Algorithms......................................
1774:	   2.9.1 - Develop code for standard and original algorithms (without data structures) 
1775:	              and determine the result of these algorithms.
1776:	      2.9.1.1 - There are standard algorithms to: (a) identify if an integer is 
1777:	                 or is not evenly divisible by another integer (b)  identify the individual 
1778:	                 digits in an integer, (c) determine the frequency with which a specific criterion 
1779:	                 is met (d) determine a minimum or maximum value, and (e) compute a sum or 
1780:	                 average
1781:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1782:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1783:	2.10 - Implementing String Algorithms......................................................
1784:	   2.10.1 - Develop code for standard and original algorithms that involve strings 
1785:	              and determine the result of these algorithms. 
1786:	      2.10.1.1 - There are standard string algorithms to: (a) find if one or more 
1787:	                 substrings have a particular property, (b)  determine the number of substrings 
1788:	                 that meet specific criteria, (c) create a new string with the characters reversed
1789:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1790:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1791:	2.11 - Nested Iteration....................................................................
1792:	   2.11.1 - Develop code to represent nested iterative processes and determine the 
1793:	              result of these processes.
1794:	      2.11.1.1 - Nested iteration statements are iteration statements that appear 
1795:	                 in the body of another iteration statement. When a loop is nested inside another 
1796:	                 loop, the inner loop must complete all its iterations before the outer loop 
1797:	                 can continue to its next iteration.
1798:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1799:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1800:	2.12 - Informal Run-Time Analysis..........................................................
1801:	   2.12.1 - Calculate statement execution counts and informal run-time comparison 
1802:	              of iterative statements.
1803:	      2.12.1.1 - A statement execution count indicates the number of times a statement 
1804:	                 is executed by the program. Statement execution counts are often calculated 
1805:	                 informally through tracing and analysis of the iterative statements.
1806:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1807:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1808:	Computer Science 42SAP - AP curriculum - Unit 3: Class Creation content running simulated:.
1809:	Unit 3 - Class Creation....................................................................
1810:	3.1 - Abstraction and Program Design.......................................................
1811:	   3.1.1 - Represent the design of a program by using natural language or creating 
1812:	              diagrams that indicate the classes in the program and the data and procedural 
1813:	              abstractions found in each class by including all attributes and behaviors. 
1814:	      3.1.1.1 - Abstraction is the process of reducing complexity by focusing on 
1815:	                 the main idea. By hiding details irrelevant to the question at hand and bringing 
1816:	                 together related and useful details, abstraction reduces complexity and allows 
1817:	                 one to focus on the idea.
1818:	      3.1.1.2 - Data abstraction provides a separation between the abstract properties 
1819:	                 of a data type and the concrete details of its  representation. Data abstraction 
1820:	                 manages complexity by giving data a name without referencing the specific 
1821:	                 details of the representation.  Data can take the form of a single variable 
1822:	                 or a collection of data, such as in a class or a set of data.
1823:	      3.1.1.3 - An attribute is a type of data abstraction that is defined in a 
1824:	                 class outside any method or constructor. An instance variable is an attribute 
1825:	                 whose value is unique to each instance of the class. A class variable is an 
1826:	                 attribute shared by all instances of the class.
1827:	      3.1.1.4 - Procedural abstraction provides a name for a process and allows 
1828:	                 a method to be used only knowing what it does, not how it does it. Through 
1829:	                 method decomposition, a programmer breaks down larger behaviors of the class 
1830:	                 into smaller behaviors by creating methods to represent each individual smaller 
1831:	                 behavior. A procedural abstraction may extract shared features to generalize 
1832:	                 functionality instead of duplicating code. This allows for code reuse, which 
1833:	                 helps manage complexity 
1834:	      3.1.1.5 - Using parameters allows procedures to be generalized, enabling the 
1835:	                 procedures to be reused with a range of input values or arguments.
1836:	      3.1.1.6 - Using procedural abstraction in a program allows programmers to 
1837:	                 change the internals of a method (to make it faster, more  efficient, use 
1838:	                 less storage, etc.) without needing to notify method users of the change as 
1839:	                 long as the method signature and what the  method does is preserved.
1840:	      3.1.1.7 - Prior to implementing a class, it is helpful to take time to design 
1841:	                 each class including its attributes and behaviors. This design can be represented 
1842:	                 using natural language or diagrams.
1843:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1844:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1845:	3.2 - Impact of Program Design.............................................................
1846:	   3.2.1 - Explain the social and ethical implications of computing systems.
1847:	      3.2.1.1 - System reliability refers to the program being able to perform its 
1848:	                 tasks as expected under stated conditions without failure. Programmers should 
1849:	                 make an effort to maximize system reliability by testing the program with 
1850:	                 a variety of conditions.
1851:	      3.2.1.2 - The creation of programs has impacts on society, the economy, and 
1852:	                 culture. These impacts can be both beneficial and harmful. Programs meant 
1853:	                 to fill a need or solve a problem can have unintended harmful effects beyond 
1854:	                 their intended use.
1855:	      3.2.1.3 - Legal issues and intellectual property concerns arise when creating 
1856:	                 programs. Programmers often reuse code written by others and published as 
1857:	                 open source and free to use. Incorporation of code that is not published as 
1858:	                 open source requires the programmer to obtain permission and often purchase 
1859:	                 the code before integrating it into their program.
1860:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1861:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1862:	3.3 - Anatomy of a Class...................................................................
1863:	   3.3.1 - Develop code to designate access and visibility constraints to classes, 
1864:	              data, constructors, and methods. 
1865:	      3.3.1.1 - Data encapsulation is a technique in which the implementation details 
1866:	                 of a class are kept hidden from external classes. The keywords public and 
1867:	                 private affect the access of classes, data, constructors, and methods. The 
1868:	                 keyword private restricts access to the declaring class, while the keyword 
1869:	                 public allows access from classes outside the declaring class.
1870:	      3.3.1.2 - In this course, classes are always designated public and are declared 
1871:	                 with the keyword class. 
1872:	      3.3.1.3 - In this course, constructors are always designated public.
1873:	      3.3.1.4 - Instance variables belong to the object, and each object has its 
1874:	                 own copy of the variable. 
1875:	      3.3.1.5 - Access to attributes should be kept internal to the class in order 
1876:	                 to accomplish encapsulation.  Therefore, it is good programming practice to 
1877:	                 designate the instance variables for these attributes as private unless the 
1878:	                 class specification states otherwise.
1879:	      3.3.1.6 - Access to behaviors can be internal or external to the class. Methods 
1880:	                 designated as public can be accessed internally or externally to a class, 
1881:	                 whereas methods designated as private can only be accessed internally to the 
1882:	                 class
1883:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1884:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1885:	3.4 - Constructors.........................................................................
1886:	   3.4.1 - Develop code to declare instance variables for the attributes to be initialized 
1887:	              in the body of the constructors of a class.
1888:	      3.4.1.1 - An object's state refers to its attributes and their values at a 
1889:	                 given time and is defined by instance variables belonging to the object. This 
1890:	                 defines a has-a relationship between the object and its instance variables. 
1891:	      3.4.1.2 - A constructor is used to set the initial state of an object, which 
1892:	                 should include initial values for all instance variables. When a constructor 
1893:	                  is called, memory is allocated for the object and the associated object reference 
1894:	                 is returned. Constructor parameters, if specified, provide data to  initialize 
1895:	                 instance variables.
1896:	      3.4.1.3 - When a mutable object is a constructor parameter, the instance variable 
1897:	                 should be initialized with a copy of the referenced object. In this way, the 
1898:	                 instance variable does not hold a reference to the original object, and methods 
1899:	                 are prevented from modifying the state of the original object.
1900:	      3.4.1.4 - When no constructor is written, Java provides a no-parameter constructor, 
1901:	                 and the instance variables are set to default values according to the data 
1902:	                 type of the attribute. This constructor is called the default constructor. 
1903:	      3.4.1.5 - The default value for an attribute of type int is 0. The default 
1904:	                 value of an attribute of type double is 0.0. The default value of an attribute 
1905:	                 of type boolean is false. The default value of a reference type is null.
1906:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1907:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1908:	3.5 - Methods: How to Write Them...........................................................
1909:	   3.5.1 - Develop code to define behaviors of an object through methods written 
1910:	              in a class using primitive values and determine the result of calling these methods.
1911:	      3.5.1.1 - A void method does not return a value. Its header contains the keyword 
1912:	                 void before the method name.
1913:	      3.5.1.2 - A non-void method returns a single value. Its header includes the 
1914:	                 return type in place of the keyword void.
1915:	      3.5.1.3 - In non-void methods, a return expression compatible with the return 
1916:	                 type is evaluated, and the value is returned. This is referred to as return 
1917:	                 by value.
1918:	      3.5.1.4 - The return keyword is used to return the flow of control to the 
1919:	                 point where the method or constructor was called. Any code that is sequentially 
1920:	                 after a return statement will never be executed. Executing a return statement 
1921:	                 inside a selection or iteration statement will halt the statement and exit 
1922:	                 the method or constructor.
1923:	      3.5.1.5 - An accessor method allows objects of other classes to obtain a copy 
1924:	                 of the value of instance variables or class variables. An accessor method 
1925:	                 is a non-void method. 
1926:	      3.5.1.6 - A mutator (modifier) method is a method that changes the values 
1927:	                 of the instance variables or class variables. A mutator method is often a 
1928:	                 void method.
1929:	      3.5.1.7 - Methods with parameters receive values through those parameters 
1930:	                 and use those values in accomplishing the method's task.
1931:	      3.5.1.8 - When an argument is a primitive value, the parameter is initialized 
1932:	                 with a copy of that value. Changes to the parameter have no effect on the 
1933:	                 corresponding argument.
1934:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1935:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1936:	3.6 - Methods: Passing and Returning References of an Object...............................
1937:	   3.6.1 - Develop code to define behaviors of an object through methods written 
1938:	              in a class using object references and determine the result of calling these 
1939:	              methods.
1940:	      3.6.1.1 - When an argument is an object reference, the parameter is initialized 
1941:	                 with a copy of that reference; it does not create a new independent copy of 
1942:	                 the object. If the parameter refers to a mutable object, the method or constructor 
1943:	                 can use this reference to alter the state of the object. It is good  programming 
1944:	                 practice to not modify mutable objects that are passed as parameters unless 
1945:	                 required in the specification.
1946:	      3.6.1.2 - When the return expression evaluates to an object reference, the 
1947:	                 reference is returned, not a reference to a new copy of the object. 
1948:	      3.6.1.3 - Methods cannot access the private data and  methods of a parameter 
1949:	                 that holds a reference to an object unless the parameter is the same type 
1950:	                 as the method's enclosing class
1951:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1952:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1953:	3.7 - Class Variables and Methods..........................................................
1954:	   3.7.1 - Develop code to define behaviors of a class through class methods.
1955:	      3.7.1.1 - Class methods cannot access or change the values of instance variables 
1956:	                 or call instance methods without being passed an instance of the class via 
1957:	                 a parameter.
1958:	      3.7.1.2 - Class methods can access or change the values of class variables 
1959:	                 and can call other class methods.
1960:	   3.7.2 - Develop code to declare the class variables that belong to the class.
1961:	      3.7.2.1 - Class variables belong to the class, with all objects of a class 
1962:	                 sharing a single copy of the class variable. Class variables are designated 
1963:	                 with the static keyword before the variable type.
1964:	      3.7.2.2 - Class variables that are designated public are accessed outside 
1965:	                 of the class by using the class name and the dot operator, since they are 
1966:	                 associated with a class, not objects of a class.
1967:	      3.7.2.3 - When a variable is declared final, its value cannot be modified.
1968:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1969:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1970:	3.8 - Scope and Access.....................................................................
1971:	   3.8.1 - Explain where variables can be used in the code.
1972:	      3.8.1.1 - Local variables are variables declared in the headers or bodies 
1973:	                 of blocks of code. Local variables can only be accessed in the block in which 
1974:	                 they are declared. Since constructors and methods are blocks of code, parameters 
1975:	                 to constructors or methods are also considered local variables. These variables 
1976:	                 may only be used within the constructor or method and cannot be declared to 
1977:	                 be public or private.
1978:	      3.8.1.2 - When there is a local variable or parameter with the same name as 
1979:	                 an instance variable, the variable name will refer to the local variable instead 
1980:	                 of the instance variable within the body of the constructor or method.
1981:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1982:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1983:	3.9 - this Keyword.........................................................................
1984:	   3.9.1 - Develop code for expressions that are self-referencing and determine 
1985:	              the result of these expressions.
1986:	      3.9.1.1 - Within an instance method or a constructor, the keyword this acts 
1987:	                 as a special variable that holds a reference to the current object - the object 
1988:	                 whose method or constructor is being called.
1989:	      3.9.1.2 - The keyword this can be used to pass the current object as an argument 
1990:	                 in a method call. 
1991:	      3.9.1.3 - Class methods do not have a this reference.
1992:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1993:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1994:	Computer Science 42SAP - AP curriculum - Unit 4: Data Collections content running simulated:.
1995:	Unit 4 - Data Collections..................................................................
1996:	4.1 - Ethical and Social Issues Around Data Collection.....................................
1997:	   4.1.1 - Explain the risks to privacy from collecting and storing personal data 
1998:	              on computer systems.
1999:	      4.1.1.1 - When using a computer, personal privacy is at risk. When developing 
2000:	                 new programs, programmers should attempt to safeguard the personal privacy 
2001:	                 of the user.
2002:	   4.1.2 - Explain the importance of recognizing data quality and potential issues 
2003:	              when using a data set.
2004:	      4.1.2.1 - Algorithmic bias describes systemic and repeated errors in a program 
2005:	                 that create unfair outcomes for a specific group of users.
2006:	      4.1.2.2 - Programmers should be aware of the data set collection method and 
2007:	                 the potential for bias when using this method before using  the data to extrapolate 
2008:	                 new information or drawing conclusions.
2009:	      4.1.2.3 - Some data sets are incomplete or contain inaccurate data. Using 
2010:	                 such data in the development or use of a program can cause the program to 
2011:	                 work incorrectly or inefficiently. 
2012:	   4.1.3 - Identify an appropriate data set to use in order to solve a problem or 
2013:	              answer a specific question.
2014:	      4.1.3.1 - Contents of a data set might be related to a specific question or 
2015:	                 topic and might not be appropriate to give correct answers or extrapolate 
2016:	                 information for a different question or topic.
2017:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2018:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2019:	4.2 - Introduction to Using Data Sets......................................................
2020:	   4.2.1 - Represent patterns and algorithms that involve data sets found in everyday 
2021:	              life using written language or diagrams.
2022:	      4.2.1.1 - A data set is a collection of specific pieces of information or 
2023:	                 data.
2024:	      4.2.1.2 - Data sets can be manipulated and analyzed to solve a problem or 
2025:	                 answer a question. When analyzing data sets, values within the set are accessed 
2026:	                 and utilized one at a time and then processed according to the desired outcome.
2027:	      4.2.1.3 - Data can be represented in a diagram by using a chart or table. 
2028:	                 This visual can be used to plan the algorithm that will be used to manipulate 
2029:	                 the data
2030:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2031:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2032:	4.3 - Array Creation and Access............................................................
2033:	   4.3.1 - Develop code used to represent collections of related data using one 
2034:	              dimensional (1D) array objects.
2035:	      4.3.1.1 - An array stores multiple values of the same type. The values can 
2036:	                 be either primitive values or object references. 
2037:	      4.3.1.2 - The length of an array is established at the time of creation and 
2038:	                 cannot be changed. The length of an array can be accessed through the length 
2039:	                 attribute.
2040:	      4.3.1.3 - When an array is created using the keyword new, all of its elements 
2041:	                 are initialized to the default values for the element data type. The  default 
2042:	                 value for int is 0, for double is 0.0, for boolean is false, and for a reference 
2043:	                 type is null. 
2044:	      4.3.1.4 - Initializer lists can be used to create and initialize arrays.
2045:	      4.3.1.5 - Square brackets [ ] are used to access and modify an element in 
2046:	                 a 1D array using an index. 
2047:	      4.3.1.6 - The valid index values for an array are 0 through one less than 
2048:	                 the length of the array, inclusive. Using an index value outside of this range 
2049:	                 will result in an ArrayIndexOutOfBoundsException.
2050:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2051:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2052:	4.4 - Array Traversals.....................................................................
2053:	   4.4.1 - Develop code used to traverse the elements in a 1D array and determine 
2054:	              the result of these traversals.
2055:	      4.4.1.1 - Traversing an array is when repetition statements are used to access 
2056:	                 all or an ordered sequence of elements in an array. 
2057:	      4.4.1.2 - Traversing an array with an indexed for loop or while loop requires 
2058:	                 elements to be accessed using their indices.
2059:	      4.4.1.3 - An enhanced for loop header includes a variable, referred to as 
2060:	                 the enhanced for loop variable. For each iteration of the enhanced for loop, 
2061:	                  the enhanced for loop variable is assigned a copy of an element without using 
2062:	                 its index. 
2063:	      4.4.1.4 - Assigning a new value to the enhanced for loop variable does not 
2064:	                 change the value stored in the array.
2065:	      4.4.1.5 - When an array stores object references, the attributes can be modified 
2066:	                 by calling methods on the enhanced for loop variable. This does not change 
2067:	                 the object references stored in the array.
2068:	      4.4.1.6 - Code written using an enhanced for loop to traverse elements in 
2069:	                 an array can be rewritten using an indexed for loop or a while loop.
2070:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2071:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2072:	4.5 - Implementing Array Algorithms........................................................
2073:	   4.5.1 - Develop code for standard and original algorithms for a particular context 
2074:	              or specification that involves arrays and determine the result of these algorithms. 
2075:	      4.5.1.1 - There are standard algorithms that utilize array traversals to: 
2076:	                 (a) determine a minimum or maximum value, (b) compute a sum or average, (d) 
2077:	                 determine if at least one element has a particular property, (e) determine 
2078:	                 if all elements have a particular property, (f) determine the number of elements 
2079:	                 having a particular property, (g) access all consecutive pairs of elements, 
2080:	                 (h) determine the presence or absence of duplicate elements, (i) shift or 
2081:	                 rotate elements left or right, (j) reverse the order of the elements
2082:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2083:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2084:	4.6 - Using Text Files.....................................................................
2085:	   4.6.1 - Develop code to read data from a text file.
2086:	      4.6.1.1 - A file is storage for data that persists when the program is not 
2087:	                 running. The data in a file can be retrieved during program execution.
2088:	      4.6.1.2 - A file can be connected to the program using the File and Scanner 
2089:	                 classes.
2090:	      4.6.1.3 - A file can be opened by creating a File object, using the name of 
2091:	                 the file as the argument of the constructor. File(String str) is the File 
2092:	                 constructor that accepts a String file name to open for reading, where str 
2093:	                 is the pathname for the file.
2094:	      4.6.1.4 - When using the File class, it is required to indicate what to do 
2095:	                 if the file with the provided name cannot be opened. One way to accomplish 
2096:	                 this is to add throws IOException to the header of the method that uses the 
2097:	                 file. If the file name is invalid, the program will terminate.
2098:	      4.6.1.5 - The File and IOException classes are part of the java.io package. 
2099:	                 An import statement must be used to make these classes available for use in 
2100:	                  the program
2101:	      4.6.1.6 - Scanner methods are part of Java Quick Reference: (a) Scanner(File 
2102:	                 f) is the Scanner constructor that accepts a File for reading. (b)int nextInt() 
2103:	                 returns the next int read from the file or input source if available. If the 
2104:	                 next int does not exist or is out of range, it will result in an InputMismatchException. 
2105:	                 (c) double nextDouble() returns the next  double read from the file or input 
2106:	                 source. If the next double does not exist, it will result in an InputMismatchException. 
2107:	                 (d) boolean nextBoolean() returns the next boolean read from the file or input 
2108:	                 source. If the next boolean does not exist, it will result in an InputMismatchException. 
2109:	                 (e) String nextLine() returns the next line of text as a String read from 
2110:	                 the file or input source; can return the empty string if called immediately 
2111:	                 after another Scanner method that is reading from the file or input source. 
2112:	                 (f) String next() returns the next String read from the file or input source. 
2113:	                 (g)  boolean hasNext() returns true if ehere is a next item to read in the 
2114:	                 file or input source; returns false otherwise. (h) void close() closes this 
2115:	                 scanner. Note: accepting input from the keyboard is outside the scope of the 
2116:	                 AP Computer Science A course and exam.
2117:	      4.6.1.7 - Using nextLine and the other Scanner methods together on the same 
2118:	                 input source sometimes requires code to adjust for the methods' different 
2119:	                 ways of handling whitespace. Note: Writing or analyzing code that uses both 
2120:	                 nextLine and other Scanner methods on the same input source is outside the 
2121:	                 scope of the AP Computer Science A course and exam.
2122:	      4.6.1.8 - The following additional String method - including what it does 
2123:	                 and when it is used - is part of the Java Quick Reference: (a) String[] split(String 
2124:	                 del returns a String array where each element is a substring of this String, 
2125:	                 which has been split around matches of the given expression del. Note: The 
2126:	                 parameter del uses a format called a regular expression. Writing or analyzing 
2127:	                 code that uses any of the special properties of regular expressions (e.g., 
2128:	                 \\*, \\.) is outside the scope of the AP Computer Science A course and exam. 
2129:	      4.6.1.9 - A while loop can be used to detect if the file still contains elements 
2130:	                 to read by using the hasNext method as the condition of the loop.
2131:	      4.6.1.10 - A file should be closed when the program is finished using it. 
2132:	                 The close method from Scanner is called to close the file.
2133:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2134:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2135:	4.7 - Wrapper Classes......................................................................
2136:	   4.7.1 - Develop code to use Integer and Double objects from their primitive counterparts 
2137:	              and determine the result of using these objects.
2138:	      4.7.1.1 - The Integer class and Double class are part of the java.lang package. 
2139:	                 An Integer object is immutable, meaning once an Integer object is created, 
2140:	                 its attributes cannot be changed. A Double object is immutable, meaning once 
2141:	                 a Double object is created, its attributes cannot be changed. 
2142:	      4.7.1.2 - Autoboxing is the automatic conversion that the Java compiler makes 
2143:	                 between primitive types and their corresponding object wrapper classes. This 
2144:	                 includes converting an int to an Integer and a double to a Double. The Java 
2145:	                 compiler applies autoboxing when a primitive value is: (a) passed as a parameter 
2146:	                 to a method that expects an object of the corresponding wrapper class (b) 
2147:	                 assigned to a variable of the corresponding wrapper class 
2148:	      4.7.1.3 - Unboxing is the automatic conversion that the Java compiler makes 
2149:	                 from the wrapper class to the primitive type. This includes converting an 
2150:	                 Integer to an int and a Double to a double. The Java compiler applies unboxing 
2151:	                 when a wrapper class object is: (a) passed as a parameter to a method that 
2152:	                 expects a value of the corresponding primitive type (b) assigned to a variable 
2153:	                 of the corresponding primitive type 
2154:	      4.7.1.4 - The following class Integer method - including what it does and 
2155:	                 when it is used - is part of the Java Quick Reference: (a) static int parseInt(String 
2156:	                 s) returns the String argument as an int. 
2157:	      4.7.1.5 - The following class Double method - including what it does and when 
2158:	                 it is used - is part of the Java Quick Reference: (a) static double parseDouble(String 
2159:	                 s) returns the String argument as a double.
2160:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2161:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2162:	4.8 - ArrayList Methods....................................................................
2163:	   4.8.1 - Develop code for collections of related objects using ArrayList objects 
2164:	              and determine the result of calling methods on these objects. 
2165:	      4.8.1.1 - An ArrayList object is mutable in size and contains object references. 
2166:	      4.8.1.2 - The ArrayList constructor ArrayList() constructs an empty list. 
2167:	      4.8.1.3 - Java allows the generic type ArrayList<E>, where the type parameter 
2168:	                 E specifies the type of the elements. When ArrayList<E> is specified, the 
2169:	                 types of the reference parameters and return type when using the ArrayList 
2170:	                 methods are type E. ArrayList<E> is preferred over ArrayList. For example, 
2171:	                 ArrayList<String> names = new ArrayList<String>(); allows the compiler to 
2172:	                 find errors that would otherwise be found at run-time.
2173:	      4.8.1.4 - The ArrayList class is part of the java.util package. An import 
2174:	                 statement must be used to make this class available for use in the program. 
2175:	      4.8.1.5 - The following ArrayList methods - including what they do and when 
2176:	                 they are used - are part of the Java Quick Reference: (a) int size() returns 
2177:	                 the number of elements in the list. (b) boolean add(E obj) appends obj to 
2178:	                 end of list; returns true. (c) void add(int index, E obj) inserts obj at position 
2179:	                 index (0 <= index <= size), moving elements at position index and higher to 
2180:	                 the right (adds 1 to their indices) and adds 1 to size. (d) E get(int index) 
2181:	                 returns the element at position index in the list. (e) E set(int index, E 
2182:	                 obj) replaces the element at position index with obj; returns the element 
2183:	                 formerly at position index. (f) E remove(int index) removes element from position 
2184:	                 index, moving elements at position index + 1 and higher to the left (subtracts 
2185:	                 1 from their indices) and subtracts 1 from size; returns the element formerly 
2186:	                 at position index.
2187:	      4.8.1.6 - The indices for an ArrayList start at 0 and end at the number of 
2188:	                 elements - 1
2189:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2190:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2191:	4.9 - ArrayList Traversals.................................................................
2192:	   4.9.1 - Develop code used to traverse the elements of an ArrayList and determine 
2193:	              the results of these traversals.
2194:	      4.9.1.1 - Traversing an ArrayList is when iteration or recursive statements 
2195:	                 are used to access all or an ordered sequence of the elements in an ArrayList.
2196:	      4.9.1.2 - Deleting elements during a traversal of an ArrayList requires the 
2197:	                 use of special techniques to avoid skipping elements. 
2198:	      4.9.1.3 - Attempting to access an index value outside of its range will result 
2199:	                 in an IndexOutOfBoundsException. 
2200:	      4.9.1.4 - Changing the size of an ArrayList while traversing it using an enhanced 
2201:	                 for loop can result in a ConcurrentModificationException. Therefore, when 
2202:	                 using an enhanced for loop to traverse an ArrayList, you should not add or 
2203:	                 remove elements.
2204:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2205:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2206:	4.10 - Implementing ArrayList Algorithms...................................................
2207:	   4.10.1 - Develop code for standard and original algorithms for a particular context 
2208:	              or specification that involve ArrayList objects and determine the result of these 
2209:	              algorithms.
2210:	      4.10.1.1 - There are standard ArrayList algorithms that utilize traversals 
2211:	                 to: (a) determine a minimum or maximum value (b) compute a sum or average 
2212:	                 (c) determine if at least one element has a particular property (d) determine 
2213:	                 if all elements have a particular property (e) determine the number of elements 
2214:	                 having a particular property (f) access all consecutive pairs of elements 
2215:	                 (g) determine the presence or absence of duplicate elements (h) shift or rotate 
2216:	                 elements left or right (i) reverse the order of the elements (j)  insert elements 
2217:	                 (k)  delete elements
2218:	      4.10.1.2 - Some algorithms require multiple String, array, or ArrayList objects 
2219:	                 to be traversed simultaneously.
2220:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2221:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2222:	4.11 - 2D Array Creation and Access........................................................
2223:	   4.11.1 - Develop code used to represent collections of related data using twodimensional 
2224:	              (2D) array objects.
2225:	      4.11.1.1 - A 2D array is stored as an array of arrays. Therefore, the way 
2226:	                 2D arrays are created and indexed is similar to 1D array objects. The size 
2227:	                 of a 2D array is established at the time of creation and cannot be changed. 
2228:	                 2D arrays can store either primitive data or object reference data. Note: 
2229:	                 Nonrectangular 2D array objects are outside the scope of the AP Computer Science 
2230:	                 A course and exam.
2231:	      4.11.1.2 - When a 2D array is created using the keyword new, all of its elements 
2232:	                 are initialized to the default values for the element data type. The default 
2233:	                 value for int is 0, for double is 0.0, for boolean is false, and for a reference 
2234:	                 type is null. 
2235:	      4.11.1.3 - The initializer list used to create and initialize a 2D array consists 
2236:	                 of initializer lists that represent 1D arrays; for example, int[][] arr2D 
2237:	                 = { {1, 2, 3}, {4, 5, 6} };.
2238:	      4.11.1.4 - The square brackets [row][col] are used to access and modify an 
2239:	                 element in a 2D array. For the purposes of the exam, when accessing the element 
2240:	                 at arr[first][second], the first index is used for rows, the second index 
2241:	                 is used for columns.
2242:	      4.11.1.5 - A single array that is a row of a 2D array can be accessed using 
2243:	                 the 2D array name and a single set of square brackets containing the row index. 
2244:	      4.11.1.6 - The number of rows contained in a 2D array can be accessed through 
2245:	                 the length attribute. The valid row index values for a 2D array are 0 through 
2246:	                 one less than the number of rows or the length of the array, inclusive. The 
2247:	                 number of columns contained in a 2D array can be accessed through the length 
2248:	                 attribute of one of the rows. The valid column index values for a 2D array 
2249:	                 are 0 through one less than the number of columns or the length of any given 
2250:	                 row of the array, inclusive. For example, given a 2D array named values, the 
2251:	                 number of rows is  values. length and the number of columns is values[0].length. 
2252:	                 Using an index value outside of these ranges will result in an ArrayIndexOutOfBoundsException.
2253:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2254:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2255:	4.12 - 2D Array Traversals.................................................................
2256:	   4.12.1 - Develop code used to traverse the elements in a 2D array and determine 
2257:	              the result of these traversals.
2258:	      4.12.1.1 - Nested iteration statements are used to traverse and access all 
2259:	                 or an ordered sequence of elements in a 2D array. Since 2D arrays are stored 
2260:	                 as arrays of arrays, the way 2D arrays are traversed using for loops and enhanced 
2261:	                 for loops is similar to 1D array objects. Nested iteration statements can 
2262:	                 be written to traverse the 2D array in row-major order, column-major order, 
2263:	                 or a uniquely defined order. Row-major order refers to an ordering of 2D array 
2264:	                 elements where traversal occurs across each row, whereas columnmajor order 
2265:	                  traversal occurs down each column.
2266:	      4.12.1.2 - The outer loop of a nested enhanced for loop used to traverse a 
2267:	                 2D array traverses the rows. Therefore, the enhanced for loop variable must 
2268:	                 be the type of each row, which is a 1D array. The inner loop traverses a single 
2269:	                 row. Therefore, the inner enhanced for loop variable must be the same type 
2270:	                 as the elements stored in the 1D array. Assigning a new value to  the enhanced 
2271:	                 for loop variable does not change the value stored in the array. 
2272:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2273:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2274:	4.13 - Implementing 2D Array Algorithms....................................................
2275:	   4.13.1 - Develop code for standard and original algorithms for a particular context 
2276:	              or specification that involves 2D arrays and determine the result of these algorithms.
2277:	      4.13.1.1 - There are standard algorithms that utilize 2D array traversals 
2278:	                 to: (a) determine a minimum or maximum value of all the elements or for a 
2279:	                 designated row, column, or other subsection (b) compute a sum or average of 
2280:	                 all the elements or for a designated row, column, or other subsection (c) 
2281:	                 determine if at least one element has a particular property in the entire 
2282:	                 2D array or for a designated row, column, or other subsection (d) determine 
2283:	                 if all elements of the 2D array or a designated row, column, or other subsection 
2284:	                 have a particular property (e) determine the number of elements in the 2D 
2285:	                 array or in a designated row, column, or other subsection having a particular 
2286:	                 property (f) access all consecutive pairs of elements (g) determine the presence 
2287:	                 or absence of duplicate elements in the 2D array or in a designated row, column, 
2288:	                 or other subsection (h) shift or rotate elements in a row left or right or 
2289:	                 in a column up or down (i) reverse the order of the elements in a row or column
2290:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2291:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2292:	4.14 - Searching Algorithms................................................................
2293:	   4.14.1 - Develop code used for linear search algorithms to search for specific 
2294:	              information in a collection and determine the results of executing a search.
2295:	      4.14.1.1 - Linear search algorithms are standard algorithms that check each 
2296:	                 element in order until the desired value is found or all elements in the array 
2297:	                 or ArrayList have been checked. Linear search algorithms can begin the search 
2298:	                 process from either end of the array or ArrayList.
2299:	      4.14.1.2 - When applying linear search algorithms to 2D arrays, each row must 
2300:	                 be accessed then linear search applied to each row of the 2D array.
2301:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2302:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2303:	4.15 - Sorting Algorithms..................................................................
2304:	   4.15.1 - Determine the result of executing each step of sorting algorithms to 
2305:	              sort the elements of a collection.
2306:	      4.15.1.1 - Selection sort and insertion sort are iterative sorting algorithms 
2307:	                 that can be used to sort elements in an array or ArrayList. 
2308:	      4.15.1.2 - Selection sort repeatedly selects the smallest (or largest) element 
2309:	                 from the unsorted portion of the list and swaps it into its correct (and final) 
2310:	                 position in the sorted portion of the list.
2311:	      4.15.1.3 - Insertion sort inserts an element from the unsorted portion of 
2312:	                 a list into its correct (but not necessarily final) position in the sorted 
2313:	                 portion of the list by shifting elements of the sorted portion to make room 
2314:	                 for the new element.
2315:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2316:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2317:	4.16 - Recursion...........................................................................
2318:	   4.16.1 - Determine the result of calling recursive methods.
2319:	      4.16.1.1 - A recursive method is a method that calls itself. Recursive methods 
2320:	                 contain at least one base case, which halts the recursion, and at least one 
2321:	                 recursive call. Recursion is another form of repetition.
2322:	      4.16.1.2 - Each recursive call has its own set of local variables, including 
2323:	                 the parameters. Parameter values capture the progress of a recursive process, 
2324:	                 much like loop control variable values capture the progress of a loop. 
2325:	      4.16.1.3 - Any recursive solution can be replicated through the use of an 
2326:	                 iterative approach and vice versa. Note: Writing recursive code is outside 
2327:	                 the scope of the  AP Computer Science A course and exam.
2328:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2329:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2330:	4.17 - Recursive Searching and Sorting.....................................................
2331:	   4.17.1 - Determine the result of executing recursive algorithms that use strings 
2332:	              or collections.
2333:	      4.17.1.1 - Recursion can be used to traverse String objects, arrays, and ArrayList 
2334:	                 objects.
2335:	   4.17.2 - Determine the result of each iteration of a binary search algorithm 
2336:	              used to search for information in a collection.
2337:	      4.17.2.1 - Data must be in sorted order to use the binary search algorithm. 
2338:	                 Binary search starts at the middle of a sorted array or ArrayList and eliminates 
2339:	                 half of the array or ArrayList in each recursive call until the desired value 
2340:	                 is found or all elements have been eliminated. 
2341:	      4.17.2.2 - Binary search is typically more efficient than linear search. Note: 
2342:	                 Search algorithms other than linear and binary search are outside the scope 
2343:	                 of the AP Computer Science A course and exam.
2344:	      4.17.2.3 - The binary search algorithm can be written either iteratively or 
2345:	                 recursively.
2346:	   4.17.3 - Determine the result of each iteration of the merge sort algorithm when 
2347:	              used to sort a collection.
2348:	      4.17.3.1 - Merge sort is a recursive sorting algorithm that can be used to 
2349:	                 sort elements in an array or ArrayList. Note: Sorting algorithms other than 
2350:	                 selection, insertion, and merge sort are outside the scope of the AP Computer 
2351:	                 Science A course and exam. 
2352:	      4.17.3.2 - Merge sort repeatedly divides an array into smaller subarrays until 
2353:	                 each subarray is one element and then recursively merges the sorted subarrays 
2354:	                 back together in sorted  order to form the final sorted array.
2355:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example below~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2356:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Curriculum example above~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2357:	Computer Science 42SAP - Practice Tests content running simulated:.........................
2358:	Computer Science 42SAP - AP Practice Test 1 content running simulated:.....................
2359:	// Question 1...
2360:	Consider the following code segment.
2361:	int a = 5;
2362:	int b = 2;
2363:	double c = 3.0;
2364:	System.out.println(5 + a / b * c - 1);
2365:	What is printed when the code segment is executed?
2366:	(A) 0.666666666666667
2367:	(B) 9.0
2368:	(C) 10.0
2369:	(D) 11.5
2370:	(E) 14.0
2371:	// Answer 1...
2372:	C
2373:	// Question 2...
2374:	Which of the following statements assigns a random
2375:	integer between 25 and 60, inclusive to rn?
2376:	(A) int rnA = (int)(Math.random() * 25) + 36;
2377:	(B) int rnB = (int)(Math.random() * 25) + 60;
2378:	(C) int rnC = (int)(Math.random() * 26) + 60;
2379:	(D) int rnD = (int)(Math.random() * 36) + 25;
2380:	(E) int rnE = (int)(Math.random() * 60) + 25;
2381:	// Answer 2...
2382:	A
2383:	D
2384:	// Question 3...
2385:	Which of the following best describes the value
2386:	of the Boolean expression shown below?
2387:	a && !(b || a)
2388:	(A) The value is always true
2389:	(B) The value is always false
2390:	(C) The value is true when a has the value 
    false, and is false otherwise
2391:	(D) The value is true when b has the value 
    false, and is false otherwise
2392:	(E) The value is true when either a or b has 
    the value true, and is false otherwise
2393:	// Answer 3...
2394:	B
2395:	// Question 4...
2396:	Consider the following code segment
2397:	int val = 48;
2398:	int div = 6;
2399:	while((val % 2 == 0) && div > 0) {
2400:	    if (val % div == 0) {
2401:	        System.out.print(val + " ");
2402:	    }
2403:	    val /= 2;
2404:	    div--;
2405:	}
2406:	What is printed when the code segment is executed?
2407:	(A) 48 12 6
2408:	(B) 48 12 6 3
2409:	(C) 48 12 6 3 1
2410:	(D) 48 24 12 6
2411:	(E) 48 24 12 6 3
2412:	// Answer 4...
2413:	A
2414:	// Question 5...
2415:	Which of the following code segments is equivalent to the code below
2416:	if (x >= 1) x = x * 3;
2417:	if (x > 3) x = 0;
2418:	(A) x = 0
2419:	(B) if (x > 1) x = 0;
2420:	(C) if (x > 3) x = 0;
2421:	(D) if (x >= 1) x = 0;
2422:	(E) none of the above
2423:	// Answer 5...
2424:	B
2425:	// Question 6...
2426:	When is the following Boolean expression true
2427:	(a and b are integers)?
2428:	(a < b) && !(b > a)
2429:	(A) Always true
2430:	(B) Never true
2431:	(C) a = b
2432:	(D) a < b
2433:	(E) a > b
2434:	// Answer 6...
2435:	B
2436:	// Question 7...
2437:	Consider the following code segment
2438:	int i = a random number such that 1 <= i <= n;
2439:	for (int a = 2; a <= i; a++)
2440:	    for (int b = 1; b < i; b++)
2441:	        System.out.println("*");
2442:	(A) 0
2443:	(B) 1
2444:	(C) 2
2445:	(D) n - 1
2446:	(E) n - 2
2447:	// Answer 7...
2448:	B
2449:	// Question 8...
2450:	Consider the following code segment
2451:	int p = 5;
2452:	int q = 2;
2453:	int sum = 0;
2454:	while (p <= 8) {
2455:	    sum += p % q;
2456:	    p++;
2457:	    q++;
2458:	}
2459:	(A) 1
2460:	(B) 0
2461:	(C) 13
2462:	(D) 7
2463:	(E) 4
2464:	// Answer 8...
2465:	D
2466:	// Question 9...
2467:	Consider the following code segment
2468:	for (int i = 0; i <= 3; i++) {
2469:	    for (int j = 1; j <= 5; j+=2) {
2470:	        System.out.println("*");
2471:	    }
2472:	}
2473:	(A) 3
2474:	(B) 6
2475:	(C) 9
2476:	(D) 12
2477:	(E) 15
2478:	// Answer 9...
2479:	D
2480:	// Question 10...
2481:	What are the values of a and b after the for loop
2482:	finishes?
2483:	int a = 10;
2484:	int b = 3;
2485:	int t = 0;
2486:	for (int i = 1; i < 4; i++) {
2487:	    t = a;
2488:	    a = i + b;
2489:	    b = t - i;
2490:	}
2491:	(A) a = 5 and b = -2
2492:	(B) a = 6 and b = 7
2493:	(C) a = 6 and b = 3
2494:	(D) a = 12 and b = 1
2495:	(E) a = 5 and b = 8
2496:	// Answer 10...
2497:	E
2498:	Computer Science 42SAP - AP Practice Test 2 content running simulated:.....................
2499:	// Question 1...
2500:	Consider the following class definition
2501:	public class Example
2502:	{
2503:	     private int x;
2504:	     // constructor not shown
2505:	}
2506:	Which of the following is a correct header for a
2507:	method that would return the value of the private
2508:	instance variable x so that it can be used in a
2509:	class other than Example?
2510:	(A) private int getX()
2511:	(B) private void getX()
2512:	(C) public int getX()
2513:	(D) public void getX()
2514:	(E) public void getX(int x)
2515:	// Answer 1...
2516:	C
2517:	// Question 2...
2518:	Consider the following class definitions
2519:	public class Thing1 {
2520:	     public void calc(int n) {
2521:	          n *= 3;
2522:	          System.out.print(n);
2523:	     }
2524:	}
2525:	public class Thing2 extends Thing1 {
2526:	     public void calc(int n) {
2527:	          n += 2;
2528:	          super.calc(n);
2529:	          System.out.print(n);
2530:	     }
2531:	}
2532:	The following code seqment appears in a class
2533:	other than Thing1 or Thing2
2534:	Thing1 t = new Thing2();
2535:	t.calc(2);
2536:	What is printed as a result of executing the
2537:	code segment?
2538:	(A) 4
2539:	(B) 6
2540:	(C) 68
2541:	(D) 124
2542:	(E) 1212
2543:	// Answer 2...
2544:	D
2545:	// Question 3...
2546:	Consider the following class definitions.
2547:	public class Student {
2548:	    public String getFood() {
2549:	        return "Pizza";
2550:	    }
2551:	    public String getInfo() {
2552:	        return "Studying";
2553:	    }
2554:	}
2555:	public class GradStudent extends Student {
2556:	    public String getFood() {
2557:	        return "Taco";
2558:	    }
2559:	    public String getInfo() {
2560:	        super.getInfo();
2561:	        return "Eating";
2562:	    }
2563:	}
2564:	What is printed when the following code is
2565:	executed?
2566:	Student s = new GradStudent();
2567:	System.out.println(s.getInfo());
2568:	(A) Pizza
2569:	(B) Taco
2570:	(C) Studying
2571:	(D) Eating
2572:	(E) Studying
2573:	    Eating
2574:	// Answer 3...
2575:	D
2576:	// Question 4...
2577:	Given the following class declarations:
2578:	public class Car {
2579:	    private String make;
2580:	    public Car(String theMake) {
2581:	        make = theMake;
2582:	    }
2583:	    public String getMake() {
2584:	        return make;
2585:	    }
2586:	}
2587:	public class ElectricCar extends Car {
2588:	    public ElectricCar() {
2589:	        super("Ford");
2590:	    }
2591:	    public ElectricCar(String theMake) {
2592:	        super(theMake);
2593:	    } 
2594:	}
2595:	Which of the following will cause a compile
2596:	time error?
2597:	(A) Car myCar = new Car();
2598:	(B) Car myCar1 = new ElectricCar();
2599:	(C) ElectricCar myCar2 = new ElectricCar("Ford");
2600:	(D) Car myCar3 = new Car("Ford");
2601:	(E) Car myCar4 = new ElectricCar("Ford");
2602:	// Answer 4...
2603:	A
2604:	// Question 5...
2605:	Given the following declarations.
2606:	public class Vehicle {
2607:	    public void test(Car x, SportsCar y) { }
2608:	}
2609:	public class Car extends Vehicle {
2610:	}
2611:	public class SportsCar extends Car {
2612:	}
2613:	Also consider the following code that appears
2614:	in a different class.
2615:	Vehicle v = new Vehicle();
2616:	Car c = new Car();
2617:	SportsCar sporty = new SportsCar();
2618:	Which of the following is a correct call to test ?
2619:	(A) v.test(sporty, v);
2620:	(B) sporty.test(c, c);
2621:	(C) v.test(sporty, c);
2622:	(D) sporty.test(sporty, v);
2623:	(E) c.test(sporty, sporty);
2624:	// Answer 5...
2625:	E
2626:	// Question 6...
2627:	Class C extends class B, which extends class A. 
2628:	Also, all of the three classes implement a public
2629:	method test(). How can a method in an object of
2630:	class C invoke the test() method defined in class
2631:	A (without creating a new instance of class A)?
2632:	(A) test();
2633:	(B) super.super.test();
2634:	(C) super.test();
2635:	(D) this.test();
2636:	(E) There is no way to call a method in a 
2637:	    grandparent class from a grandchild class
2638:	// Answer 6...
2639:	E
2640:	// Question 7...
2641:	Given the following class declarations. Assume
2642:	that Parent p = new Child(); appears in a client
2643:	program. What is the result of the call p.m1();
2644:	public class Parent {
2645:	    public void m1() {
2646:	        System.out.print("pm1");
2647:	        m2();
2648:	    }
2649:	    public void m2() {
2650:	        System.out.print("pm2");
2651:	    }
2652:	}
2653:	public class Child extends Parent {
2654:	    public void m1() {
2655:	        super.m1();
2656:	        System.out.print("cm1");
2657:	    }
2658:	    public void m2() {
2659:	        super.m2();
2660:	        System.out.print("cm2");
2661:	    }
2662:	}
2663:	(A) pm1pm2cm2cm1
2664:	(B) pm1pm2
2665:	(C) pm1pm2cm1cm2
2666:	(D) pm1cm1
2667:	(E) pm1
2668:	// Answer 7...
2669:	pm1pm2cm2cm1// Question 8...
2670:	Given the following class declarations.
2671:	public class Animal {
2672:	    public void eat() {
2673:	        System.out.println("AE");
2674:	    }
2675:	}
2676:	public class Bear extends Animal {
2677:	    public void growl() {
2678:	        System.out.println("BG");
2679:	    }
2680:	}
2681:	Assume the following declaration is in a 
2682:	different class.
2683:	Animal b = new Bear();
2684:	Which of the following will compile without error?
2685:	I.   b.eat();
2686:	II.  b.growl();
2687:	III. ((Bear)b).growl();
2688:	(A) I only
2689:	(B) II only
2690:	(C) III only
2691:	(D) I and III only
2692:	(E) I, II, and III
2693:	// Answer 8...
2694:	B
2695:	// Question 9...
2696:	Consider the following partial class definitions.
2697:	public class C1 {
2698:	    private int num;
2699:	    private String name;
2700:	    public C1(int theNum) {
2701:	        num = theNum
2702:	    } 
2703:	    public C1(String theName) {
2704:	        name = theName;
2705:	    }
2706:	}
2707:	public class C2 extends C1 {
2708:	    // methods not shown
2709:	}
2710:	Which of the following constructors are valid for
2711:	C2?
2712:	I. public C2() { }
2713:	II. public C2(int quan) { super(quan); }
2714:	III. public C2(String label) { super(label); }
2715:	(A) All three are valid
2716:	(B) II only
2717:	(C) III only
2718:	(D) II and III
2719:	(E) None are valid
2720:	// Answer 9...
2721:	D
2722:	// Question 10...
2723:	Given the following class definition. What are 
2724:	the values of x, y, and z just before method2
2725:	returns?
2726:	public class Class1 {
2727:	    public int method1(int a, int b) {
2728:	        int temp = a;
2729:	        a = b;
2730:	        b = temp;
2731:	        return b;
2732:	    }  
2733:	    public void method2() {
2734:	        int x = 3;
2735:	        int y = 5;
2736:	        int z = method1(x, y);
2737:	    }
2738:	}
2739:	(A) x=3,y=3,z=3
2740:	(B) x=3,y=5,z=3
2741:	(C) x=5,y=3,z=5
2742:	(D) x=5,y=3,z=3
2743:	(E) x=3,y=5,z=5
2744:	// Answer 10...
2745:	B
2746:	Computer Science 42SAP - AP Practice Test 3 content running simulated:.....................
2747:	// Section 1...
2748:	For the next two Free response questions, 
2749:	refer to the description below...
2750:	A travel agency maintains a list of information 
2751:	about airline flights. Flight information 
2752:	includes a departure time and an arrival time.
2753:	You may assume that the two times occur on the 
2754:	same day. These times are represented by 
2755:	objects of the Time class. The declaration for
2756:	the Time class is shown below. It includes a 
2757:	method which returns the difference (in minutes)
2758:	between the current Time object and another Time
2759:	object. 
2760:	public class Time {
2761:	     /** 
2762:	      * @return difference, in minutes, between this
2763:	      * time and other; difference is negative
2764:	      * if other is earlier than this time
2765:	      */
2766:	     public int minutesUntil(Time other) {
2767:	          /* implementation not shown */
2768:	     }
2769:	     // There may be instance variables, constructors,
2770:	     // and methods that are not shown.
2771:	}
2772:	For example, assume that t1 and t2 are Time 
2773:	objects where t1 represents 1:00 p.m. and t2 
2774:	represents 2:15 p.m. The call t1.minutesUntil(t2) 
2775:	will return 75 and the call t2.minutesUntil(t1) 
2776:	will return -75. The declaration for the Flight class 
2777:	is shown below. It has methods to access the 
2778:	departure time and the arrival time of a flight. 
2779:	You may assume that the departure time of a 
2780:	flight is earlier than its arrival time.
2781:	public class Flight {
2782:	      /** @return time at which the flight departs */
2783:	      public Time getDepartureTime() {
2784:	           /* implementation not shown */ 
2785:	      }
2786:	      /** @return time at which the flight arrives */
2787:	      public Time getArrivalTime() {
2788:	           /* implementation not shown */ 
2789:	      }
2790:	      // There may be instance variables, constructors, 
2791:	      // and methods that are not shown.
2792:	}
2793:	A trip consists of a sequence of flights and is 
2794:	represented by the Trip class. The Trip class 
2795:	contains a List of Flight objects that are stored 
2796:	in chronological order. You may assume that for 
2797:	each flight after the first flight in the list, 
2798:	the departure time of the flight is later than 
2799:	the arrival time of the preceding flight in the 
2800:	list. A partial declaration of the Trip class is 
2801:	shown below. You will write two methods for the 
2802:	Trip class.
2803:	public class Trip {
2804:	     /** 
2805:	       * The list of flights (if any) that make up 
2806:	       * this trip, stored in chronological order
2807:	       */
2808:	     private List<Flight> flights;
2809:	     /** 
2810:	       * @return the number of minutes from the 
2811:	       * departure of the first flight to the arrival 
2812:	       * of the last flight if there are one or more 
2813:	       * flights in the trip; 0, if there are no 
2814:	       * flights in the trip
2815:	       */
2816:	     public int getDuration() {
2817:	          /* to be implemented in part (a) */ 
2818:	     }
2819:	     /** 
2820:	       * Precondition: the departure time for each 
2821:	       * flight is later than the arrival time of its 
2822:	       * preceding flight
2823:	       * @return the smallest number of minutes 
2824:	       * between the arrival of a flight and the 
2825:	       * departure of the flight immediately after it, 
2826:	       * if there are two or more flights in the 
2827:	       * trip; -1, if there are fewer than two flights 
2828:	       * in the trip
2829:	       */
2830:	     public int getShortestLayover() {
2831:	          /* to be implemented in part (b) */
2832:	     }
2833:	       // There may be instance variables, constructors,
2834:	       // and methods that are not shown
2835:	}
2836:	// Question 1...
2837:	Complete method getDuration below.  
2838:	// An answer could be...
2839:	public int getDuration() {
2840:	    int totalDuration = 0;
2841:	    for (Flight flight : flights) {
2842:	        Time departure = flight.getDepartureTime();
2843:	        Time arrival   = flight.getArrivalTime();
2844:	        int  duration  = departure.minutesUntil(arrival);
2845:	        totalDuration  = totalDuration + duration;
2846:	    }
2847:	    return totalDuration;
2848:	}
2849:	// Question 2...
2850:	Write the Trip method getShortestLayover. A 
2851:	layover is the number of minutes from the arrival 
2852:	of one flight in a trip to the departure of the 
2853:	flight immediately after it. If there are two or 
2854:	more flights in the trip, the method should return 
2855:	the shortest layover of the trip; otherwise, it 
2856:	should return -1. For example, assume that the 
2857:	instance variable flights of a Trip object vacation 
2858:	contains the following flight information.
2859:	          Departure   Arrival   Layover
2860:	            Time      Time     (minutes)
2861:	         +---------+----------+
2862:	Flight 0 | 11:30am |  12:15pm |
2863:	         +---------+----------+ }  60
2864:	Flight 1 |  1:15pm |   3:45pm |
2865:	         +---------+----------+ }  15
2866:	Flight 2 |  4:00pm |   6:45pm |
2867:	         +---------+----------+ }  210
2868:	Flight 3 | 10:15pm |  11:00pm |
2869:	         +---------+----------+
2870:	The call vacation.getShortestLayover() should 
2871:	return 15. Complete method getShortestLayover() 
2872:	below.
2873:	public int getShortestLayover()
2874:	// An answer could be...
2875:	public int getShortestLayover() {
2876:	    if (flights.isEmpty()) return -1;
2877:	    int shortestLayover = Integer.MAX_VALUE;
2878:	    int i = 0;
2879:	    while (i < flights.size()) {
2880:	        Flight currentFlight = flights.get(i);
2881:	        i++;
2882:	        Flight nextFlight    = flights.get(i);
2883:	        Time arrival         = currentFlight.getArrivalTime();
2884:	        Time departure       = nextFlight.getDepartureTime();
2885:	        int layover = Math.abs(arrival.minutesUntil(departure));
2886:	        if (layover < shortestLayover) {
2887:	            shortestLayover = layover;
2888:	        }
2889:	        i++;
2890:	    }
2891:	    return shortestLayover;
2892:	}
2893:	// Section 1...
2894:	For the next three Free response questions, refer 
2895:	to the description below...
2896:	Consider the hierarchy of classes shown in the 
2897:	following diagram
2898:	         +----------+ 
2899:	         |    Pet   |
2900:	         +----------+
2901:	            /    \
2902:	 +----------+    +----------+
2903:	 |    Cat   |    |    Dog   |
2904:	 +----------+    +----------+
2905:	                       \
2906:	                       +----------+
2907:	                       | Loud Dog |
2908:	                       +----------+
2909:	Note that a Cat 'is-a' Pet, a Dog 'is-a' Pet, and 
2910:	a LoudDog 'is-a' Dog. The class Pet is specified 
2911:	as an abstract class as shown in the following 
2912:	declaration. Each Pet has a name that is 
2913:	specified when it is constructed.
2914:	public abstract class Pet {
2915:	    private String name;
2916:	    public Pet(String petName) {
2917:	        name = petName;
2918:	    }
2919:	    public String getName() {
2920:	        return name;
2921:	    }
2922:	    public abstract String speak();
2923:	}
2924:	The subclass Dog has the partial class 
2925:	declaration shown below.
2926:	public class Dog extends Pet {
2927:	    public Dog(String petName) {
2928:	        /* implementation not shown */
2929:	    }
2930:	    public String speak() {
2931:	        /* implementation not shown */
2932:	    }
2933:	}
2934:	// Question 3...
2935:	Given the class hierarchy shown above, write a 
2936:	complete class declaration for the class Cat, 
2937:	including implementations of its constructor 
2938:	and method(s). The Cat method speak returns 
2939:	'meow' when it is invoked.
2940:	// An answer could be...
2941:	public class Cat extends Pet {
2942:	    public Cat(String petName) {
2943:	        super(petName);
2944:	    }
2945:	    public String speak() {
2946:	        return "meow";
2947:	    }
2948:	}
2949:	// Question 4...
2950:	Assume that class Dog has been declared as shown 
2951:	at the beginning of the question. If the String 
2952:	dog-sound is returned by the Dog method speak, 
2953:	then the LoudDog method method speak returns a 
2954:	String containing dog-sound repeated two times. 
2955:	Given the class hierarchy shown previously, 
2956:	write a complete class declaration for the class 
2957:	LoudDog including implementations of its 
2958:	constructor and method(s).
2959:	// An answer could be...
2960:	public class LoudDog extends Dog {
2961:	    public LoudDog(String petName) {
2962:	        super(petName);
2963:	    }
2964:	    public String speak() {
2965:	        return super.speak() + super.speak();
2966:	    }
2967:	}
2968:	// Question 5...
2969:	Consider the following partial declaration of 
2970:	class Kennel
2971:	public class Kennel {
2972:	    private ArrayList<Pet> petList;
2973:	     /**
2974:	      * For every Pet in the kennel, prints the name 
2975:	      * followed by the result of a call to its speak 
2976:	      * method, one line per Pet
2977:	      */
2978:	     public void allSpeak() {
2979:	        /* to be implemented */
2980:	     }
2981:	     // There may be instance variables, constructors, 
2982:	     // and methods that are not shown
2983:	}
2984:	Write the Kennel method allSpeak For each Pet in 
2985:	the kennel, allSpeak prints a line with the name 
2986:	of the Pet followed by the result of a call to 
2987:	its speak method. In writing allSpeak you may use 
2988:	any of the methods defined for any of the classes 
2989:	specified for this problem. Assume that these 
2990:	methods work as specified, regardless of what 
2991:	you wrote in previous questions. Complete method
2992:	allSpeak below
2993:	public void allSpeak()
2994:	// An answer could be...
2995:	public void allSpeak() {
2996:	    for (Pet pet : petList) {
2997:	        System.out.println(pet.getName() + pet.speak());
2998:	    }
2999:	}
3000:	Computer Science 42SAP - AP Practice Test 4 content running simulated:.....................
3001:	// Question 1...
3002:	(A) 
3003:	(B) 
3004:	(C) 
3005:	(D) 
3006:	(E) 
3007:	// Answer 1...
3008:	// Question 2...
3009:	(A) 
3010:	(B) 
3011:	(C) 
3012:	(D) 
3013:	(E) 
3014:	// Answer 2...
3015:	// Question 3...
3016:	(A) 
3017:	(B) 
3018:	(C) 
3019:	(D) 
3020:	(E) 
3021:	// Answer 3...
3022:	// Question 4...
3023:	(A) 
3024:	(B) 
3025:	(C) 
3026:	(D) 
3027:	(E) 
3028:	// Answer 4...
3029:	// Question 5...
3030:	(A) 
3031:	(B) 
3032:	(C) 
3033:	(D) 
3034:	(E) 
3035:	// Answer 5...
3036:	// Question 6...
3037:	(A) 
3038:	(B) 
3039:	(C) 
3040:	(D) 
3041:	(E) 
3042:	// Answer 6...
3043:	// Question 7...
3044:	(A) 
3045:	(B) 
3046:	(C) 
3047:	(D) 
3048:	(E) 
3049:	// Answer 7...
3050:	// Question 8...
3051:	(A) 
3052:	(B) 
3053:	(C) 
3054:	(D) 
3055:	(E) 
3056:	// Answer 8...
3057:	// Question 9...
3058:	(A) 
3059:	(B) 
3060:	(C) 
3061:	(D) 
3062:	(E) 
3063:	// Answer 9...
3064:	// Question 10...
3065:	(A) 
3066:	(B) 
3067:	(C) 
3068:	(D) 
3069:	(E) 
3070:	// Answer 10...
3071:	Computer Science 42SAP - Student Driven 'fun' Days content running simulated:..............
3072:	Computer Science 42SAP - More Post Secondary content running simulated:....................
3073:	Computer Science 42SAP - Permanent Storage Post Secondary content running simulated:.......
3074:	// Learn about 'error traps'
3075:	Divide by zero -> java.lang.ArithmeticException: / by zero
3076:	// Create sample data to use
3077:	// Save ONE piece of data to that permanent file
3078:	// Now involve the user to get a file name
3079:	~~~ SIMULATED {File Chooser null  simulated message} DIALOG: 
3080:	File already exists!
3081:	// Open file with one line (no user involvment)
3082:	line read was Defenestration
3083:	// Open file with multiple lines (user picks file)
3084:	~~~ SIMULATED {File Chooser null  simulated message} DIALOG: 
3085:	This line read was �� sr utility.collections.LinkedList�̉-�� I 	NOT_FOUNDI lengthI longestWordL headt Lutility/collections/Node;L tailq ~ xp����   d   �sr utility.collections.Node5�����2 ... (line shortened) ...
3086:	This line read was detailMessaget Ljava/lang/String;[ 
3087:	This line read was stackTracet [Ljava/lang/StackTraceElement;L suppressedExceptionst Ljava/util/List;xpq ~ 	t 2testing.prerequisite.cs40s.advancedclasses.Athleteur [Ljava.lang.StackTraceElement;F ... (line shortened) ...
3088:	This line read was lineNumberL classLoaderNameq ~ L declaringClassq ~ L fileNameq ~ L 
3089:	This line read was methodNameq ~ L 
3090:	This line read was moduleNameq ~ L 
3091:	This line read was moduleVersionq ~ xp  �pt java.io.ObjectOutputStreamt ObjectOutputStream.javat writeObject0t 	java.baset 22.0.2sq ~ 
3092:	This line read was   1pq ~ q ~ t defaultWriteFieldsq ~ q ~ sq ~ 
3093:	This line read was   pq ~ q ~ t writeSerialDataq ~ q ~ sq ~ 
3094:	This line read was   �pq ~ q ~ t writeOrdinaryObjectq ~ q ~ sq ~ 
3095:	This line read was   �pq ~ q ~ q ~ q ~ q ~ sq ~ 
3096:	This line read was   1pq ~ q ~ q ~ q ~ q ~ sq ~ 
3097:	This line read was   pq ~ q ~ q ~ q ~ q ~ sq ~ 
3098:	This line read was   �pq ~ q ~ q ~ q ~ q ~ sq ~ 
3099:	This line read was   �pq ~ q ~ q ~ q ~ q ~ sq ~ 
3100:	This line read was   fpq ~ q ~ t writeObjectq ~ q ~ sq ~ 
3101:	This line read was   �t appt utility.io.FileHandlert FileHandler.javat 
3102:	This line read was saveObjectppsq ~ 
3103:	This line read was   �q ~ "q ~ #q ~ $q ~ %ppsq ~ 
3104:	This line read was   q ~ "t *testing.postsecondary.PermanentStorageTestt PermanentStorageTest.javat <init>ppsq ~ 
3105:	This line read was    q ~ "t .testing.postsecondary.MorePostSecondaryContentt MorePostSecondaryContent.javaq ~ *ppsq ~ 
3106:	This line read was    tq ~ "t testing.Testert Tester.javat 
3107:	This line read was postSecondaryppsq ~ 
3108:	This line read was    Kq ~ "q ~ /q ~ 0q ~ *ppsq ~ 
3109:	This line read was    1q ~ "q ~ /q ~ 0q ~ *ppsq ~ 
3110:	This line read was    q ~ "t mainpackage.MainClasst MainClass.javat mainppsr java.util.Collections$EmptyListz��<���  xpx
3111:	// Class to save/open one line (no user)
3112:	Before: Defenestration
3113:	After : Defenestration
3114:	// Class to save/open multiple lines (with user)
3115:	~~~ SIMULATED {File Chooser null  simulated message} DIALOG: 
3116:	~~~ SIMULATED {File Chooser null  simulated message} DIALOG: 
3117:	Before: [I look at my watch for the hour,But I find it has run out of power,I yell out Oh No!,I have got to go!,For I fear that the milk has gone sour]
3118:	After:  [I look at my watch for the hour,But I find it has run out of power,I yell out Oh No!,I have got to go!,For I fear that the milk has gone sour]
3119:	// Now save/open on a complex data type
3120:	File open: java.io.NotSerializableException: testing.prerequisite.cs40s.advancedclasses.Athlete
3121:	File open: java.io.WriteAbortedException: writing aborted; java.io.NotSerializableException: testing.prerequisite.cs40s.advancedclasses.Athlete
3122:	Before: Athlete: Husky: HighSchool: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Athlete@5c909414
3123:	File open: java.io.NotSerializableException: testing.prerequisite.cs40s.advancedclasses.Athlete
3124:	File open: java.io.WriteAbortedException: writing aborted; java.io.NotSerializableException: testing.prerequisite.cs40s.advancedclasses.Athlete
3125:	Before: [Athlete: Husky: HighSchool: Student Over-riding from: Person Over-riding from: testing.prerequisite.cs40s.advancedclasses.Athlete@4b14c583,Athlete: Husky: HighSchool: Student Over-riding from ... (line shortened) ...
3126:	After:  null
3127:	Computer Science 42SAP - Stacks and Queues Post Secondary content running simulated:.......
3128:	// Create objects for testing...
3129:	// Create and Test a stack object...
3130:	// Test toString, size, isEmpty, and push methods...
3131:	Empty = true	Size = 0	Empty Stack
3132:	// Loop through adding random values
3133:	Empty = false	Size = 1	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@35ef1869] <- bottom
3134:	Empty = false	Size = 2	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@c33b74f,testing.prerequisite.cs40s.advancedclasses.Box@35ef1869] <- bottom
3135:	Empty = false	Size = 3	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@130161f7,testing.prerequisite.cs40s.advancedclasses.Box@c33b74f,testing.prerequisite.cs40s.advancedclasses.Box@35ef1 ... (line shortened) ...
3136:	Empty = false	Size = 4	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@2c767a52,testing.prerequisite.cs40s.advancedclasses.Box@130161f7,testing.prerequisite.cs40s.advancedclasses.Box@c33b ... (line shortened) ...
3137:	Empty = false	Size = 5	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@619713e5,testing.prerequisite.cs40s.advancedclasses.Box@2c767a52,testing.prerequisite.cs40s.advancedclasses.Box@1301 ... (line shortened) ...
3138:	Empty = false	Size = 6	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@708f5957,testing.prerequisite.cs40s.advancedclasses.Box@619713e5,testing.prerequisite.cs40s.advancedclasses.Box@2c76 ... (line shortened) ...
3139:	Empty = false	Size = 7	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@68999068,testing.prerequisite.cs40s.advancedclasses.Box@708f5957,testing.prerequisite.cs40s.advancedclasses.Box@6197 ... (line shortened) ...
3140:	Empty = false	Size = 8	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@7722c3c3,testing.prerequisite.cs40s.advancedclasses.Box@68999068,testing.prerequisite.cs40s.advancedclasses.Box@708f ... (line shortened) ...
3141:	Empty = false	Size = 9	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@2ef3eef9,testing.prerequisite.cs40s.advancedclasses.Box@7722c3c3,testing.prerequisite.cs40s.advancedclasses.Box@6899 ... (line shortened) ...
3142:	Empty = false	Size = 10	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@243c4f91,testing.prerequisite.cs40s.advancedclasses.Box@2ef3eef9,testing.prerequisite.cs40s.advancedclasses.Box@772 ... (line shortened) ...
3143:	// Test clone method...
3144:	Clone stack: Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@243c4f91,testing.prerequisite.cs40s.advancedclasses.Box@2ef3eef9,testing.prerequisite.cs40s.advancedclasses.Box@7722c3c3,testi ... (line shortened) ...
3145:	// Test equals method...
3146:	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@243c4f91,testing.prerequisite.cs40s.advancedclasses.Box@2ef3eef9,testing.prerequisite.cs40s.advancedclasses.Box@7722c3c3,testing.prerequisi ... (line shortened) ...
3147:	// Now change the copy
3148:	// Now check again
3149:	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@243c4f91,testing.prerequisite.cs40s.advancedclasses.Box@2ef3eef9,testing.prerequisite.cs40s.advancedclasses.Box@7722c3c3,testing.prerequisi ... (line shortened) ...
3150:	// Re-clone the stack, and output
3151:	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@243c4f91,testing.prerequisite.cs40s.advancedclasses.Box@2ef3eef9,testing.prerequisite.cs40s.advancedclasses.Box@7722c3c3,testing.prerequisi ... (line shortened) ...
3152:	// Text the pop method...
3153:	Clone stack:	Empty = false	Size = 10	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@243c4f91,testing.prerequisite.cs40s.advancedclasses.Box@2ef3eef9,testing.prerequisite.cs40s.advancedcl ... (line shortened) ...
3154:	// Loop through removing values
3155:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@243c4f91	Empty = false	Size = 9	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@2ef3eef9,testing.prerequisite.cs40s.advancedclasse ... (line shortened) ...
3156:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@2ef3eef9	Empty = false	Size = 8	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@7722c3c3,testing.prerequisite.cs40s.advancedclasse ... (line shortened) ...
3157:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@7722c3c3	Empty = false	Size = 7	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@68999068,testing.prerequisite.cs40s.advancedclasse ... (line shortened) ...
3158:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@68999068	Empty = false	Size = 6	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@708f5957,testing.prerequisite.cs40s.advancedclasse ... (line shortened) ...
3159:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@708f5957	Empty = false	Size = 5	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@619713e5,testing.prerequisite.cs40s.advancedclasse ... (line shortened) ...
3160:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@619713e5	Empty = false	Size = 4	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@2c767a52,testing.prerequisite.cs40s.advancedclasse ... (line shortened) ...
3161:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@2c767a52	Empty = false	Size = 3	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@130161f7,testing.prerequisite.cs40s.advancedclasse ... (line shortened) ...
3162:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@130161f7	Empty = false	Size = 2	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@c33b74f,testing.prerequisite.cs40s.advancedclasses ... (line shortened) ...
3163:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@c33b74f	Empty = false	Size = 1	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@35ef1869] <- bottom
3164:	Popped -> testing.prerequisite.cs40s.advancedclasses.Box@35ef1869	Empty = true	Size = 0	Empty Stack
3165:	Popped -> null	Empty = true	Size = 0	Empty Stack
3166:	// Test peek (top is wrapper no testing needed)...
3167:	Clone Top = null
3168:	Stack Top = testing.prerequisite.cs40s.advancedclasses.Box@243c4f91
3169:	// Test to array and to linked list...
3170:	[testing.prerequisite.cs40s.advancedclasses.Box@243c4f91,testing.prerequisite.cs40s.advancedclasses.Box@2ef3eef9,testing.prerequisite.cs40s.advancedclasses.Box@7722c3c3,testing.prerequisite.cs40s.adva ... (line shortened) ...
3171:	Array   	[testing.prerequisite.cs40s.advancedclasses.Box@243c4f91,testing.prerequisite.cs40s.advancedclasses.Box@2ef3eef9,testing.prerequisite.cs40s.advancedclasses.Box@7722c3c3,testing.prerequisite.c ... (line shortened) ...
3172:	// Test our constructors...
3173:	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@243c4f91,testing.prerequisite.cs40s.advancedclasses.Box@2ef3eef9,testing.prerequisite.cs40s.advancedclasses.Box@7722c3c3,testing.prerequisi ... (line shortened) ...
3174:	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@243c4f91,testing.prerequisite.cs40s.advancedclasses.Box@2ef3eef9,testing.prerequisite.cs40s.advancedclasses.Box@7722c3c3,testing.prerequisi ... (line shortened) ...
3175:	// Test the Queue object...
3176:	// Test toString,size,isEmpty, and enqueue methods...
3177:	Empty = true	Size = 0	Empty Queue
3178:	// Loop through adding random values
3179:	Empty = false	Size = 1	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@50eac852] <- front
3180:	Empty = false	Size = 2	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@16ec5519,testing.prerequisite.cs40s.advancedclasses.Box@50eac852] <- front
3181:	Empty = false	Size = 3	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@2f7298b,testing.prerequisite.cs40s.advancedclasses.Box@16ec5519,testing.prerequisite.cs40s.advancedclasses.Box@50ea ... (line shortened) ...
3182:	Empty = false	Size = 4	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@188715b5,testing.prerequisite.cs40s.advancedclasses.Box@2f7298b,testing.prerequisite.cs40s.advancedclasses.Box@16ec ... (line shortened) ...
3183:	Empty = false	Size = 5	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@1ea9f6af,testing.prerequisite.cs40s.advancedclasses.Box@188715b5,testing.prerequisite.cs40s.advancedclasses.Box@2f7 ... (line shortened) ...
3184:	Empty = false	Size = 6	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@6a192cfe,testing.prerequisite.cs40s.advancedclasses.Box@1ea9f6af,testing.prerequisite.cs40s.advancedclasses.Box@188 ... (line shortened) ...
3185:	Empty = false	Size = 7	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@5119fb47,testing.prerequisite.cs40s.advancedclasses.Box@6a192cfe,testing.prerequisite.cs40s.advancedclasses.Box@1ea ... (line shortened) ...
3186:	Empty = false	Size = 8	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@7193666c,testing.prerequisite.cs40s.advancedclasses.Box@5119fb47,testing.prerequisite.cs40s.advancedclasses.Box@6a1 ... (line shortened) ...
3187:	Empty = false	Size = 9	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@20deea7f,testing.prerequisite.cs40s.advancedclasses.Box@7193666c,testing.prerequisite.cs40s.advancedclasses.Box@511 ... (line shortened) ...
3188:	Empty = false	Size = 10	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclasses.Box@20deea7f,testing.prerequisite.cs40s.advancedclasses.Box@719 ... (line shortened) ...
3189:	// Test clone method...
3190:	Clone Queue 			Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclasses.Box@20deea7f,testing.prerequisite.cs40s.advancedclasses.Box@7193666c,tes ... (line shortened) ...
3191:	// Test equals method...
3192:	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclasses.Box@20deea7f,testing.prerequisite.cs40s.advancedclasses.Box@7193666c,testing.prerequisi ... (line shortened) ...
3193:	// Now change the duplicate
3194:	// Now check again
3195:	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclasses.Box@20deea7f,testing.prerequisite.cs40s.advancedclasses.Box@7193666c,testing.prerequisi ... (line shortened) ...
3196:	// Re-clone the queue, and output
3197:	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclasses.Box@20deea7f,testing.prerequisite.cs40s.advancedclasses.Box@7193666c,testing.prerequisi ... (line shortened) ...
3198:	// Test the dequeue method...
3199:	Clone queue:	Empty = false	Size = 10	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclasses.Box@20deea7f,testing.prerequisite.cs40s.advancedcl ... (line shortened) ...
3200:	// Loop through removing values
3201:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@50eac852	Empty = false	Size = 9	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclas ... (line shortened) ...
3202:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@16ec5519	Empty = false	Size = 8	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclas ... (line shortened) ...
3203:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@2f7298b	Empty = false	Size = 7	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclass ... (line shortened) ...
3204:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@188715b5	Empty = false	Size = 6	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclas ... (line shortened) ...
3205:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@1ea9f6af	Empty = false	Size = 5	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclas ... (line shortened) ...
3206:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@6a192cfe	Empty = false	Size = 4	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclas ... (line shortened) ...
3207:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@5119fb47	Empty = false	Size = 3	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclas ... (line shortened) ...
3208:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@7193666c	Empty = false	Size = 2	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclas ... (line shortened) ...
3209:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@20deea7f	Empty = false	Size = 1	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46] <- front
3210:	Dequeued -> testing.prerequisite.cs40s.advancedclasses.Box@3835c46	Empty = true	Size = 0	Empty Queue
3211:	Dequeued -> null	Empty = true	Size = 0	Empty Queue
3212:	// Test front and back...
3213:	Clone Front = null
3214:	Queue Front = testing.prerequisite.cs40s.advancedclasses.Box@50eac852
3215:	Clone Back  = null
3216:	Queue Back  = testing.prerequisite.cs40s.advancedclasses.Box@3835c46
3217:	// Test to array and to linked list...
3218:	[testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclasses.Box@20deea7f,testing.prerequisite.cs40s.advancedclasses.Box@7193666c,testing.prerequisite.cs40s.advan ... (line shortened) ...
3219:	Array   	[testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclasses.Box@20deea7f,testing.prerequisite.cs40s.advancedclasses.Box@7193666c,testing.prerequisite.cs ... (line shortened) ...
3220:	// Test our constructors...
3221:	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclasses.Box@20deea7f,testing.prerequisite.cs40s.advancedclasses.Box@7193666c,testing.prerequisi ... (line shortened) ...
3222:	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclasses.Box@20deea7f,testing.prerequisite.cs40s.advancedclasses.Box@7193666c,testing.prerequisi ... (line shortened) ...
3223:	// Constructors from stack to queue (and back)...
3224:	Queue back -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclasses.Box@20deea7f,testing.prerequisite.cs40s.advancedclasses.Box@7193666c,testing.prerequisi ... (line shortened) ...
3225:	Stack top -> [testing.prerequisite.cs40s.advancedclasses.Box@3835c46,testing.prerequisite.cs40s.advancedclasses.Box@20deea7f,testing.prerequisite.cs40s.advancedclasses.Box@7193666c,testing.prerequisit ... (line shortened) ...
3226:	Computer Science 42SAP - Searching and Sorting Post Secondary content running simulated:...
3227:	// Search: linear search and binary search
3228:	// Sort: bubble sort and the selection sort
3229:	// Create some constants (edges) for the data
3230:	// Create some random data to search through and sort
3231:	// Including edge cases to test
3232:	// Create data to store the results...
3233:	// The simpliest of searches
3234:	Array [35,66,36,10,74,34,86,55,5,41,23,71,52,34,28,19,87,3,52,83,37,85,44,97,65,80,51,93,27,76,3,73,96,1,97,65,8,93,4,1,16,81,99,5,75,82,75,72,36,72,18,91,85,65,94,22,70,48,57,85,96,42,81,83,34,36,68, ... (line shortened) ...
3235:	// Now the linear search on all test data
3236:	Array [35,66,36,10,74,34,86,55,5,41,23,71,52,34,28,19,87,3,52,83,37,85,44,97,65,80,51,93,27,76,3,73,96,1,97,65,8,93,4,1,16,81,99,5,75,82,75,72,36,72,18,91,85,65,94,22,70,48,57,85,96,42,81,83,34,36,68, ... (line shortened) ...
3237:	Array [35,66,36,10,74,34,86,55,5,41,23,71,52,34,28,19,87,3,52,83,37,85,44,97,65,80,51,93,27,76,3,73,96,1,97,65,8,93,4,1,16,81,99,5,75,82,75,72,36,72,18,91,85,65,94,22,70,48,57,85,96,42,81,83,34,36,68, ... (line shortened) ...
3238:	Array [35,66,36,10,74,34,86,55,5,41,23,71,52,34,28,19,87,3,52,83,37,85,44,97,65,80,51,93,27,76,3,73,96,1,97,65,8,93,4,1,16,81,99,5,75,82,75,72,36,72,18,91,85,65,94,22,70,48,57,85,96,42,81,83,34,36,68, ... (line shortened) ...
3239:	Array [35,66,36,10,74,34,86,55,5,41,23,71,52,34,28,19,87,3,52,83,37,85,44,97,65,80,51,93,27,76,3,73,96,1,97,65,8,93,4,1,16,81,99,5,75,82,75,72,36,72,18,91,85,65,94,22,70,48,57,85,96,42,81,83,34,36,68, ... (line shortened) ...
3240:	Array [35,66,36,10,74,34,86,55,5,41,23,71,52,34,28,19,87,3,52,83,37,85,44,97,65,80,51,93,27,76,3,73,96,1,97,65,8,93,4,1,16,81,99,5,75,82,75,72,36,72,18,91,85,65,94,22,70,48,57,85,96,42,81,83,34,36,68, ... (line shortened) ...
3241:	// Simple sort...
3242:	Sorted Array: 	[1,1,3,3,4,5,5,8,10,10,11,11,11,13,16,18,19,22,23,23,24,27,27,28,30,34,34,34,35,35,36,36,36,37,38,39,40,40,41,42,42,44,44,45,48,49,51,52,52,52,55,57,57,60,62,63,65,65,65,66,68,70,71,71, ... (line shortened) ...
3243:	// We will re-scramble array for further testing
3244:	Sorted Array: 	[74,58,98,46,37,73,63,6,7,98,99,33,11,74,58,98,70,47,98,75,12,88,5,29,95,5,39,64,93,41,64,55,12,50,47,26,79,96,47,66,34,18,65,49,69,26,59,49,4,70,53,45,93,67,70,90,91,32,1,92,11,50,25,8 ... (line shortened) ...
3245:	// Now bubble sort (from bubbles rising from water)
3246:	Original Array 	[74,58,98,46,37,73,63,6,7,98,99,33,11,74,58,98,70,47,98,75,12,88,5,29,95,5,39,64,93,41,64,55,12,50,47,26,79,96,47,66,34,18,65,49,69,26,59,49,4,70,53,45,93,67,70,90,91,32,1,92,11,50,25, ... (line shortened) ...
3247:	// Now selection sort (from selecting the smallest)
3248:	Original Array 	[74,58,98,46,37,73,63,6,7,98,99,33,11,74,58,98,70,47,98,75,12,88,5,29,95,5,39,64,93,41,64,55,12,50,47,26,79,96,47,66,34,18,65,49,69,26,59,49,4,70,53,45,93,67,70,90,91,32,1,92,11,50,25, ... (line shortened) ...
3249:	// Now binary search (named after two or dividing)
3250:	// NOTE: binary search can only happen on sorted list
3251:	// Redo some of the test data...
3252:	Array [1,1,2,4,5,5,5,6,7,8,11,11,11,12,12,15,16,18,22,23,24,25,26,26,26,26,27,28,29,29,30,32,32,33,33,34,36,37,39,41,41,43,44,45,46,47,47,47,49,49,49,50,50,50,53,55,58,58,58,59,63,64,64,65,66,67,67,69 ... (line shortened) ...
3253:	Array [1,1,2,4,5,5,5,6,7,8,11,11,11,12,12,15,16,18,22,23,24,25,26,26,26,26,27,28,29,29,30,32,32,33,33,34,36,37,39,41,41,43,44,45,46,47,47,47,49,49,49,50,50,50,53,55,58,58,58,59,63,64,64,65,66,67,67,69 ... (line shortened) ...
3254:	Array [1,1,2,4,5,5,5,6,7,8,11,11,11,12,12,15,16,18,22,23,24,25,26,26,26,26,27,28,29,29,30,32,32,33,33,34,36,37,39,41,41,43,44,45,46,47,47,47,49,49,49,50,50,50,53,55,58,58,58,59,63,64,64,65,66,67,67,69 ... (line shortened) ...
3255:	Array [1,1,2,4,5,5,5,6,7,8,11,11,11,12,12,15,16,18,22,23,24,25,26,26,26,26,27,28,29,29,30,32,32,33,33,34,36,37,39,41,41,43,44,45,46,47,47,47,49,49,49,50,50,50,53,55,58,58,58,59,63,64,64,65,66,67,67,69 ... (line shortened) ...
3256:	Array [1,1,2,4,5,5,5,6,7,8,11,11,11,12,12,15,16,18,22,23,24,25,26,26,26,26,27,28,29,29,30,32,32,33,33,34,36,37,39,41,41,43,44,45,46,47,47,47,49,49,49,50,50,50,53,55,58,58,58,59,63,64,64,65,66,67,67,69 ... (line shortened) ...
3257:	// Use class for searching and sorting
3258:	// Create random linked list data
3259:	// Create random array data
3260:	// Place all test cases into another linked list
3261:	// Execute the linear search on all list test data...
3262:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3263:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3264:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3265:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3266:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3267:	// Execute the linear search on all array test data...
3268:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3269:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3270:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3271:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3272:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3273:	// Execute all the sorts on all test data...
3274:	// Bubble sort LinkedList data...
3275:	Before: 	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen, ... (line shortened) ...
3276:	// Bubble sort array data...
3277:	Before: 	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen, ... (line shortened) ...
3278:	// Selection sort LinkedList data...
3279:	Before: 	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen, ... (line shortened) ...
3280:	// Selection sort array data...
3281:	Before: 	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen, ... (line shortened) ...
3282:	// Shell sort LinkedList data...
3283:	Before: 	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen, ... (line shortened) ...
3284:	// Shell sort array data...
3285:	Before: 	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen, ... (line shortened) ...
3286:	// Insertion sort LinkedList data...
3287:	Before: 	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen, ... (line shortened) ...
3288:	// Insertion sort array data...
3289:	Before: 	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen, ... (line shortened) ...
3290:	// Quick sort LinkedList data...
3291:	Before: 	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen, ... (line shortened) ...
3292:	// Quick sort array data...
3293:	Before: 	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen, ... (line shortened) ...
3294:	// Merge sort LinkedList data...
3295:	Before: 	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen, ... (line shortened) ...
3296:	// Merge sort array data...
3297:	Before: 	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen, ... (line shortened) ...
3298:	// Heap sort LinkedList data...
3299:	Before: 	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen, ... (line shortened) ...
3300:	// Heap sort array data...
3301:	Before: 	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen, ... (line shortened) ...
3302:	// Execute the binary search on all List test data...
3303:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3304:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3305:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3306:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3307:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3308:	// Execute the binary search on all Array test data...
3309:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3310:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3311:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3312:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3313:	[mono,pork,abbr,khan,Arin,Suzy,Emil,Noel,dodo,Even,Rivi,Puff,twos,said,rely,pint,Arny,Elma,thud,cars,Raff,Abby,caws,huhs,airy,bump,rime,roof,soak,Kory,lank,misc,Maye,peke,Trev,were,illy,teen,Otho,Nice ... (line shortened) ...
3314:	Computer Science 42SAP - Binary Trees Post Secondary content running simulated:............
3315:	// Constants/variables for creating random values...
3316:	// Creating some TreeNode objects...
3317:	// Linking the TreeNodes...
3318:	// Testing TreeNode equals...
3319:	// Testing TreeNode toString...
3320:	75
3321:	14
3322:	77
3323:	// Creating a Tree object...
3324:	// Test the insert method...
3325:	// Insert one more...
3326:	// Test the search of the tree...
3327:	Should be found     = true
3328:	Should NOT be found = false
3329:	// Test toString() and pre, post, in order traversals
3330:	Binary Tree:
Order: [78,47,53,77,65,18]
Pre:   [78,47,18,53,77,65]
Post:  [18,65,77,53,47,78]
In:    [18,47,53,65,77,78]
3331:	// Building second tree (test clone) and test equals
3332:	1st tree -> [18,47,53,65,77,78]
3333:	2nd tree -> [19,24,36,41,75,92]
3334:	1st!=2nd
3335:	// Building a third tree (test clone) and test equals
3336:	1st tree -> [18,47,53,65,77,78]
3337:	3rd tree -> [18,47,53,65,77,78]
3338:	1st==3rd
3339:	// Build all our data structures from each other...
3340:	// Create variable objects...
3341:	// Create array from variables...
3342:	// Create LinkedList from array...
3343:	// Create Stack from LinkedList...
3344:	// Create Queue from Stack...
3345:	// Create Tree from Queue...
3346:	// Output variables,array,list,stack,queue,tree...
3347:	walsh
3348:	eldin
3349:	oking
3350:	warty
3351:	berte
3352:	[walsh,eldin,oking,warty,berte]
3353:	[walsh,eldin,oking,warty,berte]
3354:	Stack top -> [walsh,eldin,oking,warty,berte] <- bottom
3355:	Queue back -> [walsh,eldin,oking,warty,berte] <- front
3356:	Binary Tree:
Order: [walsh,eldin,oking,warty,berte]
Pre:   [walsh,eldin,berte,oking,warty]
Post:  [berte,oking,eldin,warty,walsh]
In:    [berte,eldin,oking,walsh,warty]
3357:	// Now re-building queue from tree
3358:	// Now re-building stack from queue
3359:	// Now re-building LinkedList from stack...
3360:	// Now re-building array from LinkedList...
3361:	// Output array,list,stack,queue,tree again...
3362:	[berte,eldin,oking,walsh,warty]
3363:	[berte,eldin,oking,walsh,warty]
3364:	Stack top -> [berte,eldin,oking,walsh,warty] <- bottom
3365:	Queue back -> [berte,eldin,oking,walsh,warty] <- front
3366:	Binary Tree:
Order: [walsh,eldin,oking,warty,berte]
Pre:   [walsh,eldin,berte,oking,warty]
Post:  [berte,oking,eldin,warty,walsh]
In:    [berte,eldin,oking,walsh,warty]
